(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function () {
	"use strict";	

	require('./modules/config.js');
	require('./modules/ui.js');
	require('./modules/builder.js');
	require('./modules/utils.js');
	require('./modules/canvasElement.js');
	require('./modules/styleeditor.js');
	require('./modules/content.js');
	require('./modules/export.js');
	require('./modules/preview.js');

}());
},{"./modules/builder.js":2,"./modules/canvasElement.js":3,"./modules/config.js":4,"./modules/content.js":5,"./modules/export.js":6,"./modules/preview.js":8,"./modules/styleeditor.js":9,"./modules/ui.js":10,"./modules/utils.js":11}],2:[function(require,module,exports){
(function () {
	"use strict";

    var siteBuilderUtils = require('./utils.js');
    var bConfig = require('./config.js');
    var appUI = require('./ui.js').appUI;
    var publisher = require('../vendor/publisher');


	 /*
        Basic Builder UI initialisation
    */
    var builderUI = {
        
        allBlocks: {},                                              //holds all blocks loaded from the server
        menuWrapper: document.getElementById('menu'),
        primarySideMenuWrapper: document.getElementById('main'),
        buttonBack: document.getElementById('backButton'),
        buttonBackConfirm: document.getElementById('leavePageButton'),
        
        siteBuilderModes: document.getElementById('siteBuilderModes'),
        aceEditors: {},
        frameContents: '',                                      //holds frame contents
        templateID: 0,                                          //holds the template ID for a page (???)
        radioBlockMode: document.getElementById('modeBlock'),
                
        modalDeleteBlock: document.getElementById('deleteBlock'),
        modalResetBlock: document.getElementById('resetBlock'),
        modalDeletePage: document.getElementById('deletePage'),
        buttonDeletePageConfirm: document.getElementById('deletePageConfirm'),
                
        tempFrame: {},

        currentResponsiveMode: {},
                
        init: function(){
                                                
            //load blocks
            $.getJSON('elements.json?v=12345678', function(data){ builderUI.allBlocks = data; builderUI.implementBlocks(); });
            
            //sitebar hover animation action
            $(this.menuWrapper).on('mouseenter', function(){
                
                $(this).stop().animate({'left': '0px'}, 500);
                
            }).on('mouseleave', function(){
                
                $(this).stop().animate({'left': '-190px'}, 500);
                
                $('#menu #main a').removeClass('active');
                $('.menu .second').stop().animate({
                    width: 0
                }, 500, function(){
                    $('#menu #second').hide();
                });
                
            });
            
            //prevent click event on ancors in the block section of the sidebar
            $(this.primarySideMenuWrapper).on('click', 'a:not(.actionButtons)', function(e){e.preventDefault();});
            
            $(this.buttonBack).on('click', this.backButton);
            $(this.buttonBackConfirm).on('click', this.backButtonConfirm);
            
            //notify the user of pending chnages when clicking the back button
            $(window).bind('beforeunload', function(){
                if( site.pendingChanges === true ) {
                    return 'Your site contains changed which haven\'t been saved yet. Are you sure you want to leave?';
                }
            });

        },
        
        
        /*
            builds the blocks into the site bar
        */
        implementBlocks: function() {

            var newItem, loaderFunction;
            
            for( var key in this.allBlocks.elements ) {
                
                var niceKey = key.toLowerCase().replace(" ", "_");
                
                $('<li><a href="" id="'+niceKey+'">'+key+'</a></li>').appendTo('#menu #main ul#elementCats');
                
                for( var x = 0; x < this.allBlocks.elements[key].length; x++ ) {
                    
                    if( this.allBlocks.elements[key][x].thumbnail === null ) {//we'll need an iframe
                        
                        //build us some iframes!
                        
                        if( this.allBlocks.elements[key][x].sandbox ) {
                            
                            if( this.allBlocks.elements[key][x].loaderFunction ) {
                                loaderFunction = 'data-loaderfunction="'+this.allBlocks.elements[key][x].loaderFunction+'"';
                            }
                            
                            newItem = $('<li class="element '+niceKey+'"><iframe src="'+this.allBlocks.elements[key][x].url+'" scrolling="no" sandbox="allow-same-origin"></iframe></li>');
                        
                        } else {
                            
                            newItem = $('<li class="element '+niceKey+'"><iframe src="about:blank" scrolling="no"></iframe></li>');
                        
                        }
                        
                        newItem.find('iframe').uniqueId();
                        newItem.find('iframe').attr('src', this.allBlocks.elements[key][x].url);
                    
                    } else {//we've got a thumbnail
                        
                        if( this.allBlocks.elements[key][x].sandbox ) {
                            
                            if( this.allBlocks.elements[key][x].loaderFunction ) {
                                loaderFunction = 'data-loaderfunction="'+this.allBlocks.elements[key][x].loaderFunction+'"';
                            }
                            
                            newItem = $('<li class="element '+niceKey+'"><img src="'+this.allBlocks.elements[key][x].thumbnail+'" data-srcc="'+this.allBlocks.elements[key][x].url+'" data-height="'+this.allBlocks.elements[key][x].height+'" data-sandbox="" '+loaderFunction+'></li>');
                            
                        } else {
                                
                            newItem = $('<li class="element '+niceKey+'"><img src="'+this.allBlocks.elements[key][x].thumbnail+'" data-srcc="'+this.allBlocks.elements[key][x].url+'" data-height="'+this.allBlocks.elements[key][x].height+'"></li>');
                                
                        }
                    }
                    
                    newItem.appendTo('#menu #second ul#elements');
            
                    //zoomer works

                    var theHeight;
                    
                    if( this.allBlocks.elements[key][x].height ) {
                        
                        theHeight = this.allBlocks.elements[key][x].height*0.25;
                    
                    } else {
                        
                        theHeight = 'auto';
                        
                    }
                    
                    newItem.find('iframe').zoomer({
                        zoom: 0.25,
                        width: 270,
                        height: theHeight,
                        message: "Drag&Drop Me!"
                    });
                
                }
            
            }
            
            //draggables
            builderUI.makeDraggable();
            
        },
                
        
        /*
            event handler for when the back link is clicked
        */
        backButton: function() {
            
            if( site.pendingChanges === true ) {
                $('#backModal').modal('show');
                return false;
            }
            
        },
        
        
        /*
            button for confirming leaving the page
        */
        backButtonConfirm: function() {
            
            site.pendingChanges = false;//prevent the JS alert after confirming user wants to leave
            
        },
        
        
        /*
            activates block mode
        */
        activateBlockMode: function() {
                                    
            //trigger custom event
            $('body').trigger('modeBlocks');
            
        },
        
       
        /*
            makes the blocks and templates in the sidebar draggable onto the canvas
        */
        makeDraggable: function() {
                        
            $('#elements li, #templates li').each( function () {

                $(this).draggable({
                    helper: function() {
                        return $('<div style="height: 100px; width: 300px; background: #F9FAFA; box-shadow: 5px 5px 1px rgba(0,0,0,0.1); text-align: center; line-height: 100px; font-size: 28px; color: #16A085"><span class="fui-list"></span></div>');
                    },
                    revert: 'invalid',
                    appendTo: 'body',
                    connectToSortable: '#pageList > ul',
                    start: function(){
                        site.moveMode('on');
                    },
                    stop: function (event, ui) {}
                
                }); 
            
            });
            
            $('#elements li a').each(function(){
                
                $(this).unbind('click').bind('click', function(e){
                    e.preventDefault();
                });
            
            });
            
        },
        
        
        /*
            Implements the site on the canvas, called from the Site object when the siteData has completed loading
        */
        populateCanvas: function() {

            var i,
                counter = 1;
                        
            //loop through the pages
                                    
            for( i in site.pages ) {
                
                var newPage = new Page(i, site.pages[i], counter);
                                            
                counter++;
                                
            }
            
            //activate the first page
            if(site.sitePages.length > 0) {
                site.sitePages[0].selectPage();
            }

            site.isEmpty();
                                    
        },


        /*
            Canvas loading on/off
        */
        canvasLoading: function (value) {

            if ( value === 'on' && document.getElementById('frameWrapper').querySelectorAll('#canvasOverlay').length === 0 ) {

                var overlay = document.createElement('DIV');

                overlay.style.display = 'flex';
                $(overlay).hide();
                overlay.id = 'canvasOverlay';

                overlay.innerHTML = '<div class="loader"><span>{</span><span>}</span></div>';

                document.getElementById('frameWrapper').appendChild(overlay);

                $('#canvasOverlay').fadeIn(500);

            } else if ( value === 'off' && document.getElementById('frameWrapper').querySelectorAll('#canvasOverlay').length === 1 ) {

                if ( site.loaded() ) {

                    $('#canvasOverlay').fadeOut(500, function () {
                        this.remove();
                    });

                }

            }

        }
        
    };


    /*
        Page constructor
    */
    function Page (pageName, page, counter) {
    
        this.name = pageName || "";
        this.pageID = page.pages_id || 0;
        this.blocks = [];
        this.parentUL = {}; //parent UL on the canvas
        this.status = '';//'', 'new' or 'changed'
        this.scripts = [];//tracks script URLs used on this page
        
        this.pageSettings = {
            title: page.pages_title || '',
            meta_description: page.meta_description || '',
            meta_keywords: page.meta_keywords || '',
            header_includes: page.header_includes || '',
            page_css: page.page_css || ''
        };
                
        this.pageMenuTemplate = '<a href="" class="menuItemLink">page</a><span class="pageButtons"><a href="" class="fileEdit fui-new"></a><a href="" class="fileDel fui-cross"><a class="btn btn-xs btn-primary btn-embossed fileSave fui-check" href="#"></a></span></a></span>';
        
        this.menuItem = {};//reference to the pages menu item for this page instance
        this.linksDropdownItem = {};//reference to the links dropdown item for this page instance
        
        this.parentUL = document.createElement('UL');
        this.parentUL.setAttribute('id', "page"+counter);
                
        /*
            makes the clicked page active
        */
        this.selectPage = function() {
            
            //console.log('select:');
            //console.log(this.pageSettings);
                        
            //mark the menu item as active
            site.deActivateAll();
            $(this.menuItem).addClass('active');
                        
            //let Site know which page is currently active
            site.setActive(this);
            
            //display the name of the active page on the canvas
            site.pageTitle.innerHTML = this.name;
            
            //load the page settings into the page settings modal
            /*site.inputPageSettingsTitle.value = this.pageSettings.title;
            site.inputPageSettingsMetaDescription.value = this.pageSettings.meta_description;
            site.inputPageSettingsMetaKeywords.value = this.pageSettings.meta_keywords;
            site.inputPageSettingsIncludes.value = this.pageSettings.header_includes;
            site.inputPageSettingsPageCss.value = this.pageSettings.page_css;*/ 
                          
            //trigger custom event
            $('body').trigger('changePage');
            
            //reset the heights for the blocks on the current page
            for( var i in this.blocks ) {
                
                if( Object.keys(this.blocks[i].frameDocument).length > 0 ){
                    this.blocks[i].heightAdjustment();
                }
            
            }
            
            //show the empty message?
            this.isEmpty();
                                    
        };
        
        /*
            changed the location/order of a block within a page
        */
        this.setPosition = function(frameID, newPos) {
            
            //we'll need the block object connected to iframe with frameID
            
            for(var i in this.blocks) {
                
                if( this.blocks[i].frame.getAttribute('id') === frameID ) {
                    
                    //change the position of this block in the blocks array
                    this.blocks.splice(newPos, 0, this.blocks.splice(i, 1)[0]);
                    
                }
                
            }
                        
        };
        
        /*
            delete block from blocks array
        */
        this.deleteBlock = function(block) {
            
            //remove from blocks array
            for( var i in this.blocks ) {
                if( this.blocks[i] === block ) {
                    //found it, remove from blocks array
                    this.blocks.splice(i, 1);
                }
            }
            
            site.setPendingChanges(true);
            
        };
        
        /*
            setup for editing a page name
        */
        this.editPageName = function() {
            
            if( !this.menuItem.classList.contains('edit') ) {
            
                //hide the link
                this.menuItem.querySelector('a.menuItemLink').style.display = 'none';
            
                //insert the input field
                var newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.setAttribute('name', 'page');
                newInput.setAttribute('value', this.name);
                this.menuItem.insertBefore(newInput, this.menuItem.firstChild);
                    
                newInput.focus();
        
                var tmpStr = newInput.getAttribute('value');
                newInput.setAttribute('value', '');
                newInput.setAttribute('value', tmpStr);
                            
                this.menuItem.classList.add('edit');
            
            }
            
        };
        
        /*
            Updates this page's name (event handler for the save button)
        */
        this.updatePageNameEvent = function(el) {
            
            if( this.menuItem.classList.contains('edit') ) {
            
                //el is the clicked button, we'll need access to the input
                var theInput = this.menuItem.querySelector('input[name="page"]');
                
                //make sure the page's name is OK
                if( site.checkPageName(theInput.value) ) {
                   
                    this.name = site.prepPageName( theInput.value );
            
                    this.menuItem.querySelector('input[name="page"]').remove();
                    this.menuItem.querySelector('a.menuItemLink').innerHTML = this.name;
                    this.menuItem.querySelector('a.menuItemLink').style.display = 'block';
            
                    this.menuItem.classList.remove('edit');
                
                    //update the links dropdown item
                    this.linksDropdownItem.text = this.name;
                    this.linksDropdownItem.setAttribute('value', this.name+".html");
                    
                    //update the page name on the canvas
                    site.pageTitle.innerHTML = this.name;
            
                    //changed page title, we've got pending changes
                    site.setPendingChanges(true);
                                        
                } else {
                    
                    alert(site.pageNameError);
                    
                }
                                        
            }
            
        };
        
        /*
            deletes this entire page
        */
        this.delete = function() {
                        
            //delete from the Site
            for( var i in site.sitePages ) {
                
                if( site.sitePages[i] === this ) {//got a match!
                    
                    //delete from site.sitePages
                    site.sitePages.splice(i, 1);
                    
                    //delete from canvas
                    this.parentUL.remove();
                    
                    //add to deleted pages
                    site.pagesToDelete.push(this.name);
                    
                    //delete the page's menu item
                    this.menuItem.remove();
                    
                    //delet the pages link dropdown item
                    this.linksDropdownItem.remove();
                    
                    //activate the first page
                    site.sitePages[0].selectPage();
                    
                    //page was deleted, so we've got pending changes
                    site.setPendingChanges(true);
                    
                }
                
            }
                        
        };
        
        /*
            checks if the page is empty, if so show the 'empty' message
        */
        this.isEmpty = function() {
            
            if( this.blocks.length === 0 ) {
                
                site.messageStart.style.display = 'block';
                site.divFrameWrapper.classList.add('empty');
                             
            } else {
                
                site.messageStart.style.display = 'none';
                site.divFrameWrapper.classList.remove('empty');
                
            }
                        
        };
            
        /*
            preps/strips this page data for a pending ajax request
        */
        this.prepForSave = function() {
            
            var page = {};
                    
            page.blocks = [];
                    
            //process the blocks
                    
            for( var x = 0; x < this.blocks.length; x++ ) {
                        
                var block = {};
                        
                if( this.blocks[x].sandbox ) {
                            
                    block.frames_content = "<html>"+$('#sandboxes #'+this.blocks[x].sandbox).contents().find('html').html()+"</html>";
                    block.frames_sandbox = true;
                    block.frames_loaderFunction = this.blocks[x].sandbox_loader;
                            
                } else {
                                                        
                    block.frames_content = this.blocks[x].frameDocument.documentElement.querySelector( '#page' ).outerHTML;
                    block.frames_sandbox = false;
                    block.frames_loaderFunction = '';
                            
                }
                        
                block.frames_height = this.blocks[x].frameHeight;
                block.frames_original_url = this.blocks[x].originalUrl;
                if ( this.blocks[x].global ) block.frames_global = true;
                                                                
                page.blocks.push(block);
                        
            }
            
            return page;
            
        };
            
        /*
            generates the full page, using skeleton.html
        */
        this.fullPage = function() {
            
            var page = this;//reference to self for later
            page.scripts = [];//make sure it's empty, we'll store script URLs in there later
                        
            var newDocMainParent = $('iframe#skeleton').contents().find( bConfig.pageContainer );
            
            //empty out the skeleton first
            $('iframe#skeleton').contents().find( bConfig.pageContainer ).html('');
            
            //remove old script tags
            $('iframe#skeleton').contents().find( 'script' ).each(function(){
                $(this).remove();
            });

            var theContents;
                        
            for( var i in this.blocks ) {
                
                //grab the block content
                if (this.blocks[i].sandbox !== false) {
                                
                    theContents = $('#sandboxes #'+this.blocks[i].sandbox).contents().find( bConfig.pageContainer ).clone();
                            
                } else {
                                
                    theContents = $(this.blocks[i].frameDocument.body).find( bConfig.pageContainer ).clone();
                            
                }
                                
                //remove video frameCovers
                theContents.find('.frameCover').each(function () {
                    $(this).remove();
                });
                
                //remove video frameWrappers
                theContents.find('.videoWrapper').each(function(){
                    
                    var cnt = $(this).contents();
                    $(this).replaceWith(cnt);
                    
                });
                
                //remove style leftovers from the style editor
                for( var key in bConfig.editableItems ) {
                                                                
                    theContents.find( key ).each(function(){
                                                                        
                        $(this).removeAttr('data-selector');
                        
                        $(this).css('outline', '');
                        $(this).css('outline-offset', '');
                        $(this).css('cursor', '');
                                                                        
                        if( $(this).attr('style') === '' ) {
                                        
                            $(this).removeAttr('style');
                                    
                        }
                                
                    });
                            
                }
                
                //remove style leftovers from the content editor
                for ( var x = 0; x < bConfig.editableContent.length; ++x) {
                                
                    theContents.find( bConfig.editableContent[x] ).each(function(){
                                    
                        $(this).removeAttr('data-selector');
                                
                    });
                            
                }
                
                //append to DOM in the skeleton
                newDocMainParent.append( $(theContents.html()) );
                
                //do we need to inject any scripts?
                var scripts = $(this.blocks[i].frameDocument.body).find('script');
                var theIframe = document.getElementById("skeleton");
                                            
                if( scripts.size() > 0 ) {
                                
                    scripts.each(function(){

                        var script;
                                    
                        if( $(this).text() !== '' ) {//script tags with content
                                        
                            script = theIframe.contentWindow.document.createElement("script");
                            script.type = 'text/javascript';
                            script.innerHTML = $(this).text();
                                        
                            theIframe.contentWindow.document.body.appendChild(script);
                                    
                        } else if( $(this).attr('src') !== null && page.scripts.indexOf($(this).attr('src')) === -1 ) {
                            //use indexOf to make sure each script only appears on the produced page once
                                        
                            script = theIframe.contentWindow.document.createElement("script");
                            script.type = 'text/javascript';
                            script.src = $(this).attr('src');
                                        
                            theIframe.contentWindow.document.body.appendChild(script);
                            
                            page.scripts.push($(this).attr('src'));
                                    
                        }
                                
                    });
                            
                }
            
            }
            
            console.log(this.scripts);
            
        };
            
        /*
            clear out this page
        */
        this.clear = function() {
            
            var block = this.blocks.pop();
            
            while( block !== undefined ) {
                
                block.delete();
                
                block = this.blocks.pop();
                
            }
                                    
        };

        /*
            Height adjustment for all blocks on the page
        */
        this.heightAdjustment = function () {

            for ( var i = 0; i < this.blocks.length; i++ ) {
                this.blocks[i].heightAdjustment();
            }

        };


        /*
            Checks if all blocks on this page have finished loading
        */
        this.loaded = function () {

            var i;

            for ( i = 0; i < this.blocks.length; i++ ) {

                if ( !this.blocks[i].loaded ) return false;

            }

            return true;

        };
         
        
        //loop through the frames/blocks
        
        if( page.hasOwnProperty('blocks') ) {
        
            for( var x = 0; x < page.blocks.length; x++ ) {
            
                //create new Block
            
                var newBlock = new Block();
            
                page.blocks[x].src = page.blocks[x].frames_original_url;
                
                //sandboxed block?
                if( page.blocks[x].frames_sandbox === '1') {
                                        
                    newBlock.sandbox = true;
                    newBlock.sandbox_loader = page.blocks[x].frames_loaderfunction;
                
                }
                        
                newBlock.frameID = page.blocks[x].frames_id;
                if ( page.blocks[x].frames_global ) newBlock.global = true;
                newBlock.createParentLI(page.blocks[x].frames_height);
                newBlock.createFrame(page.blocks[x]);
                newBlock.createFrameCover();
                newBlock.insertBlockIntoDom(this.parentUL);
                newBlock.contentAfterLoad = page.blocks[x].frames_content;
                                                                    
                //add the block to the new page
                this.blocks.push(newBlock);

            }
            
        }
        
        //add this page to the site object
        site.sitePages.push( this );
        
        //plant the new UL in the DOM (on the canvas)
        site.divCanvas.appendChild(this.parentUL);
        
        //make the blocks/frames in each page sortable
        
        var thePage = this;
        
        $(this.parentUL).sortable({
            revert: true,
            placeholder: "drop-hover",
            handle: '.dragBlock',
            cancel: '',
            stop: function () {
                site.moveMode('off');
                site.setPendingChanges(true);
                if ( !site.loaded() ) builderUI.canvasLoading('on');
            },
            beforeStop: function(event, ui){
                
                //template or regular block?
                var attr = ui.item.attr('data-frames');

                var newBlock;
                    
                if (typeof attr !== typeof undefined && attr !== false) {//template, build it
                 
                    $('#start').hide();
                                        
                    //clear out all blocks on this page    
                    thePage.clear();
                                            
                    //create the new frames
                    var frameIDs = ui.item.attr('data-frames').split('-');
                    var heights = ui.item.attr('data-heights').split('-');
                    var urls = ui.item.attr('data-originalurls').split('-');
                        
                    for( var x = 0; x < frameIDs.length; x++) {
                                                
                        newBlock = new Block();
                        newBlock.createParentLI(heights[x]);
                        
                        var frameData = {};
                        
                        frameData.src = 'sites/getframe/'+frameIDs[x];
                        frameData.frames_original_url = 'sites/getframe/'+frameIDs[x];
                        frameData.frames_height = heights[x];
                        
                        newBlock.createFrame( frameData );
                        newBlock.createFrameCover();
                        newBlock.insertBlockIntoDom(thePage.parentUL);
                        
                        //add the block to the new page
                        thePage.blocks.push(newBlock);
                        
                        //dropped element, so we've got pending changes
                        site.setPendingChanges(true);
                            
                    }
                
                    //set the tempateID
                    builderUI.templateID = ui.item.attr('data-pageid');
                                                                                    
                    //make sure nothing gets dropped in the lsit
                    ui.item.html(null);
                        
                    //delete drag place holder
                    $('body .ui-sortable-helper').remove();
                    
                } else {//regular block
                
                    //are we dealing with a new block being dropped onto the canvas, or a reordering og blocks already on the canvas?
                
                    if( ui.item.find('.frameCover > button').size() > 0 ) {//re-ordering of blocks on canvas
                    
                        //no need to create a new block object, we simply need to make sure the position of the existing block in the Site object
                        //is changed to reflect the new position of the block on th canvas
                    
                        var frameID = ui.item.find('iframe').attr('id');
                        var newPos = ui.item.index();
                    
                        site.activePage.setPosition(frameID, newPos);
                                        
                    } else {//new block on canvas
                                                
                        //new block                    
                        newBlock = new Block();
                                
                        newBlock.placeOnCanvas(ui);
                                    
                    }
                    
                }
                
            },
            start: function (event, ui) {

                site.moveMode('on');

                if( ui.item.find('.frameCover').size() !== 0 ) {
                    builderUI.frameContents = ui.item.find('iframe').contents().find( bConfig.pageContainer ).html();
                }
            
            },
            over: function(){
                    
                $('#start').hide();
                
            }
        });
        
        //add to the pages menu
        this.menuItem = document.createElement('LI');
        this.menuItem.innerHTML = this.pageMenuTemplate;
        
        $(this.menuItem).find('a:first').text(pageName).attr('href', '#page'+counter);
        
        var theLink = $(this.menuItem).find('a:first').get(0);
        
        //bind some events
        this.menuItem.addEventListener('click', this, false);
        
        this.menuItem.querySelector('a.fileEdit').addEventListener('click', this, false);
        this.menuItem.querySelector('a.fileSave').addEventListener('click', this, false);
        this.menuItem.querySelector('a.fileDel').addEventListener('click', this, false);

        //no del button for the index page
        if( counter === 1 ) this.menuItem.querySelector('a.fileDel').remove();
        
        site.pagesMenu.appendChild(this.menuItem);
                    
    }
    
    Page.prototype.handleEvent = function(event) {
        switch (event.type) {
            case "click": 
                                
                if( event.target.classList.contains('fileEdit') ) {
                
                    this.editPageName();
                    
                } else if( event.target.classList.contains('fileSave') ) {
                                        
                    this.updatePageNameEvent(event.target);
                
                } else if( event.target.classList.contains('fileDel') ) {
                    
                    var thePage = this;
                
                    $(builderUI.modalDeletePage).modal('show');
                    
                    $(builderUI.modalDeletePage).off('click', '#deletePageConfirm').on('click', '#deletePageConfirm', function() {
                        
                        thePage.delete();
                        
                        $(builderUI.modalDeletePage).modal('hide');
                        
                    });
                                        
                } else {
                    
                    this.selectPage();
                
                }
                
        }
    };


    /*
        Block constructor
    */
    function Block () {
        
        this.frameID = 0;
        this.loaded = false;
        this.sandbox = false;
        this.sandbox_loader = '';
        this.status = '';//'', 'changed' or 'new'
        this.global = false;
        this.originalUrl = '';
        
        this.parentLI = {};
        this.frameCover = {};
        this.frame = {};
        this.frameDocument = {};
        this.frameHeight = 0;
        
        this.annot = {};
        this.annotTimeout = {};

        this.contentAfterLoad = '';
        
        /*
            creates the parent container (LI)
        */
        this.createParentLI = function(height) {
            
            this.parentLI = document.createElement('LI');
            this.parentLI.setAttribute('class', 'element');
            //this.parentLI.setAttribute('style', 'height: '+height+'px');
            
        };
        
        /*
            creates the iframe on the canvas
        */
        this.createFrame = function(frame) {
                        
            this.frame = document.createElement('IFRAME');
            this.frame.setAttribute('frameborder', 0);
            this.frame.setAttribute('scrolling', 0);
            this.frame.setAttribute('src', frame.src);
            this.frame.setAttribute('data-originalurl', frame.frames_original_url);
            this.originalUrl = frame.frames_original_url;
                        
            $(this.frame).uniqueId();
            
            //sandbox?
            if( this.sandbox !== false ) {
                            
                this.frame.setAttribute('data-loaderfunction', this.sandbox_loader);
                this.frame.setAttribute('data-sandbox', this.sandbox);
                            
                //recreate the sandboxed iframe elsewhere
                var sandboxedFrame = $('<iframe src="'+frame.src+'" id="'+this.sandbox+'" sandbox="allow-same-origin"></iframe>');
                $('#sandboxes').append( sandboxedFrame );
                            
            }
                        
        };
            
        /*
            insert the iframe into the DOM on the canvas
        */
        this.insertBlockIntoDom = function(theUL) {
            
            this.parentLI.appendChild(this.frame);
            theUL.appendChild( this.parentLI );
            
            this.frame.addEventListener('load', this, false);

            builderUI.canvasLoading('on');
            
        };
            
        /*
            sets the frame document for the block's iframe
        */
        this.setFrameDocument = function() {
            
            //set the frame document as well
            if( this.frame.contentDocument ) {
                this.frameDocument = this.frame.contentDocument;   
            } else {
                this.frameDocument = this.frame.contentWindow.document;
            }
                                    
        };
        
        /*
            creates the frame cover and block action button
        */
        this.createFrameCover = function() {
            
            //build the frame cover and block action buttons
            this.frameCover = document.createElement('DIV');
            this.frameCover.classList.add('frameCover');
            this.frameCover.classList.add('fresh');
            //this.frameCover.style.height = this.frameHeight+"px";
                    
            var delButton = document.createElement('BUTTON');
            delButton.setAttribute('class', 'btn btn-inverse btn-sm deleteBlock');
            delButton.setAttribute('type', 'button');
            delButton.innerHTML = '<i class="fui-trash"></i> <span>Remove</span>';
            delButton.addEventListener('click', this, false);
                    
            var resetButton = document.createElement('BUTTON');
            resetButton.setAttribute('class', 'btn btn-inverse btn-sm resetBlock');
            resetButton.setAttribute('type', 'button');
            resetButton.innerHTML = '<i class="fa fa-refresh"></i> <span>Reset</span>';
            resetButton.addEventListener('click', this, false);
                    
            var htmlButton = document.createElement('BUTTON');
            htmlButton.setAttribute('class', 'btn btn-inverse btn-sm htmlBlock');
            htmlButton.setAttribute('type', 'button');
            htmlButton.innerHTML = '<i class="fa fa-code"></i> <span>Source</span>';
            htmlButton.addEventListener('click', this, false);

            var dragButton = document.createElement('BUTTON');
            dragButton.setAttribute('class', 'btn btn-inverse btn-sm dragBlock');
            dragButton.setAttribute('type', 'button');
            dragButton.innerHTML = '<i class="fa fa-arrows"></i> <span>Move</span>';
            dragButton.addEventListener('click', this, false);

            var globalLabel = document.createElement('LABEL');
            globalLabel.classList.add('checkbox');
            globalLabel.classList.add('primary');
            var globalCheckbox = document.createElement('INPUT');
            globalCheckbox.type = 'checkbox';
            globalCheckbox.setAttribute('data-toggle', 'checkbox');
            globalCheckbox.checked = this.global;
            globalLabel.appendChild(globalCheckbox);
            var globalText = document.createTextNode('Global');
            globalLabel.appendChild(globalText);

            var trigger = document.createElement('span');
            trigger.classList.add('fui-gear');

            var theBlock = this;

            $(globalCheckbox).on('change', function (e) {

                theBlock.toggleGlobal(e);

            }).radiocheck();
            
            this.frameCover.appendChild(delButton);
            this.frameCover.appendChild(resetButton);
            this.frameCover.appendChild(htmlButton);
            this.frameCover.appendChild(dragButton);
            this.frameCover.appendChild(globalLabel);
            this.frameCover.appendChild(trigger);
                            
            this.parentLI.appendChild(this.frameCover);
                                                        
        };


        /*
            
        */
        this.toggleGlobal = function (e) {

            if ( e.currentTarget.checked ) this.global = true;
            else this.global = false;

            //we've got pending changes
            site.setPendingChanges(true);

        };

            
        /*
            automatically corrects the height of the block's iframe depending on its content
        */
        this.heightAdjustment = function() {
            
            if ( Object.keys(this.frameDocument).length !== 0 ) {

                var pageContainer = this.frameDocument.body;
                var height = pageContainer.offsetHeight;

                this.frame.style.height = height+"px";
                this.parentLI.style.height = height+"px";
                //this.frameCover.style.height = height+"px";
                
                this.frameHeight = height;

            }
                                                                                    
        };
            
        /*
            deletes a block
        */
        this.delete = function() {
                        
            //remove from DOM/canvas with a nice animation
            $(this.frame.parentNode).fadeOut(500, function(){
                    
                this.remove();
                    
                site.activePage.isEmpty();
                
            });
            
            //remove from blocks array in the active page
            site.activePage.deleteBlock(this);
            
            //sanbox
            if( this.sanbdox ) {
                document.getElementById( this.sandbox ).remove();   
            }
            
            //element was deleted, so we've got pending change
            site.setPendingChanges(true);
                        
        };
            
        /*
            resets a block to it's orignal state
        */
        this.reset = function(fireEvent) {

            if ( typeof fireEvent === 'undefined') fireEvent = true;
            
            //reset frame by reloading it
            this.frame.contentWindow.location.reload();
            
            //sandbox?
            if( this.sandbox ) {
                var sandboxFrame = document.getElementById(this.sandbox).contentWindow.location.reload();  
            }
            
            //element was deleted, so we've got pending changes
            site.setPendingChanges(true);

            builderUI.canvasLoading('on');

            if ( fireEvent ) publisher.publish('onBlockChange', this, 'reload');
            
        };
            
        /*
            launches the source code editor
        */
        this.source = function() {
            
            //hide the iframe
            this.frame.style.display = 'none';
            
            //disable sortable on the parentLI
            $(this.parentLI.parentNode).sortable('disable');
            
            //built editor element
            var theEditor = document.createElement('DIV');
            theEditor.classList.add('aceEditor');
            $(theEditor).uniqueId();
            
            this.parentLI.appendChild(theEditor);
            
            //build and append error drawer
            var newLI = document.createElement('LI');
            var errorDrawer = document.createElement('DIV');
            errorDrawer.classList.add('errorDrawer');
            errorDrawer.setAttribute('id', 'div_errorDrawer');
            errorDrawer.innerHTML = '<button type="button" class="btn btn-xs btn-embossed btn-default button_clearErrorDrawer" id="button_clearErrorDrawer">CLEAR</button>';
            newLI.appendChild(errorDrawer);
            errorDrawer.querySelector('button').addEventListener('click', this, false);
            this.parentLI.parentNode.insertBefore(newLI, this.parentLI.nextSibling);
            
            
            var theId = theEditor.getAttribute('id');
            var editor = ace.edit( theId );
            
            var pageContainer = this.frameDocument.querySelector( bConfig.pageContainer );
            var theHTML = pageContainer.innerHTML;
            
            editor.setValue( theHTML );
            editor.setTheme("ace/theme/twilight");
            editor.getSession().setMode("ace/mode/html");
            
            var block = this;
            
            
            editor.getSession().on("changeAnnotation", function(){
                
                block.annot = editor.getSession().getAnnotations();
                
                clearTimeout(block.annotTimeout);

                var timeoutCount;
                
                if( $('#div_errorDrawer p').size() === 0 ) {
                    timeoutCount = bConfig.sourceCodeEditSyntaxDelay;
                } else {
                    timeoutCount = 100;
                }
                
                block.annotTimeout = setTimeout(function(){
                                                            
                    for (var key in block.annot){
                    
                        if (block.annot.hasOwnProperty(key)) {
                        
                            if( block.annot[key].text !== "Start tag seen without seeing a doctype first. Expected e.g. <!DOCTYPE html>." ) {
                            
                                var newLine = $('<p></p>');
                                var newKey = $('<b>'+block.annot[key].type+': </b>');
                                var newInfo = $('<span> '+block.annot[key].text + "on line " + " <b>" + block.annot[key].row+'</b></span>');
                                newLine.append( newKey );
                                newLine.append( newInfo );
                    
                                $('#div_errorDrawer').append( newLine );
                        
                            }
                    
                        }
                
                    }
                
                    if( $('#div_errorDrawer').css('display') === 'none' && $('#div_errorDrawer').find('p').size() > 0 ) {
                        $('#div_errorDrawer').slideDown();
                    }
                        
                }, timeoutCount);
                
            
            });
            
            //buttons
            var cancelButton = document.createElement('BUTTON');
            cancelButton.setAttribute('type', 'button');
            cancelButton.classList.add('btn');
            cancelButton.classList.add('btn-danger');
            cancelButton.classList.add('btn-sm');
            cancelButton.classList.add('editCancelButton');
            cancelButton.innerHTML = '<i class="fui-cross"></i> <span>Cancel</span>';
            cancelButton.addEventListener('click', this, false);
            
            var saveButton = document.createElement('BUTTON');
            saveButton.setAttribute('type', 'button');
            saveButton.classList.add('btn');
            saveButton.classList.add('btn-primary');
            saveButton.classList.add('btn-sm');
            saveButton.classList.add('editSaveButton');
            saveButton.innerHTML = '<i class="fui-check"></i> <span>Save</span>';
            saveButton.addEventListener('click', this, false);
            
            var buttonWrapper = document.createElement('DIV');
            buttonWrapper.classList.add('editorButtons');
            
            buttonWrapper.appendChild( cancelButton );
            buttonWrapper.appendChild( saveButton );
            
            this.parentLI.appendChild( buttonWrapper );
            
            builderUI.aceEditors[ theId ] = editor;
            
        };
            
        /*
            cancels the block source code editor
        */
        this.cancelSourceBlock = function() {

            //enable draggable on the LI
            $(this.parentLI.parentNode).sortable('enable');
		
            //delete the errorDrawer
            $(this.parentLI.nextSibling).remove();
        
            //delete the editor
            this.parentLI.querySelector('.aceEditor').remove();
            $(this.frame).fadeIn(500);
                        
            $(this.parentLI.querySelector('.editorButtons')).fadeOut(500, function(){
                $(this).remove();
            });
            
        };
            
        /*
            updates the blocks source code
        */
        this.saveSourceBlock = function() {
            
            //enable draggable on the LI
            $(this.parentLI.parentNode).sortable('enable');
            
            var theId = this.parentLI.querySelector('.aceEditor').getAttribute('id');
            var theContent = builderUI.aceEditors[theId].getValue();
            
            //delete the errorDrawer
            document.getElementById('div_errorDrawer').parentNode.remove();
            
            //delete the editor
            this.parentLI.querySelector('.aceEditor').remove();
            
            //update the frame's content
            this.frameDocument.querySelector( bConfig.pageContainer ).innerHTML = theContent;
            this.frame.style.display = 'block';
            
            //sandboxed?
            if( this.sandbox ) {
                
                var sandboxFrame = document.getElementById( this.sandbox );
                var sandboxFrameDocument = sandboxFrame.contentDocument || sandboxFrame.contentWindow.document;
                
                builderUI.tempFrame = sandboxFrame;
                
                sandboxFrameDocument.querySelector( bConfig.pageContainer ).innerHTML = theContent;
                                
                //do we need to execute a loader function?
                if( this.sandbox_loader !== '' ) {
                    
                    /*
                    var codeToExecute = "sandboxFrame.contentWindow."+this.sandbox_loader+"()";
                    var tmpFunc = new Function(codeToExecute);
                    tmpFunc();
                    */
                    
                }
                
            }
            
            $(this.parentLI.querySelector('.editorButtons')).fadeOut(500, function(){
                $(this).remove();
            });
            
            //adjust height of the frame
            this.heightAdjustment();
            
            //new page added, we've got pending changes
            site.setPendingChanges(true);
            
            //block has changed
            this.status = 'changed';

            publisher.publish('onBlockChange', this, 'change');

        };
            
        /*
            clears out the error drawer
        */
        this.clearErrorDrawer = function() {
            
            var ps = this.parentLI.nextSibling.querySelectorAll('p');
                        
            for( var i = 0; i < ps.length; i++ ) {
                ps[i].remove();  
            }
                        
        };
            
        /*
            returns the full source code of the block's frame
        */
        this.getSource = function() {
            
            var source = "<html>";
            source += this.frameDocument.head.outerHTML;
            source += this.frameDocument.body.outerHTML;
            
            return source;
            
        };

        /*
            sets the source code for this block's frame
        */
        this.setSource = function (content) {

            $(this.frame).contents().find('body').html(content);

        };
            
        /*
            places a dragged/dropped block from the left sidebar onto the canvas
        */
        this.placeOnCanvas = function(ui) {
            
            //frame data, we'll need this before messing with the item's content HTML
            var frameData = {}, attr;
                
            if( ui.item.find('iframe').size() > 0 ) {//iframe thumbnail
                    
                frameData.src = ui.item.find('iframe').attr('src');
                frameData.frames_original_url = ui.item.find('iframe').attr('src');
                frameData.frames_height = ui.item.height();
                    
                //sandboxed block?
                attr = ui.item.find('iframe').attr('sandbox');
                                
                if (typeof attr !== typeof undefined && attr !== false) {
                    this.sandbox = siteBuilderUtils.getRandomArbitrary(10000, 1000000000);
                    this.sandbox_loader = ui.item.find('iframe').attr('data-loaderfunction');
                }
                                        
            } else {//image thumbnail
                    
                frameData.src = ui.item.find('img').attr('data-srcc');
                frameData.frames_original_url = ui.item.find('img').attr('data-srcc');
                frameData.frames_height = ui.item.find('img').attr('data-height');
                                    
                //sandboxed block?
                attr = ui.item.find('img').attr('data-sandbox');
                                
                if (typeof attr !== typeof undefined && attr !== false) {
                    this.sandbox = siteBuilderUtils.getRandomArbitrary(10000, 1000000000);
                    this.sandbox_loader = ui.item.find('img').attr('data-loaderfunction');
                }
                    
            }                
                                
            //create the new block object
            this.frameID = 0;
            this.parentLI = ui.item.get(0);
            this.parentLI.innerHTML = '';
            this.status = 'new';
            this.createFrame(frameData);
            this.parentLI.style.height = this.frameHeight+"px";
            this.createFrameCover();
                
            this.frame.addEventListener('load', this);
                
            //insert the created iframe
            ui.item.append($(this.frame));
                                           
            //add the block to the current page
            site.activePage.blocks.splice(ui.item.index(), 0, this);
                
            //custom event
            ui.item.find('iframe').trigger('canvasupdated');
                                
            //dropped element, so we've got pending changes
            site.setPendingChanges(true);
            
        };

        /*
            injects external JS (defined in config.js) into the block
        */
        this.loadJavascript = function () {

            var i,
                old,
                newScript;

            //remove old ones
            old = this.frameDocument.querySelectorAll('script.builder');

            for ( i = 0; i < old.length; i++ ) old[i].remove();

            //inject
            for ( i = 0; i < bConfig.externalJS.length; i++ ) {
                
                newScript = document.createElement('SCRIPT');
                newScript.classList.add('builder');
                newScript.src = bConfig.externalJS[i];

                this.frameDocument.querySelector('body').appendChild(newScript);
            
            }

        };
        
    }
    
    Block.prototype.handleEvent = function (event) {

        switch (event.type) {
            case "load": 
                this.setFrameDocument();
                this.heightAdjustment();
                this.loadJavascript();
                
                if( this.contentAfterLoad !== '' ) this.setSource(this.contentAfterLoad);

                $(this.frameCover).removeClass('fresh', 500);

                publisher.publish('onBlockLoaded', this);

                this.loaded = true;

                builderUI.canvasLoading('off');

                break;
                
            case "click":
                
                var theBlock = this;
                
                //figure out what to do next
                
                if( event.target.classList.contains('deleteBlock') || event.target.parentNode.classList.contains('deleteBlock') ) {//delete this block
                    
                    $(builderUI.modalDeleteBlock).modal('show');                    
                    
                    $(builderUI.modalDeleteBlock).off('click', '#deleteBlockConfirm').on('click', '#deleteBlockConfirm', function(){
                        theBlock.delete(event);
                        $(builderUI.modalDeleteBlock).modal('hide');
                    });
                    
                } else if( event.target.classList.contains('resetBlock') || event.target.parentNode.classList.contains('resetBlock') ) {//reset the block
                    
                    $(builderUI.modalResetBlock).modal('show'); 
                    
                    $(builderUI.modalResetBlock).off('click', '#resetBlockConfirm').on('click', '#resetBlockConfirm', function(){
                        theBlock.reset();
                        $(builderUI.modalResetBlock).modal('hide');
                    });
                       
                } else if( event.target.classList.contains('htmlBlock') || event.target.parentNode.classList.contains('htmlBlock') ) {//source code editor
                    
                    theBlock.source();
                    
                } else if( event.target.classList.contains('editCancelButton') || event.target.parentNode.classList.contains('editCancelButton') ) {//cancel source code editor
                    
                    theBlock.cancelSourceBlock();
                    
                } else if( event.target.classList.contains('editSaveButton') || event.target.parentNode.classList.contains('editSaveButton') ) {//save source code
                    
                    theBlock.saveSourceBlock();
                    
                } else if( event.target.classList.contains('button_clearErrorDrawer') ) {//clear error drawer
                    
                    theBlock.clearErrorDrawer();
                    
                }
                
        }

    };


    /*
        Site object literal
    */
    /*jshint -W003 */
    var site = {
        
        pendingChanges: false,      //pending changes or no?
        pages: {},                  //array containing all pages, including the child frames, loaded from the server on page load
        is_admin: 0,                //0 for non-admin, 1 for admin
        data: {},                   //container for ajax loaded site data
        pagesToDelete: [],          //contains pages to be deleted
                
        sitePages: [],              //this is the only var containing the recent canvas contents
        
        sitePagesReadyForServer: {},     //contains the site data ready to be sent to the server
        
        activePage: {},             //holds a reference to the page currently open on the canvas
        
        pageTitle: document.getElementById('pageTitle'),//holds the page title of the current page on the canvas
        
        divCanvas: document.getElementById('pageList'),//DIV containing all pages on the canvas
        
        pagesMenu: document.getElementById('pages'), //UL containing the pages menu in the sidebar
                
        buttonNewPage: document.getElementById('addPage'),
        liNewPage: document.getElementById('newPageLI'),
        
        inputPageSettingsTitle: document.getElementById('pageData_title'),
        inputPageSettingsMetaDescription: document.getElementById('pageData_metaDescription'),
        inputPageSettingsMetaKeywords: document.getElementById('pageData_metaKeywords'),
        inputPageSettingsIncludes: document.getElementById('pageData_headerIncludes'),
        inputPageSettingsPageCss: document.getElementById('pageData_headerCss'),
        
        buttonSubmitPageSettings: document.getElementById('pageSettingsSubmittButton'),
        
        modalPageSettings: document.getElementById('pageSettingsModal'),
        
        buttonSave: document.getElementById('savePage'),
        
        messageStart: document.getElementById('start'),
        divFrameWrapper: document.getElementById('frameWrapper'),
        
        skeleton: document.getElementById('skeleton'),

        buttonEmptyPage: document.getElementById('clearScreen'),

        actionButtons: document.querySelectorAll('.actionButtons'),
		
		autoSaveTimer: {},
        
        init: function() {

            $.getJSON("site.json", function (data) {
                
                if( data.pages !== undefined ) {
                    site.pages = data.pages;
                } else {
                    site.pages = {index: {
                        blocks: [],
                        page_id: 1,
                        pages_title: '',
                        meta_description: '',
                        meta_keywords: '',
                        header_includes: '',
                        page_css: ''
                    }};
                }

                if( data.responsiveMode ) publisher.publish('onSetMode', data.responsiveMode);

                publisher.subscribe('onBlockChange', function (block, type) {

                    if ( block.global ) {

                        for ( var i = 0; i < site.sitePages.length; i++ ) {

                            for ( var y = 0; y < site.sitePages[i].blocks.length; y ++ ) {

                                if ( site.sitePages[i].blocks[y] !== block && site.sitePages[i].blocks[y].originalUrl === block.originalUrl && site.sitePages[i].blocks[y].global ) {

                                    if ( type === 'change' ) {

                                        site.sitePages[i].blocks[y].frameDocument.body = block.frameDocument.body.cloneNode(true);

                                        publisher.publish('onBlockLoaded', site.sitePages[i].blocks[y]);

                                    } else if ( type === 'reload' ) {

                                        site.sitePages[i].blocks[y].reset(false);

                                    }

                                }

                            }

                        }

                    }

                });

                //fire custom event
                $('body').trigger('siteDataLoaded');

                builderUI.populateCanvas();
                
            });
            
            
            $(this.buttonNewPage).on('click', site.newPage);
            $(this.modalPageSettings).on('show.bs.modal', site.loadPageSettings);
            $(this.buttonSubmitPageSettings).on('click', site.updatePageSettings);
            $(this.buttonSave).on('click', function(){site.save(true);});
            $(this.buttonEmptyPage).on('click', site.emptyPage);
            
            //auto save time 
            this.autoSaveTimer = setTimeout(site.autoSave, bConfig.autoSaveTimeout);
                            
        },
        
        autoSave: function(){
                                    
            if(site.pendingChanges) {
                site.save(false);
            }
			
			window.clearInterval(this.autoSaveTimer);
            this.autoSaveTimer = setTimeout(site.autoSave, bConfig.autoSaveTimeout);
        
        },
                
        setPendingChanges: function(value) {
                        
            this.pendingChanges = value;

            this.isEmpty();
            
            if( value === true ) {
				
				//reset timer
				window.clearInterval(this.autoSaveTimer);
            	this.autoSaveTimer = setTimeout(site.autoSave, bConfig.autoSaveTimeout);
                
                $('#savePage .bLabel').text("Save now (!)");
                
                if( site.activePage.status !== 'new' ) {
                
                    site.activePage.status = 'changed';
                    
                }
			
            } else {
	
                $('#savePage .bLabel').text("Nothing to save");
				
                site.updatePageStatus('');

            }
            
        },
                   
        save: function(showConfirmModal) {

            publisher.publish('onBeforeSave');

            //disable button
            $("a#savePage").addClass('disabled');

            var originalText = $('a#savePage').find('.bLabel').text();
            var altText = $('a#savePage').find('.bLabel').attr('data-alt-text');

            $('a#savePage').find('.bLabel').text(altText);
            $('a#savePage').addClass('disabled');
                                    
            var pages = {}, theSite;

            if( site.sitePages[0].blocks.length !== 0 ) {

                for( var x = 0; x < site.sitePages.length; x++ ) {

                    if( site.sitePages[x].blocks.length !== 0 ) {

                        pages[site.sitePages[x].name] = site.sitePages[x].prepForSave();

                    } else {

                        pages[site.sitePages[x].name] = 'empty';

                    }

                }

                theSite = {
                    pages: pages
                };

            } else {

                theSite = {
                    delete: true
                };

            }

            //store current responsive mode as well
            theSite.responsiveMode = builderUI.currentResponsiveMode;

            //remove old alerts
            $('#errorModal .modal-body > *, #successModal .modal-body > *').each(function(){
                $(this).remove();
            });

            $.ajax({
                url: '_save.php',
                method: 'POST',
                data: {data: theSite},
                dataType: "json"
            }).done(function (res) {

                //enable button
                $("a#savePage").removeClass('disabled');

                if( res.responseCode === 0 ) {
                    
                    if( showConfirmModal ) {
                        $('#errorModal .modal-body').html( res.responseHTML );
                        $('#errorModal').modal('show');
                    }
                
        
                } else if( res.responseCode === 1 ) {
                                
                    //no more pending changes
                    site.setPendingChanges(false);
            
                    $('body').trigger('changePage');

                }

            });
    
        },
        
        /*
            preps the site data before sending it to the server
        */
        prepForSave: function(template) {
            
            this.sitePagesReadyForServer = {};
            
            if( template ) {//saving template, only the activePage is needed
                
                this.sitePagesReadyForServer[this.activePage.name] = this.activePage.prepForSave();
                
                this.activePage.fullPage();
                
            } else {//regular save
            
                //find the pages which need to be send to the server
                for( var i = 0; i < this.sitePages.length; i++ ) {
                                
                    if( this.sitePages[i].status !== '' ) {
                                    
                        this.sitePagesReadyForServer[this.sitePages[i].name] = this.sitePages[i].prepForSave();
                    
                    }
                
                }
            
            }
                                                                            
        },
        
        
        /*
            sets a page as the active one
        */
        setActive: function(page) {
            
            //reference to the active page
            this.activePage = page;
            
            //hide other pages
            for(var i in this.sitePages) {
                this.sitePages[i].parentUL.style.display = 'none';   
            }
            
            //display active one
            this.activePage.parentUL.style.display = 'block';
            
        },
        
        
        /*
            de-active all page menu items
        */
        deActivateAll: function() {
            
            var pages = this.pagesMenu.querySelectorAll('li');
            
            for( var i = 0; i < pages.length; i++ ) {
                pages[i].classList.remove('active');
            }
            
        },
        
        
        /*
            adds a new page to the site
        */
        newPage: function() {
            
            site.deActivateAll();
            
            //create the new page instance
            
            var pageData = [];
            var temp = {
                pages_id: 0
            };
            pageData[0] = temp;
            
            var newPageName = 'page'+(site.sitePages.length+1);
            
            var newPage = new Page(newPageName, pageData, site.sitePages.length+1);
            
            newPage.status = 'new';
            
            newPage.selectPage();
            newPage.editPageName();
        
            newPage.isEmpty();
                        
            site.setPendingChanges(true);
                                    
        },
        
        
        /*
            checks if the name of a page is allowed
        */
        checkPageName: function(pageName) {
            
            //make sure the name is unique
            for( var i in this.sitePages ) {
                
                if( this.sitePages[i].name === pageName && this.activePage !== this.sitePages[i] ) {
                    this.pageNameError = "The page name must be unique.";
                    return false;
                }   
                
            }
            
            return true;
            
        },
        
        
        /*
            removes unallowed characters from the page name
        */
        prepPageName: function(pageName) {
            
            pageName = pageName.replace(' ', '');
            pageName = pageName.replace(/[?*!.|&#;$%@"<>()+,]/g, "");
            
            return pageName;
            
        },
        
        
        /*
            save page settings for the current page
        */
        updatePageSettings: function() {
            
            site.activePage.pageSettings.title = site.inputPageSettingsTitle.value;
            site.activePage.pageSettings.meta_description = site.inputPageSettingsMetaDescription.value;
            site.activePage.pageSettings.meta_keywords = site.inputPageSettingsMetaKeywords.value;
            site.activePage.pageSettings.header_includes = site.inputPageSettingsIncludes.value;
            site.activePage.pageSettings.page_css = site.inputPageSettingsPageCss.value;
                        
            site.setPendingChanges(true);
            
            $(site.modalPageSettings).modal('hide');
            
        },
        
        
        /*
            update page statuses
        */
        updatePageStatus: function(status) {
            
            for( var i in this.sitePages ) {
                this.sitePages[i].status = status;   
            }
            
        },


        /*
            Clears all the blocks on the current page
        */
        emptyPage: function () {

            site.activePage.clear();

        },


        /*
            Checks if the entire page is empty, if so, disable action buttons
        */
        isEmpty: function () {

            var x = 0;

            if(this.sitePages.length === 1 && this.activePage.blocks.length === 0) {
                for( x = 0; x < this.actionButtons.length; x++ ) {
                    this.actionButtons[x].classList.add('disabled');
                }
            } else {
                for( x = 0; x < this.actionButtons.length; x++ ) {
                    this.actionButtons[x].classList.remove('disabled');
                }
            }

        },


        /*
            Checks all the blocks in this site have finished loading
        */
        loaded: function () {

            var i;

            for ( i = 0; i < this.sitePages.length; i++ ) {

                if ( !this.sitePages[i].loaded() ) return false;

            }

            return true;

        },


        /*
            Make every block have an overlay during dragging to prevent mouse event issues
        */
        moveMode: function (value) {

            var i;

            for ( i = 0; i < this.activePage.blocks.length; i++ ) {

                if ( value === 'on' ) this.activePage.blocks[i].frameCover.classList.add('move');
                else if ( value === 'off' ) this.activePage.blocks[i].frameCover.classList.remove('move');

            }

        }
    
    };

    builderUI.init(); site.init();

    
    //**** EXPORTS
    module.exports.site = site;
    module.exports.builderUI = builderUI;

}());
},{"../vendor/publisher":12,"./config.js":4,"./ui.js":10,"./utils.js":11}],3:[function(require,module,exports){
(function () {
    "use strict";

    var siteBuilder = require('./builder.js');

    /*
        constructor function for Element
    */
    module.exports.Element = function (el) {
                
        this.element = el;
        this.sandbox = false;
        this.parentFrame = {};
        this.parentBlock = {};//reference to the parent block element
        this.editableAttributes = [];
        
        //make current element active/open (being worked on)
        this.setOpen = function() {
            
            $(this.element).off('mouseenter mouseleave click');
                                            
            $(this.element).css({'outline': '2px solid rgba(233,94,94,0.5)', 'outline-offset':'-2px', 'cursor': 'pointer'});
            
        };
        
        //sets up hover and click events, making the element active on the canvas
        this.activate = function() {
            
            var element = this;

            //data attributes for color
            if ( this.element.tagName === 'A' ) $(this.element).data('color', getComputedStyle(this.element).color);
            
            $(this.element).css({'outline': 'none', 'cursor': 'inherit'});
                                    
            $(this.element).on('mouseenter', function(e) {

                e.stopPropagation();
                                    
                $(this).css({'outline': '2px solid rgba(233,94,94,0.5)', 'outline-offset': '-2px', 'cursor': 'pointer'});
            
            }).on('mouseleave', function() {
                
                $(this).css({'outline': '', 'cursor': '', 'outline-offset': ''});
            
            }).on('click', function(e) {
                                                                
                e.preventDefault();
                e.stopPropagation();
                
                element.clickHandler(this);
            
            });
            
        };
        
        this.deactivate = function() {
            
            $(this.element).off('mouseenter mouseleave click');
            $(this.element).css({'outline': 'none', 'cursor': 'inherit'});

        };
        
        //removes the elements outline
        this.removeOutline = function() {
            
            $(this.element).css({'outline': 'none', 'cursor': 'inherit'});
            
        };
        
        //sets the parent iframe
        this.setParentFrame = function() {
            
            var doc = this.element.ownerDocument;
            var w = doc.defaultView || doc.parentWindow;
            var frames = w.parent.document.getElementsByTagName('iframe');
            
            for (var i= frames.length; i-->0;) {
                
                var frame= frames[i];
                
                try {
                    var d= frame.contentDocument || frame.contentWindow.document;
                    if (d===doc)
                        this.parentFrame = frame;
                } catch(e) {}
            }
            
        };
        
        //sets this element's parent block reference
        this.setParentBlock = function() {
            
            //loop through all the blocks on the canvas
            for( var i = 0; i < siteBuilder.site.sitePages.length; i++ ) {
                                
                for( var x = 0; x < siteBuilder.site.sitePages[i].blocks.length; x++ ) {
                                        
                    //if the block's frame matches this element's parent frame
                    if( siteBuilder.site.sitePages[i].blocks[x].frame === this.parentFrame ) {
                        //create a reference to that block and store it in this.parentBlock
                        this.parentBlock = siteBuilder.site.sitePages[i].blocks[x];
                    }
                
                }
                
            }
                        
        };
        
        
        this.setParentFrame();
        
        /*
            is this block sandboxed?
        */
        
        if( this.parentFrame.getAttribute('data-sandbox') ) {
            this.sandbox = this.parentFrame.getAttribute('data-sandbox');   
        }
                
    };

}());
},{"./builder.js":2}],4:[function(require,module,exports){
(function () {
	"use strict";
        
    module.exports.pageContainer = "#page";
    
    module.exports.editableItems = {
        'span.fa': ['color', 'font-size'],
        '.bg.bg1': ['background-color'],
        'nav a': ['color', 'font-weight', 'text-transform'],
        'img': ['border-top-left-radius', 'border-top-right-radius', 'border-bottom-left-radius', 'border-bottom-right-radius', 'border-color', 'border-style', 'border-width'],
        'hr.dashed': ['border-color', 'border-width'],
        '.divider > span': ['color', 'font-size'],
        'hr.shadowDown': ['margin-top', 'margin-bottom'],
        '.footer a': ['color'],
        '.social a': ['color'],
        '.bg.bg1, .bg.bg2, .header10, .header11': ['background-image', 'background-color'],
        '.frameCover': [],
        '.editContent': ['content', 'color', 'font-size', 'background-color', 'font-family'],
        'a.btn, button.btn': ['border-radius', 'font-size', 'background-color'],
        '#pricing_table2 .pricing2 .bottom li': ['content']
    };
    
    module.exports.editableItemOptions = {
        'nav a : font-weight': ['400', '700'],
        'a.btn, button.btn : border-radius': ['0px', '4px', '10px'],
        'img : border-style': ['none', 'dotted', 'dashed', 'solid'],
        'img : border-width': ['1px', '2px', '3px', '4px'],
        'h1, h2, h3, h4, h5, p : font-family': ['default', 'Lato', 'Helvetica', 'Arial', 'Times New Roman'],
        'h2 : font-family': ['default', 'Lato', 'Helvetica', 'Arial', 'Times New Roman'],
        'h3 : font-family': ['default', 'Lato', 'Helvetica', 'Arial', 'Times New Roman'],
        'p : font-family': ['default', 'Lato', 'Helvetica', 'Arial', 'Times New Roman'],
    };

    module.exports.responsiveModes = {
        desktop: '97%',
        mobile: '480px',
        tablet: '1024px'
    };

    //module.exports.editableContent = ['.editContent', '.navbar a', 'button', 'a.btn', '.footer a:not(.fa)', '.tableWrapper', 'h1'];
    module.exports.editableContent = [];

    module.exports.autoSaveTimeout = 300000;
    
    module.exports.sourceCodeEditSyntaxDelay = 10000;

    module.exports.mediumCssUrls = [
        '//cdn.jsdelivr.net/medium-editor/latest/css/medium-editor.min.css',
        '../css/medium-bootstrap.css'
    ];
    module.exports.mediumButtons = ['bold', 'italic', 'underline', 'anchor', 'orderedlist', 'unorderedlist', 'h1', 'h2', 'h3', 'h4', 'removeFormat'];
      
    module.exports.externalJS = [
        'js/builder_in_block.js'
    ];              
}());
},{}],5:[function(require,module,exports){
(function () {
	"use strict";

	var canvasElement = require('./canvasElement.js').Element;
	var bConfig = require('./config');
	var siteBuilder = require('./builder.js');
    var publisher = require('../vendor/publisher');
    var MediumEditor = require('medium-editor');
    var mediumExtensions = require('./mediumEditorExtensions');

	var contenteditor = {
        
        labelContentMode: document.getElementById('modeContentLabel'),
        radioContent: document.getElementById('modeContent'),
        buttonUpdateContent: document.getElementById('updateContentInFrameSubmit'),
        activeElement: {},
        allContentItemsOnCanvas: [],
        modalEditContent: document.getElementById('editContentModal'),
        mediumEditors: [],
    
        init: function() {

            publisher.subscribe('onBlockLoaded', function (block) {
                contenteditor.injectMediumCSS(block);
            });

            publisher.subscribe('onBeforeSave', function () {
                contenteditor.destroyAllEditors();
            });

            publisher.subscribe('onBeforePreview', function () {
                contenteditor.destroyAllEditors();
            });

            publisher.subscribe('onBeforeClone', function () {
                contenteditor.destroyAllEditors();
            });

            publisher.subscribe('onBeforeDelete', function () {
                contenteditor.destroyAllEditors();
            });

            publisher.subscribe('onClickContent', function (el) {
                contenteditor.contentClick(el);
            });
			
			//listen for the beforeSave event, removes outlines before saving
            $('body').on('beforeSave', function () {
				
				if( Object.keys( contenteditor.activeElement ).length > 0 ) {
                	contenteditor.activeElement.removeOutline();
            	}
				
			});
                        
        },
        
        /*
            Opens up the content editor
        */
        contentClick: function(el) {
                        
            //if we have an active element, make it unactive
            if( Object.keys(this.activeElement).length !== 0) {
                this.activeElement.activate();
            }

            //destroy all first
            contenteditor.destroyAllEditors();
            
            //set the active element
            var activeElement = new canvasElement(el);
            activeElement.setParentBlock();
            contenteditor.activeElement = activeElement;
                        
            //unbind hover and click events and make this item active
            contenteditor.activeElement.setOpen();

            if( !el.hasAttribute('medium-editor-index') ) {

                var theWindow = el.ownerDocument.defaultView;
                var theDoc = el.ownerDocument;

                var editor = new MediumEditor(el, {
                    ownerDocument: theDoc,
                    contentWindow: theWindow,
                    buttonLabels: 'fontawesome',
                    toolbar: {
                        buttons: bConfig.mediumButtons
                    },
                    extensions: {
                        'highlighter': new mediumExtensions.HighlighterButton()
                    }

                });

                var $this = this;

                editor.subscribe('blur', function (data, editable) {

                    if( Object.keys($this.activeElement).length !== 0) {
                        $this.activeElement.activate();
                    }

                    //height adjustment on the containing block
                    $this.activeElement.parentBlock.heightAdjustment();

                });

                editor.subscribe('focus', function (data, editable) {

                });

                editor.subscribe('editableInput', function () {
                    siteBuilder.site.setPendingChanges(true);
                    publisher.publish('onBlockChange', contenteditor.activeElement.parentBlock, 'change');
                });

                editor.selectElement(el.firstChild);

                contenteditor.mediumEditors.push(editor);

            }
                                                
        },

        /*
            Destroys all active Medium editor
        */
        destroyAllEditors: function () {

            for( var x = 0; x < contenteditor.mediumEditors.length; x++ ) {
                contenteditor.mediumEditors[x].destroy();
            }

        },

        /*
            injects the Medium Editor styling into the iframe's head
        */
        injectMediumCSS: function (block) {

            for( var x = 0; x < bConfig.mediumCssUrls.length; x++ ) {

                var cssLink = document.createElement('LINK');
                cssLink.setAttribute('rel', 'stylesheet');
                cssLink.setAttribute('href', bConfig.mediumCssUrls[x]);
                cssLink.setAttribute('type', 'text/css');
                cssLink.setAttribute('media', 'screen');
                cssLink.setAttribute('charset', 'utf-8');
                cssLink.setAttribute('id', 'mediumCss' + x);

                block.frameDocument.head.appendChild(cssLink);

            }

        }
        
    };
    
    contenteditor.init();

}());
},{"../vendor/publisher":12,"./builder.js":2,"./canvasElement.js":3,"./config":4,"./mediumEditorExtensions":7,"medium-editor":13}],6:[function(require,module,exports){
(function () {
	"use strict";

	var bConfig = require('./config.js');
    var publisher = require('../vendor/publisher');

	var bexport = {
        
        modalExport: document.getElementById('exportModal'),
        buttonExport: document.getElementById('exportPage'),
        
        init: function() {
            
            $(this.modalExport).on('show.bs.modal', this.doExportModal);
            $(this.modalExport).on('shown.bs.modal', this.prepExport);
            $(this.modalExport).find('form').on('submit', this.exportFormSubmit);
            
            //reveal export button
            $(this.buttonExport).show();
        
        },
        
        doExportModal: function() {
                        
            $('#exportModal > form #exportSubmit').show('');
            $('#exportModal > form #exportCancel').text('Cancel & Close');
            
        },
        
        
        /*
            prepares the export data
        */
        prepExport: function(e) {

            publisher.publish('closeStyleEditor');
            
            //delete older hidden fields
            $('#exportModal form input[type="hidden"].pages').remove();
            
            //loop through all pages
            $('#pageList > ul').each(function(){

                var theContents;
				
                //grab the skeleton markup
                var newDocMainParent = $('iframe#skeleton').contents().find( bConfig.pageContainer );
                
                //empty out the skeleto
                newDocMainParent.find('*').remove();
			
                //loop through page iframes and grab the body stuff
                $(this).find('iframe').each(function(){
                                        
                    var attr = $(this).attr('data-sandbox');
                    
                    if (typeof attr !== typeof undefined && attr !== false) {
                        theContents = $('#sandboxes #'+attr).contents().find( bConfig.pageContainer );
                    } else {
                        theContents = $(this).contents().find( bConfig.pageContainer ).clone();
                    }
                    
                    theContents.find('.frameCover').each(function(){
                        $(this).remove();
                    });
				
                    
                    //remove inline styling leftovers
                    for( var key in bConfig.editableItems ) {
                        
                        theContents.find( key ).each(function(){
                            
                            $(this).removeAttr('data-selector');
                            
                            if( $(this).attr('style') === '' ) {
                                $(this).removeAttr('style');
                            }
                        });
                    }
				
                    for ( var i = 0; i < bConfig.editableContent.length; ++i) {
                        
                        theContents.find( bConfig.editableContent[i] ).each(function(){
                            $(this).removeAttr('data-selector');
                        });

                    }
			
                    var toAdd = theContents.html();
				
                    //grab scripts
                    var scripts = $(this).contents().find( bConfig.pageContainer ).find('script');
                    
                    if( scripts.size() > 0 ) {
				
                        var theIframe = document.getElementById("skeleton"), script;
                        
                        scripts.each(function(){
					
                            if( $(this).text() !== '' ) {//script tags with content

                                script = theIframe.contentWindow.document.createElement("script");
                                script.type = 'text/javascript';
                                script.innerHTML = $(this).text();
                                theIframe.contentWindow.document.getElementById( bConfig.pageContainer.substring(1) ).appendChild(script);
                            
                            } else if( $(this).attr('src') !== null ) {
                                
                                script = theIframe.contentWindow.document.createElement("script");
                                script.type = 'text/javascript';
                                script.src = $(this).attr('src');
                                theIframe.contentWindow.document.getElementById( bConfig.pageContainer.substring(1) ).appendChild(script);
                            
                            }
                        
                        });
                    
                    }
                    
                    newDocMainParent.append( $(toAdd) );
                
                });
                
                var newInput = $('<input type="hidden" name="pages['+$('#pages li:eq('+($(this).index()+1)+') a:first').text()+']" class="pages" value="">');
                $('#exportModal form').prepend( newInput );
                newInput.val( "<html>"+$('iframe#skeleton').contents().find('html').html()+"</html>" );
            
            });
        },
        
        
        /*
            event handler for the export from submit
        */
        exportFormSubmit: function() {
                        
            $('#exportModal > form #exportSubmit').hide('');
            $('#exportModal > form #exportCancel').text('Close Window');
        
        }
    
    };
        
    bexport.init();

}());
},{"../vendor/publisher":12,"./config.js":4}],7:[function(require,module,exports){
(function () {
	"use strict";

	var MediumEditor = require('medium-editor');
	var rangy = require('rangy');
    require('rangy/lib/rangy-classapplier');

    rangy.init();

    module.exports.HighlighterButton = MediumEditor.extensions.button.extend({

        name: 'highlighter',
        tagNames: ['mark'], // nodeName which indicates the button should be 'active' when isAlreadyApplied() is called
		contentDefault: '<b>H</b>', // default innerHTML of the button
		contentFA: '<i class="fa fa-paint-brush"></i>', // innerHTML of button when 'fontawesome' is being used
		aria: 'Hightlight', // used as both aria-label and title attributes
		action: 'highlight', // used as the data-action attribute of the button
        iframeWin: {},

        init: function () {

        	MediumEditor.extensions.button.prototype.init.call(this);

		    this.classApplier = rangy.createClassApplier('highlight', {
		        elementTagName: 'mark',
		        normalize: true
		    });

		    this.iframeWin = rangy.dom.getIframeWindow(this.window.frameElement);

		},

		handleClick: function (event) {

		    this.classApplier.toggleSelection(this.iframeWin);
		    return false;

		}
		
    });

}());
},{"medium-editor":13,"rangy":15,"rangy/lib/rangy-classapplier":14}],8:[function(require,module,exports){
(function () {
	"use strict";

	var bConfig = require('./config.js');
	var siteBuilder = require('./builder.js');
    var publisher = require('../vendor/publisher');

	var preview = {

        modalPreview: document.getElementById('previewModal'),
        buttonPreview: document.getElementById('buttonPreview'),

        init: function() {

            //events
            $(this.modalPreview).on('shown.bs.modal', this.prepPreview);
            $(this.modalPreview).on('show.bs.modal', this.prepPreviewLink);

            //reveal preview button
            $(this.buttonPreview).show();

        },


        /*
            prepares the preview data
        */
        prepPreview: function() {

            publisher.publish('onBeforePreview');

            $('#previewModal form input[type="hidden"]').remove();

            //build the page
            siteBuilder.site.activePage.fullPage();

            var newInput;

            //markup
            newInput = $('<input type="hidden" name="page" value="">');
            $('#previewModal form').prepend( newInput );
            newInput.val( "<!DOCTYPE html><html>"+$('iframe#skeleton').contents().find('html').html()+"</html>" );

            //page title
            newInput = $('<input type="hidden" name="meta_title" value="">');
            $('#previewModal form').prepend( newInput );
            newInput.val( siteBuilder.site.activePage.pageSettings.title );
            //alert(JSON.stringify(siteBuilder.site.activePage.pageSettings));

            //page meta description
            newInput = $('<input type="hidden" name="meta_description" value="">');
            $('#previewModal form').prepend( newInput );
            newInput.val( siteBuilder.site.activePage.pageSettings.meta_description );

            //page meta keywords
            newInput = $('<input type="hidden" name="meta_keywords" value="">');
            $('#previewModal form').prepend( newInput );
            newInput.val( siteBuilder.site.activePage.pageSettings.meta_keywords );

            //page header includes
            newInput = $('<input type="hidden" name="header_includes" value="">');
            $('#previewModal form').prepend( newInput );
            newInput.val( siteBuilder.site.activePage.pageSettings.header_includes );

            //page css
            newInput = $('<input type="hidden" name="page_css" value="">');
            $('#previewModal form').prepend( newInput );
            newInput.val( siteBuilder.site.activePage.pageSettings.page_css );

            //site ID
            newInput = $('<input type="hidden" name="siteID" value="">');
            $('#previewModal form').prepend( newInput );
            newInput.val( siteBuilder.site.data.sites_id );

        },


        /*
            prepares the actual preview link
        */
        prepPreviewLink: function() {

            $('#pagePreviewLink').attr( 'href', $('#pagePreviewLink').attr('data-defurl')+$('#pages li.active a').text() );

        }

    };

    preview.init();

}());
},{"../vendor/publisher":12,"./builder.js":2,"./config.js":4}],9:[function(require,module,exports){
(function (){
	"use strict";

	var canvasElement = require('./canvasElement.js').Element;
	var bConfig = require('./config.js');
	var siteBuilder = require('./builder.js');
    var publisher = require('../vendor/publisher');

    var styleeditor = {

        radioStyle: document.getElementById('modeStyle'),
        labelStyleMode: document.getElementById('modeStyleLabel'),
        buttonSaveChanges: document.getElementById('saveStyling'),
        activeElement: {}, //holds the element currenty being edited
        allStyleItemsOnCanvas: [],
        _oldIcon: [],
        styleEditor: document.getElementById('styleEditor'),
        formStyle: document.getElementById('stylingForm'),
        buttonRemoveElement: document.getElementById('deleteElementConfirm'),
        buttonCloneElement: document.getElementById('cloneElementButton'),
        buttonResetElement: document.getElementById('resetStyleButton'),
        selectLinksInernal: document.getElementById('internalLinksDropdown'),
        selectLinksPages: document.getElementById('pageLinksDropdown'),
        videoInputYoutube: document.getElementById('youtubeID'),
        videoInputVimeo: document.getElementById('vimeoID'),
        inputCustomLink: document.getElementById('internalLinksCustom'),
        linkImage: null,
        linkIcon: null,
        inputLinkText: document.getElementById('linkText'),
        selectIcons: document.getElementById('icons'),
        buttonDetailsAppliedHide: document.getElementById('detailsAppliedMessageHide'),
        buttonCloseStyleEditor: document.querySelector('#styleEditor > a.close'),
        ulPageList: document.getElementById('pageList'),
        responsiveToggle: document.getElementById('responsiveToggle'),
        theScreen: document.getElementById('screen'),

        init: function() {

            publisher.subscribe('closeStyleEditor', function () {
                styleeditor.closeStyleEditor();
            });

            publisher.subscribe('onBlockLoaded', function (block) {

                styleeditor.setupCanvasElements(block);

            });

            publisher.subscribe('onSetMode', function (mode) {
                styleeditor.responsiveModeChange(mode);
            });

            publisher.subscribe('onBeforeSave', function () {
                styleeditor.closeStyleEditor();
            });

            publisher.subscribe('onBeforePreview', function () {
                styleeditor.closeStyleEditor();
            });

            //events
            $(this.radioStyle).on('click', this.activateStyleMode);
            $(this.buttonSaveChanges).on('click', this.updateStyling);
            $(this.formStyle).on('focus', 'input', this.animateStyleInputIn).on('blur', 'input', this.animateStyleInputOut);
            $(this.buttonRemoveElement).on('click', this.deleteElement);
            $(this.buttonCloneElement).on('click', this.cloneElement);
            $(this.buttonResetElement).on('click', this.resetElement);
            $(this.videoInputYoutube).on('focus', function(){ $(styleeditor.videoInputVimeo).val(''); });
            $(this.videoInputVimeo).on('focus', function(){ $(styleeditor.videoInputYoutube).val(''); });
            $(this.buttonDetailsAppliedHide).on('click', function(){$(this).parent().fadeOut(500);});
            $(this.buttonCloseStyleEditor).on('click', this.closeStyleEditor);
            $(this.inputCustomLink).on('focus', this.inputCustomLinkFocus).on('blur', this.inputCustomLinkBlur);

            //chosen font-awesome dropdown
            $(this.selectIcons).chosen({'search_contains': true});

            //check if formData is supported
            if (!window.FormData){
                this.hideFileUploads();
            }

            //show the style mode radio button
            $(this.labelStyleMode).show();

            //listen for the beforeSave event
            $('body').on('beforeSave', this.closeStyleEditor);

            //responsive toggle
            $(this.responsiveToggle).on('click', 'a', this.toggleResponsiveClick);

            //set the default responsive mode
            siteBuilder.builderUI.currentResponsiveMode = Object.keys(bConfig.responsiveModes)[0];

        },

        /*
            Event handler for responsive mode links
        */
        toggleResponsiveClick: function (e) {

            e.preventDefault();
            
            styleeditor.responsiveModeChange(this.getAttribute('data-responsive'));

        },

        /*
            Toggles the responsive mode
        */
        responsiveModeChange: function (mode) {

            var links,
                i;

            //UI stuff
            links = styleeditor.responsiveToggle.querySelectorAll('li');

            for ( i = 0; i < links.length; i++ ) links[i].classList.remove('active');

            document.querySelector('a[data-responsive="' + mode + '"]').parentNode.classList.add('active');


            for ( var key in bConfig.responsiveModes ) {

                if ( bConfig.responsiveModes.hasOwnProperty(key) ) this.theScreen.classList.remove(key);

            }

            if ( bConfig.responsiveModes[mode] ) {

                this.theScreen.classList.add(mode);
                $(this.theScreen).animate({width: bConfig.responsiveModes[mode]}, 650, function () {
                    //height adjustment
                    siteBuilder.site.activePage.heightAdjustment();
                });

            }

            siteBuilder.builderUI.currentResponsiveMode = mode;

        },


        /*
            Activates style editor mode
        */
        setupCanvasElements: function(block) {

            if ( block === undefined ) return false;

            var i;

            //create an object for every editable element on the canvas and setup it's events

            for( var key in bConfig.editableItems ) {

                $(block.frame).contents().find( bConfig.pageContainer + ' '+ key ).each(function () {

                    styleeditor.setupCanvasElementsOnElement(this, key);

                });

            }

        },


        /*
            Sets up canvas elements on element
        */
        setupCanvasElementsOnElement: function (element, key) {

            //Element object extention
            canvasElement.prototype.clickHandler = function (el) {
                styleeditor.styleClick(this);
            };

            var newElement = new canvasElement(element);

            newElement.editableAttributes = bConfig.editableItems[key];
            newElement.setParentBlock();
            newElement.activate();

            styleeditor.allStyleItemsOnCanvas.push( newElement );

            if ( typeof key !== undefined ) $(element).attr('data-selector', key);

        },


        /*
            Event handler for when the style editor is envoked on an item
        */
        styleClick: function(element) {

            //if we have an active element, make it unactive
            if( Object.keys(this.activeElement).length !== 0) {
                this.activeElement.activate();
            }

            //set the active element
            this.activeElement = element;

            //unbind hover and click events and make this item active
            this.activeElement.setOpen();

            var theSelector = $(this.activeElement.element).attr('data-selector');

            $('#editingElement').text( theSelector );

            //activate first tab
            $('#detailTabs a:first').click();

            //hide all by default
            $('ul#detailTabs li:gt(0)').hide();

            //content editor?
            for( var item in bConfig.editableItems ) {

                if( bConfig.editableItems.hasOwnProperty(item) && item === theSelector ) {

                    if ( bConfig.editableItems[item].indexOf('content') !== -1 ) {

                        //edit content
                        publisher.publish('onClickContent', element.element);

                    }

                }

            }

            //what are we dealing with?
            if( $(this.activeElement.element).prop('tagName') === 'A' || $(this.activeElement.element).parent().prop('tagName') === 'A' ) {

                this.editLink(this.activeElement.element);

            }

			if( $(this.activeElement.element).prop('tagName') === 'IMG' ){

                this.editImage(this.activeElement.element);

            }

			if( $(this.activeElement.element).attr('data-type') === 'video' ) {

                this.editVideo(this.activeElement.element);

            }

			if( $(this.activeElement.element).hasClass('fa') ) {

                this.editIcon(this.activeElement.element);

            }

            //load the attributes
            this.buildeStyleElements(theSelector);

            //open side panel
            this.toggleSidePanel('open');

            return false;

        },


        /*
            dynamically generates the form fields for editing an elements style attributes
        */
        buildeStyleElements: function(theSelector) {

            //delete the old ones first
            $('#styleElements > *:not(#styleElTemplate)').each(function(){

                $(this).remove();

            });

            if ( bConfig.editableItems[theSelector].length === 1 && bConfig.editableItems[theSelector][0] === 'content' ) {
                //text element only, no styling attributes

                document.getElementById('detailTabs').style.display = 'none';
                styleeditor.buttonSaveChanges.style.display = 'none';

            } else {

                document.getElementById('detailTabs').style.display = 'block';
                styleeditor.buttonSaveChanges.style.display = 'block';

            }

            for( var x = 0; x < bConfig.editableItems[theSelector].length; x++ ) {

                //create style elements
                var newStyleEl = $('#styleElTemplate').clone();
                newStyleEl.attr('id', '');
                newStyleEl.find('.control-label').text( bConfig.editableItems[theSelector][x]+":" );

                if( theSelector + " : " + bConfig.editableItems[theSelector][x] in bConfig.editableItemOptions) {//we've got a dropdown instead of open text input

                    newStyleEl.find('input').remove();

                    var newDropDown = $('<select class="form-control select select-primary btn-block select-sm"></select>');
                    newDropDown.attr('name', bConfig.editableItems[theSelector][x]);


                    for( var z=0; z<bConfig.editableItemOptions[ theSelector+" : "+bConfig.editableItems[theSelector][x] ].length; z++ ) {

                        var newOption = $('<option value="'+bConfig.editableItemOptions[theSelector+" : "+bConfig.editableItems[theSelector][x]][z]+'">'+bConfig.editableItemOptions[theSelector+" : "+bConfig.editableItems[theSelector][x]][z]+'</option>');


                        if( bConfig.editableItemOptions[theSelector+" : "+bConfig.editableItems[theSelector][x]][z] === $(styleeditor.activeElement.element).css( bConfig.editableItems[theSelector][x] ) ) {
                            //current value, marked as selected
                            newOption.attr('selected', 'true');

                        }

                        newDropDown.append( newOption );

                    }

                    newStyleEl.append( newDropDown );
                    newDropDown.select2();

                } else {

                    if ( bConfig.editableItems[theSelector][x] === 'content' ) continue;

                    newStyleEl.find('input').attr('name', bConfig.editableItems[theSelector][x]);

                    if( bConfig.editableItems[theSelector][x] === 'background-image' ) {

                        newStyleEl.find('input').bind('focus', function(){

                            var theInput = $(this);

                            $('#imageModal').modal('show');
                            $('#imageModal .image button.useImage').unbind('click');
                            $('#imageModal').on('click', '.image button.useImage', function(){

                                $(styleeditor.activeElement.element).css('background-image',  'url("'+$(this).attr('data-url')+'")');

                                //update live image
                                theInput.val( 'url("'+$(this).attr('data-url')+'")' );

                                //hide modal
                                $('#imageModal').modal('hide');

                                //we've got pending changes
                                siteBuilder.site.setPendingChanges(true);

                            });

                        });

                    } else if( bConfig.editableItems[theSelector][x].indexOf("color") > -1 ) {

                        if( $(styleeditor.activeElement.element).css( bConfig.editableItems[theSelector][x] ) !== 'transparent' && $(styleeditor.activeElement.element).css( bConfig.editableItems[theSelector][x] ) !== 'none' && $(styleeditor.activeElement.element).css( bConfig.editableItems[theSelector][x] ) !== '' ) {

                            //do we have a data attribute value for this style attribute?
                            if ( $(styleeditor.activeElement.element).data( bConfig.editableItems[theSelector][x] ) ) {

                                newStyleEl.find('input').val( $(styleeditor.activeElement.element).data( bConfig.editableItems[theSelector][x] ) );

                            } else {

                                newStyleEl.find('input').val( $(styleeditor.activeElement.element).css( bConfig.editableItems[theSelector][x] ) );

                            }

                        }

                        newStyleEl.find('input').spectrum({
                            preferredFormat: "hex",
                            showPalette: true,
                            allowEmpty: true,
                            showInput: true,
                            palette: [
                                ["#000","#444","#666","#999","#ccc","#eee","#f3f3f3","#fff"],
                                ["#f00","#f90","#ff0","#0f0","#0ff","#00f","#90f","#f0f"],
                                ["#f4cccc","#fce5cd","#fff2cc","#d9ead3","#d0e0e3","#cfe2f3","#d9d2e9","#ead1dc"],
                                ["#ea9999","#f9cb9c","#ffe599","#b6d7a8","#a2c4c9","#9fc5e8","#b4a7d6","#d5a6bd"],
                                ["#e06666","#f6b26b","#ffd966","#93c47d","#76a5af","#6fa8dc","#8e7cc3","#c27ba0"],
                                ["#c00","#e69138","#f1c232","#6aa84f","#45818e","#3d85c6","#674ea7","#a64d79"],
                                ["#900","#b45f06","#bf9000","#38761d","#134f5c","#0b5394","#351c75","#741b47"],
                                ["#600","#783f04","#7f6000","#274e13","#0c343d","#073763","#20124d","#4c1130"]
                            ]
                        });

                    } else {

                        newStyleEl.find('input').val( $(styleeditor.activeElement.element).css( bConfig.editableItems[theSelector][x] ) );

                    }

                }

                newStyleEl.css('display', 'block');

                $('#styleElements').append( newStyleEl );

                $('#styleEditor form#stylingForm').height('auto');

            }

        },


        /*
            Applies updated styling to the canvas
        */
        updateStyling: function() {

            var elementID,
                length;

            $('#styleEditor #tab1 .form-group:not(#styleElTemplate) input, #styleEditor #tab1 .form-group:not(#styleElTemplate) select').each(function(){

				if( $(this).attr('name') !== undefined ) {

                	$(styleeditor.activeElement.element).css( $(this).attr('name'),  $(this).val());

				}

                /* SANDBOX */

                if( styleeditor.activeElement.sandbox ) {

                    elementID = $(styleeditor.activeElement.element).attr('id');

                    $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).css( $(this).attr('name'),  $(this).val() );

                }

                /* END SANDBOX */

            });

            //links
            if( $(styleeditor.activeElement.element).prop('tagName') === 'A' ) {

                //change the href prop?
                styleeditor.activeElement.element.href = document.getElementById('internalLinksCustom').value;

                length = styleeditor.activeElement.element.childNodes.length;
                
                //does the link contain an image?
                if( styleeditor.linkImage ) styleeditor.activeElement.element.childNodes[length-1].nodeValue = document.getElementById('linkText').value;
                else if ( styleeditor.linkIcon ) styleeditor.activeElement.element.childNodes[length-1].nodeValue = document.getElementById('linkText').value;
                else styleeditor.activeElement.element.innerText = document.getElementById('linkText').value;

                /* SANDBOX */

                if( styleeditor.activeElement.sandbox ) {

                    elementID = $(styleeditor.activeElement.element).attr('id');

                    $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).attr('href', $('input#internalLinksCustom').val());


                }

                /* END SANDBOX */

            }

            if( $(styleeditor.activeElement.element).parent().prop('tagName') === 'A' && !styleeditor.activeElement.element.classList.contains('fa') ) {

                //change the href prop?
                styleeditor.activeElement.element.parentNode.href = document.getElementById('internalLinksCustom').value;

                length = styleeditor.activeElement.element.childNodes.length;
                

                /* SANDBOX */

                if( styleeditor.activeElement.sandbox ) {

                    elementID = $(styleeditor.activeElement.element).attr('id');

                    $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).parent().attr('href', $('input#internalLinksCustom').val());

                }

                /* END SANDBOX */

            }

            //do we need to upload an image?
            if( $('a#img_Link').css('display') === 'block' && $('input#imageFileField').val() !== '' ) {
            //if( $('a#img_Link').css('display') === 'block' ) {
                    
                var form = $('form#imageUploadForm');
                
                var formdata = false;
                
                if (window.FormData){
                    formdata = new FormData(form[0]);
                }
                
                var formAction = form.attr('action');
                
                $.ajax({
                    url : formAction,
                    data : formdata ? formdata : form.serialize(),
                    cache : false,
                    contentType : false,
                    processData : false,
                    dataType: "json",
                    type : 'POST',
                }).done(function(response){
                                
                    if( response.code === 1 ) {//success
                    
                        $('input#imageURL').val( response.response );
                    
                        $(styleeditor.activeElement.element).attr('src', response.response);
                        
                        //reset the file upload
                        $('.imageFileTab').find('a.fileinput-exists').click();
                        
                        /* SANDBOX */
                                
                        if( styleeditor.activeElement.sandbox ) {
                    
                            var elementID = $(styleeditor.activeElement.element).attr('id');
                                    
                            $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).attr('src', response.response);
                    
                        }
                
                        /* END SANDBOX */
                    
                    } else if( response.code === 0 ) {//error
                    
                        alert('Something went wrong: '+response.response);
                    
                    }
                
                });
                
                        
            } else if( $('a#img_Link').css('display') === 'block' ) {
            
                
                //no image to upload, just a SRC change
                if( $('input#imageURL').val() !== '' && $('input#imageURL').val() !== $(styleeditor.activeElement.element).attr('src') ) {
                
                    $(styleeditor.activeElement.element).attr('src', $('input#imageURL').val());
                    
                    /* SANDBOX */
                        
                    if( styleeditor.activeElement.sandbox ) {
                
                        elementID = $(styleeditor.activeElement.element).attr('id');
                                
                        $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).attr('src', $('input#imageURL').val());
                
                    }
            
                    /* END SANDBOX */
                
                }
                
            
            }

            //icons
            if( $(styleeditor.activeElement.element).hasClass('fa') ) {

                //out with the old, in with the new :)
                //get icon class name, starting with fa-
                var get = $.grep(styleeditor.activeElement.element.className.split(" "), function(v, i){

                    return v.indexOf('fa-') === 0;

                }).join();

                //if the icons is being changed, save the old one so we can reset it if needed

                if( get !== $('select#icons').val() ) {

                    $(styleeditor.activeElement.element).uniqueId();
                    styleeditor._oldIcon[$(styleeditor.activeElement.element).attr('id')] = get;

                }

                $(styleeditor.activeElement.element).removeClass( get ).addClass( $('select#icons').val() );


                /* SANDBOX */

                if( styleeditor.activeElement.sandbox ) {

                    elementID = $(styleeditor.activeElement.element).attr('id');
                    $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).removeClass( get ).addClass( $('select#icons').val() );

                }

                /* END SANDBOX */

            }

            //video URL
            if( $(styleeditor.activeElement.element).attr('data-type') === 'video' ) {

                if( $('input#youtubeID').val() !== '' ) {

                    $(styleeditor.activeElement.element).prev().attr('src', "//www.youtube.com/embed/"+$('#video_Tab input#youtubeID').val());

                } else if( $('input#vimeoID').val() !== '' ) {

                    $(styleeditor.activeElement.element).prev().attr('src', "//player.vimeo.com/video/"+$('#video_Tab input#vimeoID').val()+"?title=0&amp;byline=0&amp;portrait=0");

                }

                /* SANDBOX */

                if( styleeditor.activeElement.sandbox ) {

                    elementID = $(styleeditor.activeElement.element).attr('id');

                    if( $('input#youtubeID').val() !== '' ) {

                        $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).prev().attr('src', "//www.youtube.com/embed/"+$('#video_Tab input#youtubeID').val());

                    } else if( $('input#vimeoID').val() !== '' ) {

                        $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).prev().attr('src', "//player.vimeo.com/video/"+$('#video_Tab input#vimeoID').val()+"?title=0&amp;byline=0&amp;portrait=0");

                    }

                }

                /* END SANDBOX */

            }

            $('#detailsAppliedMessage').fadeIn(600, function(){

                setTimeout(function(){ $('#detailsAppliedMessage').fadeOut(1000); }, 3000);

            });

            //adjust frame height
            styleeditor.activeElement.parentBlock.heightAdjustment();


            //we've got pending changes
            siteBuilder.site.setPendingChanges(true);

            publisher.publish('onBlockChange', styleeditor.activeElement.parentBlock, 'change');

        },


        /*
            on focus, we'll make the input fields wider
        */
        animateStyleInputIn: function() {

            $(this).css('position', 'absolute');
            $(this).css('right', '0px');
            $(this).animate({'width': '100%'}, 500);
            $(this).focus(function(){
                this.select();
            });

        },


        /*
            on blur, we'll revert the input fields to their original size
        */
        animateStyleInputOut: function() {

            $(this).animate({'width': '42%'}, 500, function(){
                $(this).css('position', 'relative');
                $(this).css('right', 'auto');
            });

        },

        /*
            builds the dropdown with pages to link to
        */
        buildPagesDropdown: function (currentVal) {

            $(styleeditor.selectLinksPages).off('change').select2('destroy');

            if( typeof currentVal === 'undefined' ) currentVal = null;

            var x,
                newOption;

            styleeditor.selectLinksPages.innerHTML = '';

            newOption = document.createElement('OPTION');
            newOption.innerText = "Choose a page";
            newOption.setAttribute('value', '#');
            styleeditor.selectLinksPages.appendChild(newOption);

            for( x = 0; x < siteBuilder.site.sitePages.length; x++ ) {

                newOption = document.createElement('OPTION');
                newOption.innerText = siteBuilder.site.sitePages[x].name;
                newOption.setAttribute('value', siteBuilder.site.sitePages[x].name + '.html');
                if( currentVal === siteBuilder.site.sitePages[x].name + '.html') newOption.setAttribute('selected', true);

                styleeditor.selectLinksPages.appendChild(newOption);

            }

            $(styleeditor.selectLinksPages).select2();
            $(styleeditor.selectLinksPages).trigger('change');

            $(styleeditor.selectLinksPages).on('change', function () {
                styleeditor.inputCustomLink.value = this.value;
                styleeditor.resetBlockDropdown();
            });

        },


        /*
            builds the dropdown with #blocks on this page
        */
        buildBlocksDropdown: function (currentVal) {

            $(styleeditor.selectLinksInernal).off('change').select2('destroy');

            if( typeof currentVal === 'undefined' ) currentVal = null;

            var x,
                newOption;

            styleeditor.selectLinksInernal.innerHTML = '';

            newOption = document.createElement('OPTION');
            newOption.innerText = "Choose a block";
            newOption.setAttribute('value', '#');
            styleeditor.selectLinksInernal.appendChild(newOption);

            for ( x = 0; x < siteBuilder.site.activePage.blocks.length; x++ ) {

                var frameDoc = siteBuilder.site.activePage.blocks[x].frameDocument;
                var pageContainer  = frameDoc.querySelector(bConfig.pageContainer);
                var theID = pageContainer.children[0].id;

                newOption = document.createElement('OPTION');
                newOption.innerText = '#' + theID;
                newOption.setAttribute('value', '#' + theID);
                if( currentVal === '#' + theID ) newOption.setAttribute('selected', true);

                styleeditor.selectLinksInernal.appendChild(newOption);

            }

            $(styleeditor.selectLinksInernal).select2();
            $(styleeditor.selectLinksInernal).trigger('change');

            $(styleeditor.selectLinksInernal).on('change', function () {
                styleeditor.inputCustomLink.value = this.value;
                styleeditor.resetPageDropdown();
            });

        },


        /*
            blur event handler for the custom link input
        */
        inputCustomLinkBlur: function (e) {

            var value = e.target.value,
                x;

            //pages match?
            for ( x = 0; x < styleeditor.selectLinksPages.querySelectorAll('option').length; x++ ) {

                if ( value === styleeditor.selectLinksPages.querySelectorAll('option')[x].value ) {

                    styleeditor.selectLinksPages.selectedIndex = x;
                    $(styleeditor.selectLinksPages).trigger('change').select2();

                }

            }

            //blocks match?
            for ( x = 0; styleeditor.selectLinksInernal.querySelectorAll('option').length; x++ ) {

                if ( value === styleeditor.selectLinksInernal.querySelectorAll('option')[x].value ) {

                    styleeditor.selectLinksInernal.selectedIndex = x;
                    $(styleeditor.selectLinksInernal).trigger('change').select2();

                }

            }

        },


        /*
            focus event handler for the custom link input
        */
        inputCustomLinkFocus: function () {

            styleeditor.resetPageDropdown();
            styleeditor.resetBlockDropdown();

        },


        /*
            reset the block link dropdown
        */
        resetBlockDropdown: function () {

            styleeditor.selectLinksInernal.selectedIndex = 0;
            $(styleeditor.selectLinksInernal).select2('destroy').select2();

        },


        /*
            reset the page link dropdown
        */
        resetPageDropdown: function () {

            styleeditor.selectLinksPages.selectedIndex = 0;
            $(styleeditor.selectLinksPages).select2('destroy').select2();

        },


        /*
            when the clicked element is an anchor tag (or has a parent anchor tag)
        */
        editLink: function(el) {

            var theHref;

            $('a#link_Link').parent().show();

            //set theHref
            if( $(el).prop('tagName') === 'A' ) {

                theHref = $(el).attr('href');

            } else if( $(el).parent().prop('tagName') === 'A' ) {

                theHref = $(el).parent().attr('href');

            }

            styleeditor.buildPagesDropdown(theHref);
            styleeditor.buildBlocksDropdown(theHref);
            styleeditor.inputCustomLink.value = theHref;

            //grab an image?
            if ( el.querySelector('img') ) styleeditor.linkImage = el.querySelector('img');
            else styleeditor.linkImage = null;

            //grab an icon?
            if ( el.querySelector('.fa') ) styleeditor.linkIcon = el.querySelector('.fa').cloneNode(true);
            else styleeditor.linkIcon = null;

            styleeditor.inputLinkText.value = el.innerText;
    
        },


        /*
            when the clicked element is an image
        */
        editImage: function(el) {

            $('a#img_Link').parent().show();

            //set the current SRC
            $('.imageFileTab').find('input#imageURL').val( $(el).attr('src') );

            //reset the file upload
            $('.imageFileTab').find('a.fileinput-exists').click();

        },


        /*
            when the clicked element is a video element
        */
        editVideo: function(el) {

            var matchResults;

            $('a#video_Link').parent().show();
            $('a#video_Link').click();

            //inject current video ID,check if we're dealing with Youtube or Vimeo

            if( $(el).prev().attr('src').indexOf("vimeo.com") > -1 ) {//vimeo

                matchResults = $(el).prev().attr('src').match(/player\.vimeo\.com\/video\/([0-9]*)/);

                $('#video_Tab input#vimeoID').val( matchResults[matchResults.length-1] );
                $('#video_Tab input#youtubeID').val('');

            } else {//youtube

                //temp = $(el).prev().attr('src').split('/');
                var regExp = /.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#\&\?]*).*/;
                matchResults = $(el).prev().attr('src').match(regExp);

                $('#video_Tab input#youtubeID').val( matchResults[1] );
                $('#video_Tab input#vimeoID').val('');

            }

        },


        /*
            when the clicked element is an fa icon
        */
        editIcon: function() {

            $('a#icon_Link').parent().show();

            //get icon class name, starting with fa-
            var get = $.grep(this.activeElement.element.className.split(" "), function(v, i){

                return v.indexOf('fa-') === 0;

            }).join();

            $('select#icons option').each(function(){

                if( $(this).val() === get ) {

                    $(this).attr('selected', true);

                    $('#icons').trigger('chosen:updated');

                }

            });

        },


        /*
            delete selected element
        */
        deleteElement: function() {

            publisher.publish('onBeforeDelete');

            var toDel;

            //determine what to delete
            if( $(styleeditor.activeElement.element).prop('tagName') === 'A' ) {//ancor

                if( $(styleeditor.activeElement.element).parent().prop('tagName') ==='LI' ) {//clone the LI

                    toDel = $(styleeditor.activeElement.element).parent();

                } else {

                    toDel = $(styleeditor.activeElement.element);

                }

            } else if( $(styleeditor.activeElement.element).prop('tagName') === 'IMG' ) {//image

                if( $(styleeditor.activeElement.element).parent().prop('tagName') === 'A' ) {//clone the A

                    toDel = $(styleeditor.activeElement.element).parent();

                } else {

                    toDel = $(styleeditor.activeElement.element);

                }

            } else {//everything else

                toDel = $(styleeditor.activeElement.element);

            }


            toDel.fadeOut(500, function(){

                var randomEl = $(this).closest('body').find('*:first');

                toDel.remove();

                /* SANDBOX */

                var elementID = $(styleeditor.activeElement.element).attr('id');

                $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).remove();

                /* END SANDBOX */

                styleeditor.activeElement.parentBlock.heightAdjustment();

                //we've got pending changes
                siteBuilder.site.setPendingChanges(true);

            });

            $('#deleteElement').modal('hide');

            styleeditor.closeStyleEditor();

            publisher.publish('onBlockChange', styleeditor.activeElement.parentBlock, 'change');

        },


        /*
            clones the selected element
        */
        cloneElement: function() {

            publisher.publish('onBeforeClone');

            var theClone, theClone2, theOne, cloned, cloneParent, elementID;

            if( $(styleeditor.activeElement.element).parent().hasClass('propClone') ) {//clone the parent element

                theClone = $(styleeditor.activeElement.element).parent().clone();
                theClone.find( $(styleeditor.activeElement.element).prop('tagName') ).attr('style', '');

                theClone2 = $(styleeditor.activeElement.element).parent().clone();
                theClone2.find( $(styleeditor.activeElement.element).prop('tagName') ).attr('style', '');

                theOne = theClone.find( $(styleeditor.activeElement.element).prop('tagName') );
                cloned = $(styleeditor.activeElement.element).parent();

                cloneParent = $(styleeditor.activeElement.element).parent().parent();

            } else {//clone the element itself

                theClone = $(styleeditor.activeElement.element).clone();

                theClone.attr('style', '');

                /*if( styleeditor.activeElement.sandbox ) {
                    theClone.attr('id', '').uniqueId();
                }*/

                theClone2 = $(styleeditor.activeElement.element).clone();
                theClone2.attr('style', '');

                /*
                if( styleeditor.activeElement.sandbox ) {
                    theClone2.attr('id', theClone.attr('id'));
                }*/

                theOne = theClone;
                cloned = $(styleeditor.activeElement.element);

                cloneParent = $(styleeditor.activeElement.element).parent();

            }

            cloned.after( theClone );

            /* SANDBOX */

            if( styleeditor.activeElement.sandbox ) {

                elementID = $(styleeditor.activeElement.element).attr('id');
                $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).after( theClone2 );

            }

            /* END SANDBOX */

            //make sure the new element gets the proper events set on it
            if ( !theClone.get(0).classList.contains('propClone') ) styleeditor.setupCanvasElementsOnElement(theClone.get(0));

            //create an object for every editable element in the cloned element as well
            for( var key in bConfig.editableItems ) {

                theClone.find( '*[data-selector="' + key + '"]' ).each(function () {

                    styleeditor.setupCanvasElementsOnElement(this, key);

                });

            }

            //possible height adjustments
            styleeditor.activeElement.parentBlock.heightAdjustment();

            //we've got pending changes
            siteBuilder.site.setPendingChanges(true);

            publisher.publish('onBlockChange', styleeditor.activeElement.parentBlock, 'change');

        },


        /*
            resets the active element
        */
        resetElement: function() {

            $(styleeditor.activeElement.element).attr('style', '').css({'outline': '3px dashed red', 'outline-offset':'-3px', 'cursor': 'pointer'});

            /* SANDBOX */

            if( styleeditor.activeElement.sandbox ) {

                var elementID = $(styleeditor.activeElement.element).attr('id');
                $('#'+styleeditor.activeElement.sandbox).contents().find('#'+elementID).attr('style', '');

            }

            /* END SANDBOX */

            $('#styleEditor form#stylingForm').height( $('#styleEditor form#stylingForm').height()+"px" );

            $('#styleEditor form#stylingForm .form-group:not(#styleElTemplate)').fadeOut(500, function(){

                $(this).remove();

            });


            //reset icon

            if( styleeditor._oldIcon[$(styleeditor.activeElement.element).attr('id')] !== null ) {

                var get = $.grep(styleeditor.activeElement.element.className.split(" "), function(v, i){

                    return v.indexOf('fa-') === 0;

                }).join();

                $(styleeditor.activeElement.element).removeClass( get ).addClass( styleeditor._oldIcon[$(styleeditor.activeElement.element).attr('id')] );

                $('select#icons option').each(function(){

                    if( $(this).val() === styleeditor._oldIcon[$(styleeditor.activeElement.element).attr('id')] ) {

                        $(this).attr('selected', true);
                        $('#icons').trigger('chosen:updated');

                    }

                });

            }

            setTimeout( function(){styleeditor.buildeStyleElements( $(styleeditor.activeElement.element).attr('data-selector') );}, 550);

            siteBuilder.site.setPendingChanges(true);

            publisher.publish('onBlockChange', styleeditor.activeElement.parentBlock, 'change');

        },

        /*
            hides file upload forms
        */
        hideFileUploads: function() {

            $('form#imageUploadForm').hide();
            $('#imageModal #uploadTabLI').hide();

        },


        /*
            closes the style editor
        */
        closeStyleEditor: function (e) {

            if ( e !== undefined ) e.preventDefault();

            if ( styleeditor.activeElement.editableAttributes && styleeditor.activeElement.editableAttributes.indexOf('content') === -1 ) {
                styleeditor.activeElement.removeOutline();
                styleeditor.activeElement.activate();
            }

            if( $('#styleEditor').css('left') === '0px' ) {

                styleeditor.toggleSidePanel('close');

            }

        },


        /*
            toggles the side panel
        */
        toggleSidePanel: function(val) {

            if( val === 'open' && $('#styleEditor').css('left') === '-300px' ) {
                $('#styleEditor').animate({'left': '0px'}, 250);
            } else if( val === 'close' && $('#styleEditor').css('left') === '0px' ) {
                $('#styleEditor').animate({'left': '-300px'}, 250);
            }

        }

    };

    styleeditor.init();

    exports.styleeditor = styleeditor;

}());
},{"../vendor/publisher":12,"./builder.js":2,"./canvasElement.js":3,"./config.js":4}],10:[function(require,module,exports){
(function () {

/* globals siteUrl:false, baseUrl:false */
    "use strict";
        
    var appUI = {
        
        firstMenuWidth: 190,
        secondMenuWidth: 300,
        loaderAnimation: document.getElementById('loader'),
        secondMenuTriggerContainers: $('#menu #main #elementCats, #menu #main #templatesUl'),
        siteUrl: siteUrl,
        baseUrl: baseUrl,
        
        setup: function(){
            
            // Fade the loader animation
            $(appUI.loaderAnimation).fadeOut(function(){
                $('#menu').animate({'left': -appUI.firstMenuWidth}, 1000);
            });
            
            // Tabs
            $(".nav-tabs a").on('click', function (e) {
                e.preventDefault();
                $(this).tab("show");
            });
            
            $("select.select").select2();
            
            $(':radio, :checkbox').radiocheck();
            
            // Tooltips
            $("[data-toggle=tooltip]").tooltip("hide");
            
            // Table: Toggle all checkboxes
            $('.table .toggle-all :checkbox').on('click', function () {
                var $this = $(this);
                var ch = $this.prop('checked');
                $this.closest('.table').find('tbody :checkbox').radiocheck(!ch ? 'uncheck' : 'check');
            });
            
            // Add style class name to a tooltips
            $(".tooltip").addClass(function() {
                if ($(this).prev().attr("data-tooltip-style")) {
                    return "tooltip-" + $(this).prev().attr("data-tooltip-style");
                }
            });
            
            $(".btn-group").on('click', "a", function() {
                $(this).siblings().removeClass("active").end().addClass("active");
            });
            
            // Focus state for append/prepend inputs
            $('.input-group').on('focus', '.form-control', function () {
                $(this).closest('.input-group, .form-group').addClass('focus');
            }).on('blur', '.form-control', function () {
                $(this).closest('.input-group, .form-group').removeClass('focus');
            });
            
            // Table: Toggle all checkboxes
            $('.table .toggle-all').on('click', function() {
                var ch = $(this).find(':checkbox').prop('checked');
                $(this).closest('.table').find('tbody :checkbox').checkbox(!ch ? 'check' : 'uncheck');
            });
            
            // Table: Add class row selected
            $('.table tbody :checkbox').on('check uncheck toggle', function (e) {
                var $this = $(this)
                , check = $this.prop('checked')
                , toggle = e.type === 'toggle'
                , checkboxes = $('.table tbody :checkbox')
                , checkAll = checkboxes.length === checkboxes.filter(':checked').length;

                $this.closest('tr')[check ? 'addClass' : 'removeClass']('selected-row');
                if (toggle) $this.closest('.table').find('.toggle-all :checkbox').checkbox(checkAll ? 'check' : 'uncheck');
            });
            
            // Switch
            $("[data-toggle='switch']").wrap('<div class="switch" />').parent().bootstrapSwitch();
                        
            appUI.secondMenuTriggerContainers.on('click', 'a:not(.btn)', appUI.secondMenuAnimation);
                        
        },
        
        secondMenuAnimation: function(){
        
            $('#menu #main a').removeClass('active');
            $(this).addClass('active');
	
            //show only the right elements
            $('#menu #second ul li').hide();
            $('#menu #second ul li.'+$(this).attr('id')).show();

            if( $(this).attr('id') === 'all' ) {
                $('#menu #second ul#elements li').show();		
            }
	
            $('.menu .second').css('display', 'block').stop().animate({
                width: appUI.secondMenuWidth
            }, 500);	
                
        }
        
    };
    
    //initiate the UI
    appUI.setup();


    //**** EXPORTS
    module.exports.appUI = appUI;
    
}());
},{}],11:[function(require,module,exports){
(function () {
	"use strict";
    
    exports.getRandomArbitrary = function(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    };
    
}());
},{}],12:[function(require,module,exports){
/*!
 * publisher.js - (c) Ryan Florence 2011
 * github.com/rpflorence/publisher.js
 * MIT License
*/

// UMD Boilerplate \o/ && D:
(function (root, factory) {
  if (typeof exports === 'object') {
    module.exports = factory(); // node
  } else if (typeof define === 'function' && define.amd) {
    define(factory); // amd
  } else {
    // window with noConflict
    var _publisher = root.publisher;
    var publisher = root.publisher = factory();
    root.publisher.noConflict = function () {
      root.publisher = _publisher;
      return publisher;
    }
  }
}(this, function () {

  var publisher = function (obj) {
    var topics = {};
    obj = obj || {};

    obj.publish = function (topic/*, messages...*/) {
      if (!topics[topic]) return obj;
      var messages = [].slice.call(arguments, 1);
      for (var i = 0, l = topics[topic].length; i < l; i++) {
        topics[topic][i].handler.apply(topics[topic][i].context, messages);
      }
      return obj;
    };

    obj.subscribe = function (topicOrSubscriber, handlerOrTopics) {
      var firstType = typeof topicOrSubscriber;

      if (firstType === 'string') {
        return subscribe.apply(null, arguments);
      }

      if (firstType === 'object' && !handlerOrTopics) {
        return subscribeMultiple.apply(null, arguments);
      }

      if (typeof handlerOrTopics === 'string') {
        return hitch.apply(null, arguments);
      }

      return hitchMultiple.apply(null, arguments);
    };

    function subscribe (topic, handler, context) {
      var reference = { handler: handler, context: context || obj };
      topic = topics[topic] || (topics[topic] = []);
      topic.push(reference);
      return {
        attach: function () {
          topic.push(reference);
          return this;
        },
        detach: function () {
          erase(topic, reference);
          return this;
        }
      };
    };

    function subscribeMultiple (pairs) {
      var subscriptions = {};
      for (var topic in pairs) {
        if (!pairs.hasOwnProperty(topic)) continue;
        subscriptions[topic] = subscribe(topic, pairs[topic]);
      }
      return subscriptions;
    };

    function hitch (subscriber, topic) {
      return subscribe(topic, subscriber[topic], subscriber);
    };

    function hitchMultiple (subscriber, topics) {
      var subscriptions = [];
      for (var i = 0, l = topics.length; i < l; i++) {
        subscriptions.push( hitch(subscriber, topics[i]) );
      }
      return subscriptions;
    };

    function erase (arr, victim) {
      for (var i = 0, l = arr.length; i < l; i++){
        if (arr[i] === victim) arr.splice(i, 1);
      }
    }

    return obj;
  };

  // publisher is a publisher, so meta ...
  return publisher(publisher);
}));

},{}],13:[function(require,module,exports){
/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

// Full polyfill for browsers with no classList support
if (!("classList" in document.createElement("_"))) {
  (function (view) {

  "use strict";

  if (!('Element' in view)) return;

  var
      classListProp = "classList"
    , protoProp = "prototype"
    , elemCtrProto = view.Element[protoProp]
    , objCtr = Object
    , strTrim = String[protoProp].trim || function () {
      return this.replace(/^\s+|\s+$/g, "");
    }
    , arrIndexOf = Array[protoProp].indexOf || function (item) {
      var
          i = 0
        , len = this.length
      ;
      for (; i < len; i++) {
        if (i in this && this[i] === item) {
          return i;
        }
      }
      return -1;
    }
    // Vendors: please allow content code to instantiate DOMExceptions
    , DOMEx = function (type, message) {
      this.name = type;
      this.code = DOMException[type];
      this.message = message;
    }
    , checkTokenAndGetIndex = function (classList, token) {
      if (token === "") {
        throw new DOMEx(
            "SYNTAX_ERR"
          , "An invalid or illegal string was specified"
        );
      }
      if (/\s/.test(token)) {
        throw new DOMEx(
            "INVALID_CHARACTER_ERR"
          , "String contains an invalid character"
        );
      }
      return arrIndexOf.call(classList, token);
    }
    , ClassList = function (elem) {
      var
          trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
        , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
        , i = 0
        , len = classes.length
      ;
      for (; i < len; i++) {
        this.push(classes[i]);
      }
      this._updateClassName = function () {
        elem.setAttribute("class", this.toString());
      };
    }
    , classListProto = ClassList[protoProp] = []
    , classListGetter = function () {
      return new ClassList(this);
    }
  ;
  // Most DOMException implementations don't allow calling DOMException's toString()
  // on non-DOMExceptions. Error's toString() is sufficient here.
  DOMEx[protoProp] = Error[protoProp];
  classListProto.item = function (i) {
    return this[i] || null;
  };
  classListProto.contains = function (token) {
    token += "";
    return checkTokenAndGetIndex(this, token) !== -1;
  };
  classListProto.add = function () {
    var
        tokens = arguments
      , i = 0
      , l = tokens.length
      , token
      , updated = false
    ;
    do {
      token = tokens[i] + "";
      if (checkTokenAndGetIndex(this, token) === -1) {
        this.push(token);
        updated = true;
      }
    }
    while (++i < l);

    if (updated) {
      this._updateClassName();
    }
  };
  classListProto.remove = function () {
    var
        tokens = arguments
      , i = 0
      , l = tokens.length
      , token
      , updated = false
      , index
    ;
    do {
      token = tokens[i] + "";
      index = checkTokenAndGetIndex(this, token);
      while (index !== -1) {
        this.splice(index, 1);
        updated = true;
        index = checkTokenAndGetIndex(this, token);
      }
    }
    while (++i < l);

    if (updated) {
      this._updateClassName();
    }
  };
  classListProto.toggle = function (token, force) {
    token += "";

    var
        result = this.contains(token)
      , method = result ?
        force !== true && "remove"
      :
        force !== false && "add"
    ;

    if (method) {
      this[method](token);
    }

    if (force === true || force === false) {
      return force;
    } else {
      return !result;
    }
  };
  classListProto.toString = function () {
    return this.join(" ");
  };

  if (objCtr.defineProperty) {
    var classListPropDesc = {
        get: classListGetter
      , enumerable: true
      , configurable: true
    };
    try {
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    } catch (ex) { // IE 8 doesn't support enumerable:true
      if (ex.number === -0x7FF5EC54) {
        classListPropDesc.enumerable = false;
        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
      }
    }
  } else if (objCtr[protoProp].__defineGetter__) {
    elemCtrProto.__defineGetter__(classListProp, classListGetter);
  }

  }(self));
}

/* Blob.js
 * A Blob implementation.
 * 2014-07-24
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/dsamarin
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
  "use strict";

  view.URL = view.URL || view.webkitURL;

  if (view.Blob && view.URL) {
    try {
      new Blob;
      return;
    } catch (e) {}
  }

  // Internally we use a BlobBuilder implementation to base Blob off of
  // in order to support older browsers that only have BlobBuilder
  var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
    var
        get_class = function(object) {
        return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
      }
      , FakeBlobBuilder = function BlobBuilder() {
        this.data = [];
      }
      , FakeBlob = function Blob(data, type, encoding) {
        this.data = data;
        this.size = data.length;
        this.type = type;
        this.encoding = encoding;
      }
      , FBB_proto = FakeBlobBuilder.prototype
      , FB_proto = FakeBlob.prototype
      , FileReaderSync = view.FileReaderSync
      , FileException = function(type) {
        this.code = this[this.name = type];
      }
      , file_ex_codes = (
          "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
        + "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
      ).split(" ")
      , file_ex_code = file_ex_codes.length
      , real_URL = view.URL || view.webkitURL || view
      , real_create_object_URL = real_URL.createObjectURL
      , real_revoke_object_URL = real_URL.revokeObjectURL
      , URL = real_URL
      , btoa = view.btoa
      , atob = view.atob

      , ArrayBuffer = view.ArrayBuffer
      , Uint8Array = view.Uint8Array

      , origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
    ;
    FakeBlob.fake = FB_proto.fake = true;
    while (file_ex_code--) {
      FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
    }
    // Polyfill URL
    if (!real_URL.createObjectURL) {
      URL = view.URL = function(uri) {
        var
            uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
          , uri_origin
        ;
        uri_info.href = uri;
        if (!("origin" in uri_info)) {
          if (uri_info.protocol.toLowerCase() === "data:") {
            uri_info.origin = null;
          } else {
            uri_origin = uri.match(origin);
            uri_info.origin = uri_origin && uri_origin[1];
          }
        }
        return uri_info;
      };
    }
    URL.createObjectURL = function(blob) {
      var
          type = blob.type
        , data_URI_header
      ;
      if (type === null) {
        type = "application/octet-stream";
      }
      if (blob instanceof FakeBlob) {
        data_URI_header = "data:" + type;
        if (blob.encoding === "base64") {
          return data_URI_header + ";base64," + blob.data;
        } else if (blob.encoding === "URI") {
          return data_URI_header + "," + decodeURIComponent(blob.data);
        } if (btoa) {
          return data_URI_header + ";base64," + btoa(blob.data);
        } else {
          return data_URI_header + "," + encodeURIComponent(blob.data);
        }
      } else if (real_create_object_URL) {
        return real_create_object_URL.call(real_URL, blob);
      }
    };
    URL.revokeObjectURL = function(object_URL) {
      if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
        real_revoke_object_URL.call(real_URL, object_URL);
      }
    };
    FBB_proto.append = function(data/*, endings*/) {
      var bb = this.data;
      // decode data to a binary string
      if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
        var
            str = ""
          , buf = new Uint8Array(data)
          , i = 0
          , buf_len = buf.length
        ;
        for (; i < buf_len; i++) {
          str += String.fromCharCode(buf[i]);
        }
        bb.push(str);
      } else if (get_class(data) === "Blob" || get_class(data) === "File") {
        if (FileReaderSync) {
          var fr = new FileReaderSync;
          bb.push(fr.readAsBinaryString(data));
        } else {
          // async FileReader won't work as BlobBuilder is sync
          throw new FileException("NOT_READABLE_ERR");
        }
      } else if (data instanceof FakeBlob) {
        if (data.encoding === "base64" && atob) {
          bb.push(atob(data.data));
        } else if (data.encoding === "URI") {
          bb.push(decodeURIComponent(data.data));
        } else if (data.encoding === "raw") {
          bb.push(data.data);
        }
      } else {
        if (typeof data !== "string") {
          data += ""; // convert unsupported types to strings
        }
        // decode UTF-16 to binary string
        bb.push(unescape(encodeURIComponent(data)));
      }
    };
    FBB_proto.getBlob = function(type) {
      if (!arguments.length) {
        type = null;
      }
      return new FakeBlob(this.data.join(""), type, "raw");
    };
    FBB_proto.toString = function() {
      return "[object BlobBuilder]";
    };
    FB_proto.slice = function(start, end, type) {
      var args = arguments.length;
      if (args < 3) {
        type = null;
      }
      return new FakeBlob(
          this.data.slice(start, args > 1 ? end : this.data.length)
        , type
        , this.encoding
      );
    };
    FB_proto.toString = function() {
      return "[object Blob]";
    };
    FB_proto.close = function() {
      this.size = 0;
      delete this.data;
    };
    return FakeBlobBuilder;
  }(view));

  view.Blob = function(blobParts, options) {
    var type = options ? (options.type || "") : "";
    var builder = new BlobBuilder();
    if (blobParts) {
      for (var i = 0, len = blobParts.length; i < len; i++) {
        if (Uint8Array && blobParts[i] instanceof Uint8Array) {
          builder.append(blobParts[i].buffer);
        }
        else {
          builder.append(blobParts[i]);
        }
      }
    }
    var blob = builder.getBlob(type);
    if (!blob.slice && blob.webkitSlice) {
      blob.slice = blob.webkitSlice;
    }
    return blob;
  };

  var getPrototypeOf = Object.getPrototypeOf || function(object) {
    return object.__proto__;
  };
  view.Blob.prototype = getPrototypeOf(new view.Blob());
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

(function (root, factory) {
    'use strict';
    if (typeof module === 'object') {
        module.exports = factory;
    } else if (typeof define === 'function' && define.amd) {
        define(function () {
            return factory;
        });
    } else {
        root.MediumEditor = factory;
    }
}(this, function () {

    'use strict';

function MediumEditor(elements, options) {
    'use strict';
    return this.init(elements, options);
}

MediumEditor.extensions = {};
/*jshint unused: true */
(function (window) {
    'use strict';

    function copyInto(overwrite, dest) {
        var prop,
            sources = Array.prototype.slice.call(arguments, 2);
        dest = dest || {};
        for (var i = 0; i < sources.length; i++) {
            var source = sources[i];
            if (source) {
                for (prop in source) {
                    if (source.hasOwnProperty(prop) &&
                        typeof source[prop] !== 'undefined' &&
                        (overwrite || dest.hasOwnProperty(prop) === false)) {
                        dest[prop] = source[prop];
                    }
                }
            }
        }
        return dest;
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains
    // Some browsers (including phantom) don't return true for Node.contains(child)
    // if child is a text node.  Detect these cases here and use a fallback
    // for calls to Util.isDescendant()
    var nodeContainsWorksWithTextNodes = false;
    try {
        var testParent = document.createElement('div'),
            testText = document.createTextNode(' ');
        testParent.appendChild(testText);
        nodeContainsWorksWithTextNodes = testParent.contains(testText);
    } catch (exc) {}

    var Util = {

        // http://stackoverflow.com/questions/17907445/how-to-detect-ie11#comment30165888_17907562
        // by rg89
        isIE: ((navigator.appName === 'Microsoft Internet Explorer') || ((navigator.appName === 'Netscape') && (new RegExp('Trident/.*rv:([0-9]{1,}[.0-9]{0,})').exec(navigator.userAgent) !== null))),

        isEdge: (/Edge\/\d+/).exec(navigator.userAgent) !== null,

        // if firefox
        isFF: (navigator.userAgent.toLowerCase().indexOf('firefox') > -1),

        // http://stackoverflow.com/a/11752084/569101
        isMac: (window.navigator.platform.toUpperCase().indexOf('MAC') >= 0),

        // https://github.com/jashkenas/underscore
        keyCode: {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            ESCAPE: 27,
            SPACE: 32,
            DELETE: 46,
            K: 75, // K keycode, and not k
            M: 77
        },

        /**
         * Returns true if it's metaKey on Mac, or ctrlKey on non-Mac.
         * See #591
         */
        isMetaCtrlKey: function (event) {
            if ((Util.isMac && event.metaKey) || (!Util.isMac && event.ctrlKey)) {
                return true;
            }

            return false;
        },

        /**
         * Returns true if the key associated to the event is inside keys array
         *
         * @see : https://github.com/jquery/jquery/blob/0705be475092aede1eddae01319ec931fb9c65fc/src/event.js#L473-L484
         * @see : http://stackoverflow.com/q/4471582/569101
         */
        isKey: function (event, keys) {
            var keyCode = Util.getKeyCode(event);

            // it's not an array let's just compare strings!
            if (false === Array.isArray(keys)) {
                return keyCode === keys;
            }

            if (-1 === keys.indexOf(keyCode)) {
                return false;
            }

            return true;
        },

        getKeyCode: function (event) {
            var keyCode = event.which;

            // getting the key code from event
            if (null === keyCode) {
                keyCode = event.charCode !== null ? event.charCode : event.keyCode;
            }

            return keyCode;
        },

        blockContainerElementNames: [
            // elements our editor generates
            'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'ul', 'li', 'ol',
            // all other known block elements
            'address', 'article', 'aside', 'audio', 'canvas', 'dd', 'dl', 'dt', 'fieldset',
            'figcaption', 'figure', 'footer', 'form', 'header', 'hgroup', 'main', 'nav',
            'noscript', 'output', 'section', 'video',
            'table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td'
        ],

        emptyElementNames: ['br', 'col', 'colgroup', 'hr', 'img', 'input', 'source', 'wbr'],

        extend: function extend(/* dest, source1, source2, ...*/) {
            var args = [true].concat(Array.prototype.slice.call(arguments));
            return copyInto.apply(this, args);
        },

        defaults: function defaults(/*dest, source1, source2, ...*/) {
            var args = [false].concat(Array.prototype.slice.call(arguments));
            return copyInto.apply(this, args);
        },

        /*
         * Create a link around the provided text nodes which must be adjacent to each other and all be
         * descendants of the same closest block container. If the preconditions are not met, unexpected
         * behavior will result.
         */
        createLink: function (document, textNodes, href, target) {
            var anchor = document.createElement('a');
            Util.moveTextRangeIntoElement(textNodes[0], textNodes[textNodes.length - 1], anchor);
            anchor.setAttribute('href', href);
            if (target) {
                anchor.setAttribute('target', target);
            }
            return anchor;
        },

        /*
         * Given the provided match in the format {start: 1, end: 2} where start and end are indices into the
         * textContent of the provided element argument, modify the DOM inside element to ensure that the text
         * identified by the provided match can be returned as text nodes that contain exactly that text, without
         * any additional text at the beginning or end of the returned array of adjacent text nodes.
         *
         * The only DOM manipulation performed by this function is splitting the text nodes, non-text nodes are
         * not affected in any way.
         */
        findOrCreateMatchingTextNodes: function (document, element, match) {
            var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, null, false),
                matchedNodes = [],
                currentTextIndex = 0,
                startReached = false,
                currentNode = null,
                newNode = null;

            while ((currentNode = treeWalker.nextNode()) !== null) {
                if (currentNode.nodeType > 3) {
                    continue;
                } else if (currentNode.nodeType === 3) {
                    if (!startReached && match.start < (currentTextIndex + currentNode.nodeValue.length)) {
                        startReached = true;
                        newNode = Util.splitStartNodeIfNeeded(currentNode, match.start, currentTextIndex);
                    }
                    if (startReached) {
                        Util.splitEndNodeIfNeeded(currentNode, newNode, match.end, currentTextIndex);
                    }
                    if (startReached && currentTextIndex === match.end) {
                        break; // Found the node(s) corresponding to the link. Break out and move on to the next.
                    } else if (startReached && currentTextIndex > (match.end + 1)) {
                        throw new Error('PerformLinking overshot the target!'); // should never happen...
                    }

                    if (startReached) {
                        matchedNodes.push(newNode || currentNode);
                    }

                    currentTextIndex += currentNode.nodeValue.length;
                    if (newNode !== null) {
                        currentTextIndex += newNode.nodeValue.length;
                        // Skip the newNode as we'll already have pushed it to the matches
                        treeWalker.nextNode();
                    }
                    newNode = null;
                } else if (currentNode.tagName.toLowerCase() === 'img') {
                    if (!startReached && (match.start <= currentTextIndex)) {
                        startReached = true;
                    }
                    if (startReached) {
                        matchedNodes.push(currentNode);
                    }
                }
            }
            return matchedNodes;
        },

        /*
         * Given the provided text node and text coordinates, split the text node if needed to make it align
         * precisely with the coordinates.
         *
         * This function is intended to be called from Util.findOrCreateMatchingTextNodes.
         */
        splitStartNodeIfNeeded: function (currentNode, matchStartIndex, currentTextIndex) {
            if (matchStartIndex !== currentTextIndex) {
                return currentNode.splitText(matchStartIndex - currentTextIndex);
            }
            return null;
        },

        /*
         * Given the provided text node and text coordinates, split the text node if needed to make it align
         * precisely with the coordinates. The newNode argument should from the result of Util.splitStartNodeIfNeeded,
         * if that function has been called on the same currentNode.
         *
         * This function is intended to be called from Util.findOrCreateMatchingTextNodes.
         */
        splitEndNodeIfNeeded: function (currentNode, newNode, matchEndIndex, currentTextIndex) {
            var textIndexOfEndOfFarthestNode,
                endSplitPoint;
            textIndexOfEndOfFarthestNode = currentTextIndex + (newNode || currentNode).nodeValue.length +
                    (newNode ? currentNode.nodeValue.length : 0) -
                    1;
            endSplitPoint = (newNode || currentNode).nodeValue.length -
                    (textIndexOfEndOfFarthestNode + 1 - matchEndIndex);
            if (textIndexOfEndOfFarthestNode >= matchEndIndex &&
                    currentTextIndex !== textIndexOfEndOfFarthestNode &&
                    endSplitPoint !== 0) {
                (newNode || currentNode).splitText(endSplitPoint);
            }
        },

        /*
        * Take an element, and break up all of its text content into unique pieces such that:
         * 1) All text content of the elements are in separate blocks. No piece of text content should span
         *    across multiple blocks. This means no element return by this function should have
         *    any blocks as children.
         * 2) The union of the textcontent of all of the elements returned here covers all
         *    of the text within the element.
         *
         *
         * EXAMPLE:
         * In the event that we have something like:
         *
         * <blockquote>
         *   <p>Some Text</p>
         *   <ol>
         *     <li>List Item 1</li>
         *     <li>List Item 2</li>
         *   </ol>
         * </blockquote>
         *
         * This function would return these elements as an array:
         *   [ <p>Some Text</p>, <li>List Item 1</li>, <li>List Item 2</li> ]
         *
         * Since the <blockquote> and <ol> elements contain blocks within them they are not returned.
         * Since the <p> and <li>'s don't contain block elements and cover all the text content of the
         * <blockquote> container, they are the elements returned.
         */
        splitByBlockElements: function (element) {
            if (element.nodeType !== 3 && element.nodeType !== 1) {
                return [];
            }

            var toRet = [],
                blockElementQuery = MediumEditor.util.blockContainerElementNames.join(',');

            if (element.nodeType === 3 || element.querySelectorAll(blockElementQuery).length === 0) {
                return [element];
            }

            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType === 3) {
                    toRet.push(child);
                } else if (child.nodeType === 1) {
                    var blockElements = child.querySelectorAll(blockElementQuery);
                    if (blockElements.length === 0) {
                        toRet.push(child);
                    } else {
                        toRet = toRet.concat(MediumEditor.util.splitByBlockElements(child));
                    }
                }
            }

            return toRet;
        },

        // Find the next node in the DOM tree that represents any text that is being
        // displayed directly next to the targetNode (passed as an argument)
        // Text that appears directly next to the current node can be:
        //  - A sibling text node
        //  - A descendant of a sibling element
        //  - A sibling text node of an ancestor
        //  - A descendant of a sibling element of an ancestor
        findAdjacentTextNodeWithContent: function findAdjacentTextNodeWithContent(rootNode, targetNode, ownerDocument) {
            var pastTarget = false,
                nextNode,
                nodeIterator = ownerDocument.createNodeIterator(rootNode, NodeFilter.SHOW_TEXT, null, false);

            // Use a native NodeIterator to iterate over all the text nodes that are descendants
            // of the rootNode.  Once past the targetNode, choose the first non-empty text node
            nextNode = nodeIterator.nextNode();
            while (nextNode) {
                if (nextNode === targetNode) {
                    pastTarget = true;
                } else if (pastTarget) {
                    if (nextNode.nodeType === 3 && nextNode.nodeValue && nextNode.nodeValue.trim().length > 0) {
                        break;
                    }
                }
                nextNode = nodeIterator.nextNode();
            }

            return nextNode;
        },

        // Find an element's previous sibling within a medium-editor element
        // If one doesn't exist, find the closest ancestor's previous sibling
        findPreviousSibling: function (node) {
            if (!node || Util.isMediumEditorElement(node)) {
                return false;
            }

            var previousSibling = node.previousSibling;
            while (!previousSibling && !Util.isMediumEditorElement(node.parentNode)) {
                node = node.parentNode;
                previousSibling = node.previousSibling;
            }

            return previousSibling;
        },

        isDescendant: function isDescendant(parent, child, checkEquality) {
            if (!parent || !child) {
                return false;
            }
            if (parent === child) {
                return !!checkEquality;
            }
            // If parent is not an element, it can't have any descendants
            if (parent.nodeType !== 1) {
                return false;
            }
            if (nodeContainsWorksWithTextNodes || child.nodeType !== 3) {
                return parent.contains(child);
            }
            var node = child.parentNode;
            while (node !== null) {
                if (node === parent) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        },

        // https://github.com/jashkenas/underscore
        isElement: function isElement(obj) {
            return !!(obj && obj.nodeType === 1);
        },

        // https://github.com/jashkenas/underscore
        throttle: function (func, wait) {
            var THROTTLE_INTERVAL = 50,
                context,
                args,
                result,
                timeout = null,
                previous = 0,
                later = function () {
                    previous = Date.now();
                    timeout = null;
                    result = func.apply(context, args);
                    if (!timeout) {
                        context = args = null;
                    }
                };

            if (!wait && wait !== 0) {
                wait = THROTTLE_INTERVAL;
            }

            return function () {
                var now = Date.now(),
                    remaining = wait - (now - previous);

                context = this;
                args = arguments;
                if (remaining <= 0 || remaining > wait) {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                    }
                    previous = now;
                    result = func.apply(context, args);
                    if (!timeout) {
                        context = args = null;
                    }
                } else if (!timeout) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        },

        traverseUp: function (current, testElementFunction) {
            if (!current) {
                return false;
            }

            do {
                if (current.nodeType === 1) {
                    if (testElementFunction(current)) {
                        return current;
                    }
                    // do not traverse upwards past the nearest containing editor
                    if (Util.isMediumEditorElement(current)) {
                        return false;
                    }
                }

                current = current.parentNode;
            } while (current);

            return false;
        },

        htmlEntities: function (str) {
            // converts special characters (like <) into their escaped/encoded values (like &lt;).
            // This allows you to show to display the string without the browser reading it as HTML.
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        },

        // http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
        insertHTMLCommand: function (doc, html) {
            var selection, range, el, fragment, node, lastNode, toReplace,
                res = false,
                ecArgs = ['insertHTML', false, html];

            /* Edge's implementation of insertHTML is just buggy right now:
             * - Doesn't allow leading white space at the beginning of an element
             * - Found a case when a <font size="2"> tag was inserted when calling alignCenter inside a blockquote
             *
             * There are likely other bugs, these are just the ones we found so far.
             * For now, let's just use the same fallback we did for IE
             */
            if (!MediumEditor.util.isEdge && doc.queryCommandSupported('insertHTML')) {
                try {
                    return doc.execCommand.apply(doc, ecArgs);
                } catch (ignore) {}
            }

            selection = doc.getSelection();
            if (selection.rangeCount) {
                range = selection.getRangeAt(0);
                toReplace = range.commonAncestorContainer;

                // https://github.com/yabwe/medium-editor/issues/748
                // If the selection is an empty editor element, create a temporary text node inside of the editor
                // and select it so that we don't delete the editor element
                if (Util.isMediumEditorElement(toReplace) && !toReplace.firstChild) {
                    range.selectNode(toReplace.appendChild(doc.createTextNode('')));
                } else if ((toReplace.nodeType === 3 && range.startOffset === 0 && range.endOffset === toReplace.nodeValue.length) ||
                        (toReplace.nodeType !== 3 && toReplace.innerHTML === range.toString())) {
                    // Ensure range covers maximum amount of nodes as possible
                    // By moving up the DOM and selecting ancestors whose only child is the range
                    while (!Util.isMediumEditorElement(toReplace) &&
                            toReplace.parentNode &&
                            toReplace.parentNode.childNodes.length === 1 &&
                            !Util.isMediumEditorElement(toReplace.parentNode)) {
                        toReplace = toReplace.parentNode;
                    }
                    range.selectNode(toReplace);
                }
                range.deleteContents();

                el = doc.createElement('div');
                el.innerHTML = html;
                fragment = doc.createDocumentFragment();
                while (el.firstChild) {
                    node = el.firstChild;
                    lastNode = fragment.appendChild(node);
                }
                range.insertNode(fragment);

                // Preserve the selection:
                if (lastNode) {
                    range = range.cloneRange();
                    range.setStartAfter(lastNode);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                res = true;
            }

            // https://github.com/yabwe/medium-editor/issues/992
            // If we're monitoring calls to execCommand, notify listeners as if a real call had happened
            if (doc.execCommand.callListeners) {
                doc.execCommand.callListeners(ecArgs, res);
            }
            return res;
        },

        execFormatBlock: function (doc, tagName) {
            // Get the top level block element that contains the selection
            var blockContainer = Util.getTopBlockContainer(MediumEditor.selection.getSelectionStart(doc)),
                childNodes;

            // Special handling for blockquote
            if (tagName === 'blockquote') {
                if (blockContainer) {
                    childNodes = Array.prototype.slice.call(blockContainer.childNodes);
                    // Check if the blockquote has a block element as a child (nested blocks)
                    if (childNodes.some(function (childNode) {
                        return Util.isBlockContainer(childNode);
                    })) {
                        // FF handles blockquote differently on formatBlock
                        // allowing nesting, we need to use outdent
                        // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla
                        return doc.execCommand('outdent', false, null);
                    }
                }

                // When IE blockquote needs to be called as indent
                // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777
                if (Util.isIE) {
                    return doc.execCommand('indent', false, tagName);
                }
            }

            // If the blockContainer is already the element type being passed in
            // treat it as 'undo' formatting and just convert it to a <p>
            if (blockContainer && tagName === blockContainer.nodeName.toLowerCase()) {
                tagName = 'p';
            }

            // When IE we need to add <> to heading elements
            // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
            if (Util.isIE) {
                tagName = '<' + tagName + '>';
            }

            // When FF, IE and Edge, we have to handle blockquote node seperately as 'formatblock' does not work.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Commands
            if (blockContainer && blockContainer.nodeName.toLowerCase() === 'blockquote') {
                // For IE, just use outdent
                if (Util.isIE && tagName === '<p>') {
                    return doc.execCommand('outdent', false, tagName);
                }

                // For Firefox and Edge, make sure there's a nested block element before calling outdent
                if ((Util.isFF || Util.isEdge) && tagName === 'p') {
                    childNodes = Array.prototype.slice.call(blockContainer.childNodes);
                    // If there are some non-block elements we need to wrap everything in a <p> before we outdent
                    if (childNodes.some(function (childNode) {
                        return !Util.isBlockContainer(childNode);
                    })) {
                        doc.execCommand('formatBlock', false, tagName);
                    }
                    return doc.execCommand('outdent', false, tagName);
                }
            }

            return doc.execCommand('formatBlock', false, tagName);
        },

        /**
         * Set target to blank on the given el element
         *
         * TODO: not sure if this should be here
         *
         * When creating a link (using core -> createLink) the selection returned by Firefox will be the parent of the created link
         * instead of the created link itself (as it is for Chrome for example), so we retrieve all "a" children to grab the good one by
         * using `anchorUrl` to ensure that we are adding target="_blank" on the good one.
         * This isn't a bulletproof solution anyway ..
         */
        setTargetBlank: function (el, anchorUrl) {
            var i, url = anchorUrl || false;
            if (el.nodeName.toLowerCase() === 'a') {
                el.target = '_blank';
            } else {
                el = el.getElementsByTagName('a');

                for (i = 0; i < el.length; i += 1) {
                    if (false === url || url === el[i].attributes.href.value) {
                        el[i].target = '_blank';
                    }
                }
            }
        },

        /*
         * this function is called to explicitly remove the target='_blank' as FF holds on to _blank value even
         * after unchecking the checkbox on anchor form
         */
        removeTargetBlank: function (el, anchorUrl) {
            var i;
            if (el.nodeName.toLowerCase() === 'a') {
                el.removeAttribute('target');
            } else {
                el = el.getElementsByTagName('a');

                for (i = 0; i < el.length; i += 1) {
                    if (anchorUrl === el[i].attributes.href.value) {
                        el[i].removeAttribute('target');
                    }
                }
            }
        },

        addClassToAnchors: function (el, buttonClass) {
            var classes = buttonClass.split(' '),
                i,
                j;
            if (el.nodeName.toLowerCase() === 'a') {
                for (j = 0; j < classes.length; j += 1) {
                    el.classList.add(classes[j]);
                }
            } else {
                el = el.getElementsByTagName('a');
                for (i = 0; i < el.length; i += 1) {
                    for (j = 0; j < classes.length; j += 1) {
                        el[i].classList.add(classes[j]);
                    }
                }
            }
        },

        isListItem: function (node) {
            if (!node) {
                return false;
            }
            if (node.nodeName.toLowerCase() === 'li') {
                return true;
            }

            var parentNode = node.parentNode,
                tagName = parentNode.nodeName.toLowerCase();
            while (tagName === 'li' || (!Util.isBlockContainer(parentNode) && tagName !== 'div')) {
                if (tagName === 'li') {
                    return true;
                }
                parentNode = parentNode.parentNode;
                if (parentNode) {
                    tagName = parentNode.nodeName.toLowerCase();
                } else {
                    return false;
                }
            }
            return false;
        },

        cleanListDOM: function (ownerDocument, element) {
            if (element.nodeName.toLowerCase() !== 'li') {
                return;
            }

            var list = element.parentElement;

            if (list.parentElement.nodeName.toLowerCase() === 'p') { // yes we need to clean up
                Util.unwrap(list.parentElement, ownerDocument);

                // move cursor at the end of the text inside the list
                // for some unknown reason, the cursor is moved to end of the "visual" line
                MediumEditor.selection.moveCursor(ownerDocument, element.firstChild, element.firstChild.textContent.length);
            }
        },

        /* splitDOMTree
         *
         * Given a root element some descendant element, split the root element
         * into its own element containing the descendant element and all elements
         * on the left or right side of the descendant ('right' is default)
         *
         * example:
         *
         *         <div>
         *      /    |   \
         *  <span> <span> <span>
         *   / \    / \    / \
         *  1   2  3   4  5   6
         *
         *  If I wanted to split this tree given the <div> as the root and "4" as the leaf
         *  the result would be (the prime ' marks indicates nodes that are created as clones):
         *
         *   SPLITTING OFF 'RIGHT' TREE       SPLITTING OFF 'LEFT' TREE
         *
         *     <div>            <div>'              <div>'      <div>
         *      / \              / \                 / \          |
         * <span> <span>   <span>' <span>       <span> <span>   <span>
         *   / \    |        |      / \           /\     /\       /\
         *  1   2   3        4     5   6         1  2   3  4     5  6
         *
         *  The above example represents splitting off the 'right' or 'left' part of a tree, where
         *  the <div>' would be returned as an element not appended to the DOM, and the <div>
         *  would remain in place where it was
         *
        */
        splitOffDOMTree: function (rootNode, leafNode, splitLeft) {
            var splitOnNode = leafNode,
                createdNode = null,
                splitRight = !splitLeft;

            // loop until we hit the root
            while (splitOnNode !== rootNode) {
                var currParent = splitOnNode.parentNode,
                    newParent = currParent.cloneNode(false),
                    targetNode = (splitRight ? splitOnNode : currParent.firstChild),
                    appendLast;

                // Create a new parent element which is a clone of the current parent
                if (createdNode) {
                    if (splitRight) {
                        // If we're splitting right, add previous created element before siblings
                        newParent.appendChild(createdNode);
                    } else {
                        // If we're splitting left, add previous created element last
                        appendLast = createdNode;
                    }
                }
                createdNode = newParent;

                while (targetNode) {
                    var sibling = targetNode.nextSibling;
                    // Special handling for the 'splitNode'
                    if (targetNode === splitOnNode) {
                        if (!targetNode.hasChildNodes()) {
                            targetNode.parentNode.removeChild(targetNode);
                        } else {
                            // For the node we're splitting on, if it has children, we need to clone it
                            // and not just move it
                            targetNode = targetNode.cloneNode(false);
                        }
                        // If the resulting split node has content, add it
                        if (targetNode.textContent) {
                            createdNode.appendChild(targetNode);
                        }

                        targetNode = (splitRight ? sibling : null);
                    } else {
                        // For general case, just remove the element and only
                        // add it to the split tree if it contains something
                        targetNode.parentNode.removeChild(targetNode);
                        if (targetNode.hasChildNodes() || targetNode.textContent) {
                            createdNode.appendChild(targetNode);
                        }

                        targetNode = sibling;
                    }
                }

                // If we had an element we wanted to append at the end, do that now
                if (appendLast) {
                    createdNode.appendChild(appendLast);
                }

                splitOnNode = currParent;
            }

            return createdNode;
        },

        moveTextRangeIntoElement: function (startNode, endNode, newElement) {
            if (!startNode || !endNode) {
                return false;
            }

            var rootNode = Util.findCommonRoot(startNode, endNode);
            if (!rootNode) {
                return false;
            }

            if (endNode === startNode) {
                var temp = startNode.parentNode,
                    sibling = startNode.nextSibling;
                temp.removeChild(startNode);
                newElement.appendChild(startNode);
                if (sibling) {
                    temp.insertBefore(newElement, sibling);
                } else {
                    temp.appendChild(newElement);
                }
                return newElement.hasChildNodes();
            }

            // create rootChildren array which includes all the children
            // we care about
            var rootChildren = [],
                firstChild,
                lastChild,
                nextNode;
            for (var i = 0; i < rootNode.childNodes.length; i++) {
                nextNode = rootNode.childNodes[i];
                if (!firstChild) {
                    if (Util.isDescendant(nextNode, startNode, true)) {
                        firstChild = nextNode;
                    }
                } else {
                    if (Util.isDescendant(nextNode, endNode, true)) {
                        lastChild = nextNode;
                        break;
                    } else {
                        rootChildren.push(nextNode);
                    }
                }
            }

            var afterLast = lastChild.nextSibling,
                fragment = rootNode.ownerDocument.createDocumentFragment();

            // build up fragment on startNode side of tree
            if (firstChild === startNode) {
                firstChild.parentNode.removeChild(firstChild);
                fragment.appendChild(firstChild);
            } else {
                fragment.appendChild(Util.splitOffDOMTree(firstChild, startNode));
            }

            // add any elements between firstChild & lastChild
            rootChildren.forEach(function (element) {
                element.parentNode.removeChild(element);
                fragment.appendChild(element);
            });

            // build up fragment on endNode side of the tree
            if (lastChild === endNode) {
                lastChild.parentNode.removeChild(lastChild);
                fragment.appendChild(lastChild);
            } else {
                fragment.appendChild(Util.splitOffDOMTree(lastChild, endNode, true));
            }

            // Add fragment into passed in element
            newElement.appendChild(fragment);

            if (lastChild.parentNode === rootNode) {
                // If last child is in the root, insert newElement in front of it
                rootNode.insertBefore(newElement, lastChild);
            } else if (afterLast) {
                // If last child was removed, but it had a sibling, insert in front of it
                rootNode.insertBefore(newElement, afterLast);
            } else {
                // lastChild was removed and was the last actual element just append
                rootNode.appendChild(newElement);
            }

            return newElement.hasChildNodes();
        },

        /* based on http://stackoverflow.com/a/6183069 */
        depthOfNode: function (inNode) {
            var theDepth = 0,
                node = inNode;
            while (node.parentNode !== null) {
                node = node.parentNode;
                theDepth++;
            }
            return theDepth;
        },

        findCommonRoot: function (inNode1, inNode2) {
            var depth1 = Util.depthOfNode(inNode1),
                depth2 = Util.depthOfNode(inNode2),
                node1 = inNode1,
                node2 = inNode2;

            while (depth1 !== depth2) {
                if (depth1 > depth2) {
                    node1 = node1.parentNode;
                    depth1 -= 1;
                } else {
                    node2 = node2.parentNode;
                    depth2 -= 1;
                }
            }

            while (node1 !== node2) {
                node1 = node1.parentNode;
                node2 = node2.parentNode;
            }

            return node1;
        },
        /* END - based on http://stackoverflow.com/a/6183069 */

        isElementAtBeginningOfBlock: function (node) {
            var textVal,
                sibling;
            while (!Util.isBlockContainer(node) && !Util.isMediumEditorElement(node)) {
                sibling = node;
                while (sibling = sibling.previousSibling) {
                    textVal = sibling.nodeType === 3 ? sibling.nodeValue : sibling.textContent;
                    if (textVal.length > 0) {
                        return false;
                    }
                }
                node = node.parentNode;
            }
            return true;
        },

        isMediumEditorElement: function (element) {
            return element && element.getAttribute && !!element.getAttribute('data-medium-editor-element');
        },

        getContainerEditorElement: function (element) {
            return Util.traverseUp(element, function (node) {
                return Util.isMediumEditorElement(node);
            });
        },

        isBlockContainer: function (element) {
            return element && element.nodeType !== 3 && Util.blockContainerElementNames.indexOf(element.nodeName.toLowerCase()) !== -1;
        },

        /* Finds the closest ancestor which is a block container element
         * If element is within editor element but not within any other block element,
         * the editor element is returned
         */
        getClosestBlockContainer: function (node) {
            return Util.traverseUp(node, function (node) {
                return Util.isBlockContainer(node) || Util.isMediumEditorElement(node);
            });
        },

        /* Finds highest level ancestor element which is a block container element
         * If element is within editor element but not within any other block element,
         * the editor element is returned
         */
        getTopBlockContainer: function (element) {
            var topBlock = Util.isBlockContainer(element) ? element : false;
            Util.traverseUp(element, function (el) {
                if (Util.isBlockContainer(el)) {
                    topBlock = el;
                }
                if (!topBlock && Util.isMediumEditorElement(el)) {
                    topBlock = el;
                    return true;
                }
                return false;
            });
            return topBlock;
        },

        getFirstSelectableLeafNode: function (element) {
            while (element && element.firstChild) {
                element = element.firstChild;
            }

            // We don't want to set the selection to an element that can't have children, this messes up Gecko.
            element = Util.traverseUp(element, function (el) {
                return Util.emptyElementNames.indexOf(el.nodeName.toLowerCase()) === -1;
            });
            // Selecting at the beginning of a table doesn't work in PhantomJS.
            if (element.nodeName.toLowerCase() === 'table') {
                var firstCell = element.querySelector('th, td');
                if (firstCell) {
                    element = firstCell;
                }
            }
            return element;
        },

        // TODO: remove getFirstTextNode AND _getFirstTextNode when jumping in 6.0.0 (no code references)
        getFirstTextNode: function (element) {
            Util.warn('getFirstTextNode is deprecated and will be removed in version 6.0.0');
            return Util._getFirstTextNode(element);
        },

        _getFirstTextNode: function (element) {
            if (element.nodeType === 3) {
                return element;
            }

            for (var i = 0; i < element.childNodes.length; i++) {
                var textNode = Util._getFirstTextNode(element.childNodes[i]);
                if (textNode !== null) {
                    return textNode;
                }
            }
            return null;
        },

        ensureUrlHasProtocol: function (url) {
            if (url.indexOf('://') === -1) {
                return 'http://' + url;
            }
            return url;
        },

        warn: function () {
            if (window.console !== undefined && typeof window.console.warn === 'function') {
                window.console.warn.apply(window.console, arguments);
            }
        },

        deprecated: function (oldName, newName, version) {
            // simple deprecation warning mechanism.
            var m = oldName + ' is deprecated, please use ' + newName + ' instead.';
            if (version) {
                m += ' Will be removed in ' + version;
            }
            Util.warn(m);
        },

        deprecatedMethod: function (oldName, newName, args, version) {
            // run the replacement and warn when someone calls a deprecated method
            Util.deprecated(oldName, newName, version);
            if (typeof this[newName] === 'function') {
                this[newName].apply(this, args);
            }
        },

        cleanupAttrs: function (el, attrs) {
            attrs.forEach(function (attr) {
                el.removeAttribute(attr);
            });
        },

        cleanupTags: function (el, tags) {
            tags.forEach(function (tag) {
                if (el.nodeName.toLowerCase() === tag) {
                    el.parentNode.removeChild(el);
                }
            });
        },

        // get the closest parent
        getClosestTag: function (el, tag) {
            return Util.traverseUp(el, function (element) {
                return element.nodeName.toLowerCase() === tag.toLowerCase();
            });
        },

        unwrap: function (el, doc) {
            var fragment = doc.createDocumentFragment(),
                nodes = Array.prototype.slice.call(el.childNodes);

            // cast nodeList to array since appending child
            // to a different node will alter length of el.childNodes
            for (var i = 0; i < nodes.length; i++) {
                fragment.appendChild(nodes[i]);
            }

            if (fragment.childNodes.length) {
                el.parentNode.replaceChild(fragment, el);
            } else {
                el.parentNode.removeChild(el);
            }
        }
    };

    MediumEditor.util = Util;
}(window));

(function () {
    'use strict';

    var Extension = function (options) {
        MediumEditor.util.extend(this, options);
    };

    Extension.extend = function (protoProps) {
        // magic extender thinger. mostly borrowed from backbone/goog.inherits
        // place this function on some thing you want extend-able.
        //
        // example:
        //
        //      function Thing(args){
        //          this.options = args;
        //      }
        //
        //      Thing.prototype = { foo: "bar" };
        //      Thing.extend = extenderify;
        //
        //      var ThingTwo = Thing.extend({ foo: "baz" });
        //
        //      var thingOne = new Thing(); // foo === "bar"
        //      var thingTwo = new ThingTwo(); // foo === "baz"
        //
        //      which seems like some simply shallow copy nonsense
        //      at first, but a lot more is going on there.
        //
        //      passing a `constructor` to the extend props
        //      will cause the instance to instantiate through that
        //      instead of the parent's constructor.

        var parent = this,
            child;

        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent's constructor.

        if (protoProps && protoProps.hasOwnProperty('constructor')) {
            child = protoProps.constructor;
        } else {
            child = function () {
                return parent.apply(this, arguments);
            };
        }

        // das statics (.extend comes over, so your subclass can have subclasses too)
        MediumEditor.util.extend(child, parent);

        // Set the prototype chain to inherit from `parent`, without calling
        // `parent`'s constructor function.
        var Surrogate = function () {
            this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate();

        if (protoProps) {
            MediumEditor.util.extend(child.prototype, protoProps);
        }

        // todo: $super?

        return child;
    };

    Extension.prototype = {
        /* init: [function]
         *
         * Called by MediumEditor during initialization.
         * The .base property will already have been set to
         * current instance of MediumEditor when this is called.
         * All helper methods will exist as well
         */
        init: function () {},

        /* base: [MediumEditor instance]
         *
         * If not overriden, this will be set to the current instance
         * of MediumEditor, before the init method is called
         */
        base: undefined,

        /* name: [string]
         *
         * 'name' of the extension, used for retrieving the extension.
         * If not set, MediumEditor will set this to be the key
         * used when passing the extension into MediumEditor via the
         * 'extensions' option
         */
        name: undefined,

        /* checkState: [function (node)]
         *
         * If implemented, this function will be called one or more times
         * the state of the editor & toolbar are updated.
         * When the state is updated, the editor does the following:
         *
         * 1) Find the parent node containing the current selection
         * 2) Call checkState on the extension, passing the node as an argument
         * 3) Get the parent node of the previous node
         * 4) Repeat steps #2 and #3 until we move outside the parent contenteditable
         */
        checkState: undefined,

        /* destroy: [function ()]
         *
         * This method should remove any created html, custom event handlers
         * or any other cleanup tasks that should be performed.
         * If implemented, this function will be called when MediumEditor's
         * destroy method has been called.
         */
        destroy: undefined,

        /* As alternatives to checkState, these functions provide a more structured
         * path to updating the state of an extension (usually a button) whenever
         * the state of the editor & toolbar are updated.
         */

        /* queryCommandState: [function ()]
         *
         * If implemented, this function will be called once on each extension
         * when the state of the editor/toolbar is being updated.
         *
         * If this function returns a non-null value, the extension will
         * be ignored as the code climbs the dom tree.
         *
         * If this function returns true, and the setActive() function is defined
         * setActive() will be called
         */
        queryCommandState: undefined,

        /* isActive: [function ()]
         *
         * If implemented, this function will be called when MediumEditor
         * has determined that this extension is 'active' for the current selection.
         * This may be called when the editor & toolbar are being updated,
         * but only if queryCommandState() or isAlreadyApplied() functions
         * are implemented, and when called, return true.
         */
        isActive: undefined,

        /* isAlreadyApplied: [function (node)]
         *
         * If implemented, this function is similar to checkState() in
         * that it will be called repeatedly as MediumEditor moves up
         * the DOM to update the editor & toolbar after a state change.
         *
         * NOTE: This function will NOT be called if checkState() has
         * been implemented. This function will NOT be called if
         * queryCommandState() is implemented and returns a non-null
         * value when called
         */
        isAlreadyApplied: undefined,

        /* setActive: [function ()]
         *
         * If implemented, this function is called when MediumEditor knows
         * that this extension is currently enabled.  Currently, this
         * function is called when updating the editor & toolbar, and
         * only if queryCommandState() or isAlreadyApplied(node) return
         * true when called
         */
        setActive: undefined,

        /* setInactive: [function ()]
         *
         * If implemented, this function is called when MediumEditor knows
         * that this extension is currently disabled.  Curently, this
         * is called at the beginning of each state change for
         * the editor & toolbar. After calling this, MediumEditor
         * will attempt to update the extension, either via checkState()
         * or the combination of queryCommandState(), isAlreadyApplied(node),
         * isActive(), and setActive()
         */
        setInactive: undefined,

        /************************ Helpers ************************
         * The following are helpers that are either set by MediumEditor
         * during initialization, or are helper methods which either
         * route calls to the MediumEditor instance or provide common
         * functionality for all extensions
         *********************************************************/

        /* window: [Window]
         *
         * If not overriden, this will be set to the window object
         * to be used by MediumEditor and its extensions.  This is
         * passed via the 'contentWindow' option to MediumEditor
         * and is the global 'window' object by default
         */
        'window': undefined,

        /* document: [Document]
         *
         * If not overriden, this will be set to the document object
         * to be used by MediumEditor and its extensions. This is
         * passed via the 'ownerDocument' optin to MediumEditor
         * and is the global 'document' object by default
         */
        'document': undefined,

        /* getEditorElements: [function ()]
         *
         * Helper function which returns an array containing
         * all the contenteditable elements for this instance
         * of MediumEditor
         */
        getEditorElements: function () {
            return this.base.elements;
        },

        /* getEditorId: [function ()]
         *
         * Helper function which returns a unique identifier
         * for this instance of MediumEditor
         */
        getEditorId: function () {
            return this.base.id;
        },

        /* getEditorOptions: [function (option)]
         *
         * Helper function which returns the value of an option
         * used to initialize this instance of MediumEditor
         */
        getEditorOption: function (option) {
            return this.base.options[option];
        }
    };

    /* List of method names to add to the prototype of Extension
     * Each of these methods will be defined as helpers that
     * just call directly into the MediumEditor instance.
     *
     * example for 'on' method:
     * Extension.prototype.on = function () {
     *     return this.base.on.apply(this.base, arguments);
     * }
     */
    [
        // general helpers
        'execAction',

        // event handling
        'on',
        'off',
        'subscribe',
        'trigger'

    ].forEach(function (helper) {
        Extension.prototype[helper] = function () {
            return this.base[helper].apply(this.base, arguments);
        };
    });

    MediumEditor.Extension = Extension;
})();

(function () {
    'use strict';

    function filterOnlyParentElements(node) {
        if (MediumEditor.util.isBlockContainer(node)) {
            return NodeFilter.FILTER_ACCEPT;
        } else {
            return NodeFilter.FILTER_SKIP;
        }
    }

    var Selection = {
        findMatchingSelectionParent: function (testElementFunction, contentWindow) {
            var selection = contentWindow.getSelection(),
                range,
                current;

            if (selection.rangeCount === 0) {
                return false;
            }

            range = selection.getRangeAt(0);
            current = range.commonAncestorContainer;

            return MediumEditor.util.traverseUp(current, testElementFunction);
        },

        getSelectionElement: function (contentWindow) {
            return this.findMatchingSelectionParent(function (el) {
                return MediumEditor.util.isMediumEditorElement(el);
            }, contentWindow);
        },

        // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html
        // Tim Down
        exportSelection: function (root, doc) {
            if (!root) {
                return null;
            }

            var selectionState = null,
                selection = doc.getSelection();

            if (selection.rangeCount > 0) {
                var range = selection.getRangeAt(0),
                    preSelectionRange = range.cloneRange(),
                    start;

                preSelectionRange.selectNodeContents(root);
                preSelectionRange.setEnd(range.startContainer, range.startOffset);
                start = preSelectionRange.toString().length;

                selectionState = {
                    start: start,
                    end: start + range.toString().length
                };

                // Check to see if the selection starts with any images
                // if so we need to make sure the the beginning of the selection is
                // set correctly when importing selection
                if (this.doesRangeStartWithImages(range, doc)) {
                    selectionState.startsWithImage = true;
                }

                // Check to see if the selection has any trailing images
                // if so, this this means we need to look for them when we import selection
                var trailingImageCount = this.getTrailingImageCount(root, selectionState, range.endContainer, range.endOffset);
                if (trailingImageCount) {
                    selectionState.trailingImageCount = trailingImageCount;
                }

                // If start = 0 there may still be an empty paragraph before it, but we don't care.
                if (start !== 0) {
                    var emptyBlocksIndex = this.getIndexRelativeToAdjacentEmptyBlocks(doc, root, range.startContainer, range.startOffset);
                    if (emptyBlocksIndex !== -1) {
                        selectionState.emptyBlocksIndex = emptyBlocksIndex;
                    }
                }
            }

            return selectionState;
        },

        // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html
        // Tim Down
        //
        // {object} selectionState - the selection to import
        // {DOMElement} root - the root element the selection is being restored inside of
        // {Document} doc - the document to use for managing selection
        // {boolean} [favorLaterSelectionAnchor] - defaults to false. If true, import the cursor immediately
        //      subsequent to an anchor tag if it would otherwise be placed right at the trailing edge inside the
        //      anchor. This cursor positioning, even though visually equivalent to the user, can affect behavior
        //      in MS IE.
        importSelection: function (selectionState, root, doc, favorLaterSelectionAnchor) {
            if (!selectionState || !root) {
                return;
            }

            var range = doc.createRange();
            range.setStart(root, 0);
            range.collapse(true);

            var node = root,
                nodeStack = [],
                charIndex = 0,
                foundStart = false,
                foundEnd = false,
                trailingImageCount = 0,
                stop = false,
                nextCharIndex,
                allowRangeToStartAtEndOfNode = false,
                lastTextNode = null;

            // When importing selection, the start of the selection may lie at the end of an element
            // or at the beginning of an element.  Since visually there is no difference between these 2
            // we will try to move the selection to the beginning of an element since this is generally
            // what users will expect and it's a more predictable behavior.
            //
            // However, there are some specific cases when we don't want to do this:
            //  1) We're attempting to move the cursor outside of the end of an anchor [favorLaterSelectionAnchor = true]
            //  2) The selection starts with an image, which is special since an image doesn't have any 'content'
            //     as far as selection and ranges are concerned
            //  3) The selection starts after a specified number of empty block elements (selectionState.emptyBlocksIndex)
            //
            // For these cases, we want the selection to start at a very specific location, so we should NOT
            // automatically move the cursor to the beginning of the first actual chunk of text
            if (favorLaterSelectionAnchor || selectionState.startsWithImage || typeof selectionState.emptyBlocksIndex !== 'undefined') {
                allowRangeToStartAtEndOfNode = true;
            }

            while (!stop && node) {
                // Only iterate over elements and text nodes
                if (node.nodeType > 3) {
                    node = nodeStack.pop();
                    continue;
                }

                // If we hit a text node, we need to add the amount of characters to the overall count
                if (node.nodeType === 3 && !foundEnd) {
                    nextCharIndex = charIndex + node.length;
                    // Check if we're at or beyond the start of the selection we're importing
                    if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {
                        // NOTE: We only want to allow a selection to start at the END of an element if
                        //  allowRangeToStartAtEndOfNode is true
                        if (allowRangeToStartAtEndOfNode || selectionState.start < nextCharIndex) {
                            range.setStart(node, selectionState.start - charIndex);
                            foundStart = true;
                        }
                        // We're at the end of a text node where the selection could start but we shouldn't
                        // make the selection start here because allowRangeToStartAtEndOfNode is false.
                        // However, we should keep a reference to this node in case there aren't any more
                        // text nodes after this, so that we have somewhere to import the selection to
                        else {
                            lastTextNode = node;
                        }
                    }
                    // We've found the start of the selection, check if we're at or beyond the end of the selection we're importing
                    if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {
                        if (!selectionState.trailingImageCount) {
                            range.setEnd(node, selectionState.end - charIndex);
                            stop = true;
                        } else {
                            foundEnd = true;
                        }
                    }
                    charIndex = nextCharIndex;
                } else {
                    if (selectionState.trailingImageCount && foundEnd) {
                        if (node.nodeName.toLowerCase() === 'img') {
                            trailingImageCount++;
                        }
                        if (trailingImageCount === selectionState.trailingImageCount) {
                            // Find which index the image is in its parent's children
                            var endIndex = 0;
                            while (node.parentNode.childNodes[endIndex] !== node) {
                                endIndex++;
                            }
                            range.setEnd(node.parentNode, endIndex + 1);
                            stop = true;
                        }
                    }

                    if (!stop && node.nodeType === 1) {
                        // this is an element
                        // add all its children to the stack
                        var i = node.childNodes.length - 1;
                        while (i >= 0) {
                            nodeStack.push(node.childNodes[i]);
                            i -= 1;
                        }
                    }
                }

                if (!stop) {
                    node = nodeStack.pop();
                }
            }

            // If we've gone through the entire text but didn't find the beginning of a text node
            // to make the selection start at, we should fall back to starting the selection
            // at the END of the last text node we found
            if (!foundStart && lastTextNode) {
                range.setStart(lastTextNode, lastTextNode.length);
                range.setEnd(lastTextNode, lastTextNode.length);
            }

            if (typeof selectionState.emptyBlocksIndex !== 'undefined') {
                range = this.importSelectionMoveCursorPastBlocks(doc, root, selectionState.emptyBlocksIndex, range);
            }

            // If the selection is right at the ending edge of a link, put it outside the anchor tag instead of inside.
            if (favorLaterSelectionAnchor) {
                range = this.importSelectionMoveCursorPastAnchor(selectionState, range);
            }

            var sel = doc.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        },

        // Utility method called from importSelection only
        importSelectionMoveCursorPastAnchor: function (selectionState, range) {
            var nodeInsideAnchorTagFunction = function (node) {
                return node.nodeName.toLowerCase() === 'a';
            };
            if (selectionState.start === selectionState.end &&
                    range.startContainer.nodeType === 3 &&
                    range.startOffset === range.startContainer.nodeValue.length &&
                    MediumEditor.util.traverseUp(range.startContainer, nodeInsideAnchorTagFunction)) {
                var prevNode = range.startContainer,
                    currentNode = range.startContainer.parentNode;
                while (currentNode !== null && currentNode.nodeName.toLowerCase() !== 'a') {
                    if (currentNode.childNodes[currentNode.childNodes.length - 1] !== prevNode) {
                        currentNode = null;
                    } else {
                        prevNode = currentNode;
                        currentNode = currentNode.parentNode;
                    }
                }
                if (currentNode !== null && currentNode.nodeName.toLowerCase() === 'a') {
                    var currentNodeIndex = null;
                    for (var i = 0; currentNodeIndex === null && i < currentNode.parentNode.childNodes.length; i++) {
                        if (currentNode.parentNode.childNodes[i] === currentNode) {
                            currentNodeIndex = i;
                        }
                    }
                    range.setStart(currentNode.parentNode, currentNodeIndex + 1);
                    range.collapse(true);
                }
            }
            return range;
        },

        // Uses the emptyBlocksIndex calculated by getIndexRelativeToAdjacentEmptyBlocks
        // to move the cursor back to the start of the correct paragraph
        importSelectionMoveCursorPastBlocks: function (doc, root, index, range) {
            var treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false),
                startContainer = range.startContainer,
                startBlock,
                targetNode,
                currIndex = 0;
            index = index || 1; // If index is 0, we still want to move to the next block

            // Chrome counts newlines and spaces that separate block elements as actual elements.
            // If the selection is inside one of these text nodes, and it has a previous sibling
            // which is a block element, we want the treewalker to start at the previous sibling
            // and NOT at the parent of the textnode
            if (startContainer.nodeType === 3 && MediumEditor.util.isBlockContainer(startContainer.previousSibling)) {
                startBlock = startContainer.previousSibling;
            } else {
                startBlock = MediumEditor.util.getClosestBlockContainer(startContainer);
            }

            // Skip over empty blocks until we hit the block we want the selection to be in
            while (treeWalker.nextNode()) {
                if (!targetNode) {
                    // Loop through all blocks until we hit the starting block element
                    if (startBlock === treeWalker.currentNode) {
                        targetNode = treeWalker.currentNode;
                    }
                } else {
                    targetNode = treeWalker.currentNode;
                    currIndex++;
                    // We hit the target index, bail
                    if (currIndex === index) {
                        break;
                    }
                    // If we find a non-empty block, ignore the emptyBlocksIndex and just put selection here
                    if (targetNode.textContent.length > 0) {
                        break;
                    }
                }
            }

            if (!targetNode) {
                targetNode = startBlock;
            }

            // We're selecting a high-level block node, so make sure the cursor gets moved into the deepest
            // element at the beginning of the block
            range.setStart(MediumEditor.util.getFirstSelectableLeafNode(targetNode), 0);

            return range;
        },

        // Returns -1 unless the cursor is at the beginning of a paragraph/block
        // If the paragraph/block is preceeded by empty paragraphs/block (with no text)
        // it will return the number of empty paragraphs before the cursor.
        // Otherwise, it will return 0, which indicates the cursor is at the beginning
        // of a paragraph/block, and not at the end of the paragraph/block before it
        getIndexRelativeToAdjacentEmptyBlocks: function (doc, root, cursorContainer, cursorOffset) {
            // If there is text in front of the cursor, that means there isn't only empty blocks before it
            if (cursorContainer.textContent.length > 0 && cursorOffset > 0) {
                return -1;
            }

            // Check if the block that contains the cursor has any other text in front of the cursor
            var node = cursorContainer;
            if (node.nodeType !== 3) {
                node = cursorContainer.childNodes[cursorOffset];
            }
            if (node) {
                // The element isn't at the beginning of a block, so it has content before it
                if (!MediumEditor.util.isElementAtBeginningOfBlock(node)) {
                    return -1;
                }

                var previousSibling = MediumEditor.util.findPreviousSibling(node);
                // If there is no previous sibling, this is the first text element in the editor
                if (!previousSibling) {
                    return -1;
                }
                // If the previous sibling has text, then there are no empty blocks before this
                else if (previousSibling.nodeValue) {
                    return -1;
                }
            }

            // Walk over block elements, counting number of empty blocks between last piece of text
            // and the block the cursor is in
            var closestBlock = MediumEditor.util.getClosestBlockContainer(cursorContainer),
                treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false),
                emptyBlocksCount = 0;
            while (treeWalker.nextNode()) {
                var blockIsEmpty = treeWalker.currentNode.textContent === '';
                if (blockIsEmpty || emptyBlocksCount > 0) {
                    emptyBlocksCount += 1;
                }
                if (treeWalker.currentNode === closestBlock) {
                    return emptyBlocksCount;
                }
                if (!blockIsEmpty) {
                    emptyBlocksCount = 0;
                }
            }

            return emptyBlocksCount;
        },

        // Returns true if the selection range begins with an image tag
        // Returns false if the range starts with any non empty text nodes
        doesRangeStartWithImages: function (range, doc) {
            if (range.startOffset !== 0 || range.startContainer.nodeType !== 1) {
                return false;
            }

            if (range.startContainer.nodeName.toLowerCase() === 'img') {
                return true;
            }

            var img = range.startContainer.querySelector('img');
            if (!img) {
                return false;
            }

            var treeWalker = doc.createTreeWalker(range.startContainer, NodeFilter.SHOW_ALL, null, false);
            while (treeWalker.nextNode()) {
                var next = treeWalker.currentNode;
                // If we hit the image, then there isn't any text before the image so
                // the image is at the beginning of the range
                if (next === img) {
                    break;
                }
                // If we haven't hit the iamge, but found text that contains content
                // then the range doesn't start with an image
                if (next.nodeValue) {
                    return false;
                }
            }

            return true;
        },

        getTrailingImageCount: function (root, selectionState, endContainer, endOffset) {
            // If the endOffset of a range is 0, the endContainer doesn't contain images
            // If the endContainer is a text node, there are no trailing images
            if (endOffset === 0 || endContainer.nodeType !== 1) {
                return 0;
            }

            // If the endContainer isn't an image, and doesn't have an image descendants
            // there are no trailing images
            if (endContainer.nodeName.toLowerCase() !== 'img' && !endContainer.querySelector('img')) {
                return 0;
            }

            var lastNode = endContainer.childNodes[endOffset - 1];
            while (lastNode.hasChildNodes()) {
                lastNode = lastNode.lastChild;
            }

            var node = root,
                nodeStack = [],
                charIndex = 0,
                foundStart = false,
                foundEnd = false,
                stop = false,
                nextCharIndex,
                trailingImages = 0;

            while (!stop && node) {
                // Only iterate over elements and text nodes
                if (node.nodeType > 3) {
                    node = nodeStack.pop();
                    continue;
                }

                if (node.nodeType === 3 && !foundEnd) {
                    trailingImages = 0;
                    nextCharIndex = charIndex + node.length;
                    if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {
                        foundStart = true;
                    }
                    if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {
                        foundEnd = true;
                    }
                    charIndex = nextCharIndex;
                } else {
                    if (node.nodeName.toLowerCase() === 'img') {
                        trailingImages++;
                    }

                    if (node === lastNode) {
                        stop = true;
                    } else if (node.nodeType === 1) {
                        // this is an element
                        // add all its children to the stack
                        var i = node.childNodes.length - 1;
                        while (i >= 0) {
                            nodeStack.push(node.childNodes[i]);
                            i -= 1;
                        }
                    }
                }

                if (!stop) {
                    node = nodeStack.pop();
                }
            }

            return trailingImages;
        },

        // determine if the current selection contains any 'content'
        // content being any non-white space text or an image
        selectionContainsContent: function (doc) {
            var sel = doc.getSelection();

            // collapsed selection or selection withour range doesn't contain content
            if (!sel || sel.isCollapsed || !sel.rangeCount) {
                return false;
            }

            // if toString() contains any text, the selection contains some content
            if (sel.toString().trim() !== '') {
                return true;
            }

            // if selection contains only image(s), it will return empty for toString()
            // so check for an image manually
            var selectionNode = this.getSelectedParentElement(sel.getRangeAt(0));
            if (selectionNode) {
                if (selectionNode.nodeName.toLowerCase() === 'img' ||
                    (selectionNode.nodeType === 1 && selectionNode.querySelector('img'))) {
                    return true;
                }
            }

            return false;
        },

        selectionInContentEditableFalse: function (contentWindow) {
            // determine if the current selection is exclusively inside
            // a contenteditable="false", though treat the case of an
            // explicit contenteditable="true" inside a "false" as false.
            var sawtrue,
                sawfalse = this.findMatchingSelectionParent(function (el) {
                    var ce = el && el.getAttribute('contenteditable');
                    if (ce === 'true') {
                        sawtrue = true;
                    }
                    return el.nodeName !== '#text' && ce === 'false';
                }, contentWindow);

            return !sawtrue && sawfalse;
        },

        // http://stackoverflow.com/questions/4176923/html-of-selected-text
        // by Tim Down
        getSelectionHtml: function getSelectionHtml(doc) {
            var i,
                html = '',
                sel = doc.getSelection(),
                len,
                container;
            if (sel.rangeCount) {
                container = doc.createElement('div');
                for (i = 0, len = sel.rangeCount; i < len; i += 1) {
                    container.appendChild(sel.getRangeAt(i).cloneContents());
                }
                html = container.innerHTML;
            }
            return html;
        },

        /**
         *  Find the caret position within an element irrespective of any inline tags it may contain.
         *
         *  @param {DOMElement} An element containing the cursor to find offsets relative to.
         *  @param {Range} A Range representing cursor position. Will window.getSelection if none is passed.
         *  @return {Object} 'left' and 'right' attributes contain offsets from begining and end of Element
         */
        getCaretOffsets: function getCaretOffsets(element, range) {
            var preCaretRange, postCaretRange;

            if (!range) {
                range = window.getSelection().getRangeAt(0);
            }

            preCaretRange = range.cloneRange();
            postCaretRange = range.cloneRange();

            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);

            postCaretRange.selectNodeContents(element);
            postCaretRange.setStart(range.endContainer, range.endOffset);

            return {
                left: preCaretRange.toString().length,
                right: postCaretRange.toString().length
            };
        },

        // http://stackoverflow.com/questions/15867542/range-object-get-selection-parent-node-chrome-vs-firefox
        rangeSelectsSingleNode: function (range) {
            var startNode = range.startContainer;
            return startNode === range.endContainer &&
                startNode.hasChildNodes() &&
                range.endOffset === range.startOffset + 1;
        },

        getSelectedParentElement: function (range) {
            if (!range) {
                return null;
            }

            // Selection encompasses a single element
            if (this.rangeSelectsSingleNode(range) && range.startContainer.childNodes[range.startOffset].nodeType !== 3) {
                return range.startContainer.childNodes[range.startOffset];
            }

            // Selection range starts inside a text node, so get its parent
            if (range.startContainer.nodeType === 3) {
                return range.startContainer.parentNode;
            }

            // Selection starts inside an element
            return range.startContainer;
        },

        getSelectedElements: function (doc) {
            var selection = doc.getSelection(),
                range,
                toRet,
                currNode;

            if (!selection.rangeCount || selection.isCollapsed || !selection.getRangeAt(0).commonAncestorContainer) {
                return [];
            }

            range = selection.getRangeAt(0);

            if (range.commonAncestorContainer.nodeType === 3) {
                toRet = [];
                currNode = range.commonAncestorContainer;
                while (currNode.parentNode && currNode.parentNode.childNodes.length === 1) {
                    toRet.push(currNode.parentNode);
                    currNode = currNode.parentNode;
                }

                return toRet;
            }

            return [].filter.call(range.commonAncestorContainer.getElementsByTagName('*'), function (el) {
                return (typeof selection.containsNode === 'function') ? selection.containsNode(el, true) : true;
            });
        },

        selectNode: function (node, doc) {
            var range = doc.createRange(),
                sel = doc.getSelection();

            range.selectNodeContents(node);
            sel.removeAllRanges();
            sel.addRange(range);
        },

        select: function (doc, startNode, startOffset, endNode, endOffset) {
            doc.getSelection().removeAllRanges();
            var range = doc.createRange();
            range.setStart(startNode, startOffset);
            if (endNode) {
                range.setEnd(endNode, endOffset);
            } else {
                range.collapse(true);
            }
            doc.getSelection().addRange(range);
            return range;
        },

        /**
         *  Clear the current highlighted selection and set the caret to the start or the end of that prior selection, defaults to end.
         *
         *  @param {DomDocument} doc            Current document
         *  @param {boolean} moveCursorToStart  A boolean representing whether or not to set the caret to the beginning of the prior selection.
         */
        clearSelection: function (doc, moveCursorToStart) {
            if (moveCursorToStart) {
                doc.getSelection().collapseToStart();
            } else {
                doc.getSelection().collapseToEnd();
            }
        },

        /**
         * Move cursor to the given node with the given offset.
         *
         * @param  {DomDocument} doc     Current document
         * @param  {DomElement}  node    Element where to jump
         * @param  {integer}     offset  Where in the element should we jump, 0 by default
         */
        moveCursor: function (doc, node, offset) {
            this.select(doc, node, offset);
        },

        getSelectionRange: function (ownerDocument) {
            var selection = ownerDocument.getSelection();
            if (selection.rangeCount === 0) {
                return null;
            }
            return selection.getRangeAt(0);
        },

        // http://stackoverflow.com/questions/1197401/how-can-i-get-the-element-the-caret-is-in-with-javascript-when-using-contentedi
        // by You
        getSelectionStart: function (ownerDocument) {
            var node = ownerDocument.getSelection().anchorNode,
                startNode = (node && node.nodeType === 3 ? node.parentNode : node);

            return startNode;
        }
    };

    MediumEditor.selection = Selection;
}());

(function () {
    'use strict';

    var Events = function (instance) {
        this.base = instance;
        this.options = this.base.options;
        this.events = [];
        this.disabledEvents = {};
        this.customEvents = {};
        this.listeners = {};
    };

    Events.prototype = {
        InputEventOnContenteditableSupported: !MediumEditor.util.isIE && !MediumEditor.util.isEdge,

        // Helpers for event handling

        attachDOMEvent: function (target, event, listener, useCapture) {
            target.addEventListener(event, listener, useCapture);
            this.events.push([target, event, listener, useCapture]);
        },

        detachDOMEvent: function (target, event, listener, useCapture) {
            var index = this.indexOfListener(target, event, listener, useCapture),
                e;
            if (index !== -1) {
                e = this.events.splice(index, 1)[0];
                e[0].removeEventListener(e[1], e[2], e[3]);
            }
        },

        indexOfListener: function (target, event, listener, useCapture) {
            var i, n, item;
            for (i = 0, n = this.events.length; i < n; i = i + 1) {
                item = this.events[i];
                if (item[0] === target && item[1] === event && item[2] === listener && item[3] === useCapture) {
                    return i;
                }
            }
            return -1;
        },

        detachAllDOMEvents: function () {
            var e = this.events.pop();
            while (e) {
                e[0].removeEventListener(e[1], e[2], e[3]);
                e = this.events.pop();
            }
        },

        enableCustomEvent: function (event) {
            if (this.disabledEvents[event] !== undefined) {
                delete this.disabledEvents[event];
            }
        },

        disableCustomEvent: function (event) {
            this.disabledEvents[event] = true;
        },

        // custom events
        attachCustomEvent: function (event, listener) {
            this.setupListener(event);
            if (!this.customEvents[event]) {
                this.customEvents[event] = [];
            }
            this.customEvents[event].push(listener);
        },

        detachCustomEvent: function (event, listener) {
            var index = this.indexOfCustomListener(event, listener);
            if (index !== -1) {
                this.customEvents[event].splice(index, 1);
                // TODO: If array is empty, should detach internal listeners via destroyListener()
            }
        },

        indexOfCustomListener: function (event, listener) {
            if (!this.customEvents[event] || !this.customEvents[event].length) {
                return -1;
            }

            return this.customEvents[event].indexOf(listener);
        },

        detachAllCustomEvents: function () {
            this.customEvents = {};
            // TODO: Should detach internal listeners here via destroyListener()
        },

        triggerCustomEvent: function (name, data, editable) {
            if (this.customEvents[name] && !this.disabledEvents[name]) {
                this.customEvents[name].forEach(function (listener) {
                    listener(data, editable);
                });
            }
        },

        // Cleaning up

        destroy: function () {
            this.detachAllDOMEvents();
            this.detachAllCustomEvents();
            this.detachExecCommand();

            if (this.base.elements) {
                this.base.elements.forEach(function (element) {
                    element.removeAttribute('data-medium-focused');
                });
            }
        },

        // Listening to calls to document.execCommand

        // Attach a listener to be notified when document.execCommand is called
        attachToExecCommand: function () {
            if (this.execCommandListener) {
                return;
            }

            // Store an instance of the listener so:
            // 1) We only attach to execCommand once
            // 2) We can remove the listener later
            this.execCommandListener = function (execInfo) {
                this.handleDocumentExecCommand(execInfo);
            }.bind(this);

            // Ensure that execCommand has been wrapped correctly
            this.wrapExecCommand();

            // Add listener to list of execCommand listeners
            this.options.ownerDocument.execCommand.listeners.push(this.execCommandListener);
        },

        // Remove our listener for calls to document.execCommand
        detachExecCommand: function () {
            var doc = this.options.ownerDocument;
            if (!this.execCommandListener || !doc.execCommand.listeners) {
                return;
            }

            // Find the index of this listener in the array of listeners so it can be removed
            var index = doc.execCommand.listeners.indexOf(this.execCommandListener);
            if (index !== -1) {
                doc.execCommand.listeners.splice(index, 1);
            }

            // If the list of listeners is now empty, put execCommand back to its original state
            if (!doc.execCommand.listeners.length) {
                this.unwrapExecCommand();
            }
        },

        // Wrap document.execCommand in a custom method so we can listen to calls to it
        wrapExecCommand: function () {
            var doc = this.options.ownerDocument;

            // Ensure all instance of MediumEditor only wrap execCommand once
            if (doc.execCommand.listeners) {
                return;
            }

            // Helper method to call all listeners to execCommand
            var callListeners = function (args, result) {
                    if (doc.execCommand.listeners) {
                        doc.execCommand.listeners.forEach(function (listener) {
                            listener({
                                command: args[0],
                                value: args[2],
                                args: args,
                                result: result
                            });
                        });
                    }
                },

            // Create a wrapper method for execCommand which will:
            // 1) Call document.execCommand with the correct arguments
            // 2) Loop through any listeners and notify them that execCommand was called
            //    passing extra info on the call
            // 3) Return the result
                wrapper = function () {
                    var result = doc.execCommand.orig.apply(this, arguments);

                    if (!doc.execCommand.listeners) {
                        return result;
                    }

                    var args = Array.prototype.slice.call(arguments);
                    callListeners(args, result);

                    return result;
                };

            // Store a reference to the original execCommand
            wrapper.orig = doc.execCommand;

            // Attach an array for storing listeners
            wrapper.listeners = [];

            // Helper for notifying listeners
            wrapper.callListeners = callListeners;

            // Overwrite execCommand
            doc.execCommand = wrapper;
        },

        // Revert document.execCommand back to its original self
        unwrapExecCommand: function () {
            var doc = this.options.ownerDocument;
            if (!doc.execCommand.orig) {
                return;
            }

            // Use the reference to the original execCommand to revert back
            doc.execCommand = doc.execCommand.orig;
        },

        // Listening to browser events to emit events medium-editor cares about
        setupListener: function (name) {
            if (this.listeners[name]) {
                return;
            }

            switch (name) {
                case 'externalInteraction':
                    // Detecting when user has interacted with elements outside of MediumEditor
                    this.attachDOMEvent(this.options.ownerDocument.body, 'mousedown', this.handleBodyMousedown.bind(this), true);
                    this.attachDOMEvent(this.options.ownerDocument.body, 'click', this.handleBodyClick.bind(this), true);
                    this.attachDOMEvent(this.options.ownerDocument.body, 'focus', this.handleBodyFocus.bind(this), true);
                    break;
                case 'blur':
                    // Detecting when focus is lost
                    this.setupListener('externalInteraction');
                    break;
                case 'focus':
                    // Detecting when focus moves into some part of MediumEditor
                    this.setupListener('externalInteraction');
                    break;
                case 'editableInput':
                    // setup cache for knowing when the content has changed
                    this.contentCache = [];
                    this.base.elements.forEach(function (element) {
                        this.contentCache[element.getAttribute('medium-editor-index')] = element.innerHTML;

                        // Attach to the 'oninput' event, handled correctly by most browsers
                        if (this.InputEventOnContenteditableSupported) {
                            this.attachDOMEvent(element, 'input', this.handleInput.bind(this));
                        }
                    }.bind(this));

                    // For browsers which don't support the input event on contenteditable (IE)
                    // we'll attach to 'selectionchange' on the document and 'keypress' on the editables
                    if (!this.InputEventOnContenteditableSupported) {
                        this.setupListener('editableKeypress');
                        this.keypressUpdateInput = true;
                        this.attachDOMEvent(document, 'selectionchange', this.handleDocumentSelectionChange.bind(this));
                        // Listen to calls to execCommand
                        this.attachToExecCommand();
                    }
                    break;
                case 'editableClick':
                    // Detecting click in the contenteditables
                    this.attachToEachElement('click', this.handleClick);
                    break;
                case 'editableBlur':
                    // Detecting blur in the contenteditables
                    this.attachToEachElement('blur', this.handleBlur);
                    break;
                case 'editableKeypress':
                    // Detecting keypress in the contenteditables
                    this.attachToEachElement('keypress', this.handleKeypress);
                    break;
                case 'editableKeyup':
                    // Detecting keyup in the contenteditables
                    this.attachToEachElement('keyup', this.handleKeyup);
                    break;
                case 'editableKeydown':
                    // Detecting keydown on the contenteditables
                    this.attachToEachElement('keydown', this.handleKeydown);
                    break;
                case 'editableKeydownSpace':
                    // Detecting keydown for SPACE on the contenteditables
                    this.setupListener('editableKeydown');
                    break;
                case 'editableKeydownEnter':
                    // Detecting keydown for ENTER on the contenteditables
                    this.setupListener('editableKeydown');
                    break;
                case 'editableKeydownTab':
                    // Detecting keydown for TAB on the contenteditable
                    this.setupListener('editableKeydown');
                    break;
                case 'editableKeydownDelete':
                    // Detecting keydown for DELETE/BACKSPACE on the contenteditables
                    this.setupListener('editableKeydown');
                    break;
                case 'editableMouseover':
                    // Detecting mouseover on the contenteditables
                    this.attachToEachElement('mouseover', this.handleMouseover);
                    break;
                case 'editableDrag':
                    // Detecting dragover and dragleave on the contenteditables
                    this.attachToEachElement('dragover', this.handleDragging);
                    this.attachToEachElement('dragleave', this.handleDragging);
                    break;
                case 'editableDrop':
                    // Detecting drop on the contenteditables
                    this.attachToEachElement('drop', this.handleDrop);
                    break;
                case 'editablePaste':
                    // Detecting paste on the contenteditables
                    this.attachToEachElement('paste', this.handlePaste);
                    break;
            }
            this.listeners[name] = true;
        },

        attachToEachElement: function (name, handler) {
            this.base.elements.forEach(function (element) {
                this.attachDOMEvent(element, name, handler.bind(this));
            }, this);
        },

        focusElement: function (element) {
            element.focus();
            this.updateFocus(element, { target: element, type: 'focus' });
        },

        updateFocus: function (target, eventObj) {
            var toolbar = this.base.getExtensionByName('toolbar'),
                toolbarEl = toolbar ? toolbar.getToolbarElement() : null,
                anchorPreview = this.base.getExtensionByName('anchor-preview'),
                previewEl = (anchorPreview && anchorPreview.getPreviewElement) ? anchorPreview.getPreviewElement() : null,
                hadFocus = this.base.getFocusedElement(),
                toFocus;

            // For clicks, we need to know if the mousedown that caused the click happened inside the existing focused element.
            // If so, we don't want to focus another element
            if (hadFocus &&
                    eventObj.type === 'click' &&
                    this.lastMousedownTarget &&
                    (MediumEditor.util.isDescendant(hadFocus, this.lastMousedownTarget, true) ||
                     MediumEditor.util.isDescendant(toolbarEl, this.lastMousedownTarget, true) ||
                     MediumEditor.util.isDescendant(previewEl, this.lastMousedownTarget, true))) {
                toFocus = hadFocus;
            }

            if (!toFocus) {
                this.base.elements.some(function (element) {
                    // If the target is part of an editor element, this is the element getting focus
                    if (!toFocus && (MediumEditor.util.isDescendant(element, target, true))) {
                        toFocus = element;
                    }

                    // bail if we found an element that's getting focus
                    return !!toFocus;
                }, this);
            }

            // Check if the target is external (not part of the editor, toolbar, or anchorpreview)
            var externalEvent = !MediumEditor.util.isDescendant(hadFocus, target, true) &&
                                !MediumEditor.util.isDescendant(toolbarEl, target, true) &&
                                !MediumEditor.util.isDescendant(previewEl, target, true);

            if (toFocus !== hadFocus) {
                // If element has focus, and focus is going outside of editor
                // Don't blur focused element if clicking on editor, toolbar, or anchorpreview
                if (hadFocus && externalEvent) {
                    // Trigger blur on the editable that has lost focus
                    hadFocus.removeAttribute('data-medium-focused');
                    this.triggerCustomEvent('blur', eventObj, hadFocus);
                }

                // If focus is going into an editor element
                if (toFocus) {
                    // Trigger focus on the editable that now has focus
                    toFocus.setAttribute('data-medium-focused', true);
                    this.triggerCustomEvent('focus', eventObj, toFocus);
                }
            }

            if (externalEvent) {
                this.triggerCustomEvent('externalInteraction', eventObj);
            }
        },

        updateInput: function (target, eventObj) {
            if (!this.contentCache) {
                return;
            }
            // An event triggered which signifies that the user may have changed someting
            // Look in our cache of input for the contenteditables to see if something changed
            var index = target.getAttribute('medium-editor-index');
            if (target.innerHTML !== this.contentCache[index]) {
                // The content has changed since the last time we checked, fire the event
                this.triggerCustomEvent('editableInput', eventObj, target);
            }
            this.contentCache[index] = target.innerHTML;
        },

        handleDocumentSelectionChange: function (event) {
            // When selectionchange fires, target and current target are set
            // to document, since this is where the event is handled
            // However, currentTarget will have an 'activeElement' property
            // which will point to whatever element has focus.
            if (event.currentTarget && event.currentTarget.activeElement) {
                var activeElement = event.currentTarget.activeElement,
                    currentTarget;
                // We can look at the 'activeElement' to determine if the selectionchange has
                // happened within a contenteditable owned by this instance of MediumEditor
                this.base.elements.some(function (element) {
                    if (MediumEditor.util.isDescendant(element, activeElement, true)) {
                        currentTarget = element;
                        return true;
                    }
                    return false;
                }, this);

                // We know selectionchange fired within one of our contenteditables
                if (currentTarget) {
                    this.updateInput(currentTarget, { target: activeElement, currentTarget: currentTarget });
                }
            }
        },

        handleDocumentExecCommand: function () {
            // document.execCommand has been called
            // If one of our contenteditables currently has focus, we should
            // attempt to trigger the 'editableInput' event
            var target = this.base.getFocusedElement();
            if (target) {
                this.updateInput(target, { target: target, currentTarget: target });
            }
        },

        handleBodyClick: function (event) {
            this.updateFocus(event.target, event);
        },

        handleBodyFocus: function (event) {
            this.updateFocus(event.target, event);
        },

        handleBodyMousedown: function (event) {
            this.lastMousedownTarget = event.target;
        },

        handleInput: function (event) {
            this.updateInput(event.currentTarget, event);
        },

        handleClick: function (event) {
            this.triggerCustomEvent('editableClick', event, event.currentTarget);
        },

        handleBlur: function (event) {
            this.triggerCustomEvent('editableBlur', event, event.currentTarget);
        },

        handleKeypress: function (event) {
            this.triggerCustomEvent('editableKeypress', event, event.currentTarget);

            // If we're doing manual detection of the editableInput event we need
            // to check for input changes during 'keypress'
            if (this.keypressUpdateInput) {
                var eventObj = { target: event.target, currentTarget: event.currentTarget };

                // In IE, we need to let the rest of the event stack complete before we detect
                // changes to input, so using setTimeout here
                setTimeout(function () {
                    this.updateInput(eventObj.currentTarget, eventObj);
                }.bind(this), 0);
            }
        },

        handleKeyup: function (event) {
            this.triggerCustomEvent('editableKeyup', event, event.currentTarget);
        },

        handleMouseover: function (event) {
            this.triggerCustomEvent('editableMouseover', event, event.currentTarget);
        },

        handleDragging: function (event) {
            this.triggerCustomEvent('editableDrag', event, event.currentTarget);
        },

        handleDrop: function (event) {
            this.triggerCustomEvent('editableDrop', event, event.currentTarget);
        },

        handlePaste: function (event) {
            this.triggerCustomEvent('editablePaste', event, event.currentTarget);
        },

        handleKeydown: function (event) {

            this.triggerCustomEvent('editableKeydown', event, event.currentTarget);

            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.SPACE)) {
                return this.triggerCustomEvent('editableKeydownSpace', event, event.currentTarget);
            }

            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER) || (event.ctrlKey && MediumEditor.util.isKey(event, MediumEditor.util.keyCode.M))) {
                return this.triggerCustomEvent('editableKeydownEnter', event, event.currentTarget);
            }

            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.TAB)) {
                return this.triggerCustomEvent('editableKeydownTab', event, event.currentTarget);
            }

            if (MediumEditor.util.isKey(event, [MediumEditor.util.keyCode.DELETE, MediumEditor.util.keyCode.BACKSPACE])) {
                return this.triggerCustomEvent('editableKeydownDelete', event, event.currentTarget);
            }
        }
    };

    MediumEditor.Events = Events;
}());

(function () {
    'use strict';

    var Button = MediumEditor.Extension.extend({

        /* Button Options */

        /* action: [string]
         * The action argument to pass to MediumEditor.execAction()
         * when the button is clicked
         */
        action: undefined,

        /* aria: [string]
         * The value to add as the aria-label attribute of the button
         * element displayed in the toolbar.
         * This is also used as the tooltip for the button
         */
        aria: undefined,

        /* tagNames: [Array]
         * NOTE: This is not used if useQueryState is set to true.
         *
         * Array of element tag names that would indicate that this
         * button has already been applied. If this action has already
         * been applied, the button will be displayed as 'active' in the toolbar
         *
         * Example:
         * For 'bold', if the text is ever within a <b> or <strong>
         * tag that indicates the text is already bold. So the array
         * of tagNames for bold would be: ['b', 'strong']
         */
        tagNames: undefined,

        /* style: [Object]
         * NOTE: This is not used if useQueryState is set to true.
         *
         * A pair of css property & value(s) that indicate that this
         * button has already been applied. If this action has already
         * been applied, the button will be displayed as 'active' in the toolbar
         * Properties of the object:
         *   prop [String]: name of the css property
         *   value [String]: value(s) of the css property
         *                   multiple values can be separated by a '|'
         *
         * Example:
         * For 'bold', if the text is ever within an element with a 'font-weight'
         * style property set to '700' or 'bold', that indicates the text
         * is already bold.  So the style object for bold would be:
         * { prop: 'font-weight', value: '700|bold' }
         */
        style: undefined,

        /* useQueryState: [boolean]
         * Enables/disables whether this button should use the built-in
         * document.queryCommandState() method to determine whether
         * the action has already been applied.  If the action has already
         * been applied, the button will be displayed as 'active' in the toolbar
         *
         * Example:
         * For 'bold', if this is set to true, the code will call:
         * document.queryCommandState('bold') which will return true if the
         * browser thinks the text is already bold, and false otherwise
         */
        useQueryState: undefined,

        /* contentDefault: [string]
         * Default innerHTML to put inside the button
         */
        contentDefault: undefined,

        /* contentFA: [string]
         * The innerHTML to use for the content of the button
         * if the `buttonLabels` option for MediumEditor is set to 'fontawesome'
         */
        contentFA: undefined,

        /* classList: [Array]
         * An array of classNames (strings) to be added to the button
         */
        classList: undefined,

        /* attrs: [object]
         * A set of key-value pairs to add to the button as custom attributes
         */
        attrs: undefined,

        // The button constructor can optionally accept the name of a built-in button
        // (ie 'bold', 'italic', etc.)
        // When the name of a button is passed, it will initialize itself with the
        // configuration for that button
        constructor: function (options) {
            if (Button.isBuiltInButton(options)) {
                MediumEditor.Extension.call(this, this.defaults[options]);
            } else {
                MediumEditor.Extension.call(this, options);
            }
        },

        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            this.button = this.createButton();
            this.on(this.button, 'click', this.handleClick.bind(this));
        },

        /* getButton: [function ()]
         *
         * If implemented, this function will be called when
         * the toolbar is being created.  The DOM Element returned
         * by this function will be appended to the toolbar along
         * with any other buttons.
         */
        getButton: function () {
            return this.button;
        },

        getAction: function () {
            return (typeof this.action === 'function') ? this.action(this.base.options) : this.action;
        },

        getAria: function () {
            return (typeof this.aria === 'function') ? this.aria(this.base.options) : this.aria;
        },

        getTagNames: function () {
            return (typeof this.tagNames === 'function') ? this.tagNames(this.base.options) : this.tagNames;
        },

        createButton: function () {
            var button = this.document.createElement('button'),
                content = this.contentDefault,
                ariaLabel = this.getAria(),
                buttonLabels = this.getEditorOption('buttonLabels');
            // Add class names
            button.classList.add('medium-editor-action');
            button.classList.add('medium-editor-action-' + this.name);
            if (this.classList) {
                this.classList.forEach(function (className) {
                    button.classList.add(className);
                });
            }

            // Add attributes
            button.setAttribute('data-action', this.getAction());
            if (ariaLabel) {
                button.setAttribute('title', ariaLabel);
                button.setAttribute('aria-label', ariaLabel);
            }
            if (this.attrs) {
                Object.keys(this.attrs).forEach(function (attr) {
                    button.setAttribute(attr, this.attrs[attr]);
                }, this);
            }

            if (buttonLabels === 'fontawesome' && this.contentFA) {
                content = this.contentFA;
            }
            button.innerHTML = content;
            return button;
        },

        handleClick: function (event) {
            event.preventDefault();
            event.stopPropagation();

            var action = this.getAction();

            if (action) {
                this.execAction(action);
            }
        },

        isActive: function () {
            return this.button.classList.contains(this.getEditorOption('activeButtonClass'));
        },

        setInactive: function () {
            this.button.classList.remove(this.getEditorOption('activeButtonClass'));
            delete this.knownState;
        },

        setActive: function () {
            this.button.classList.add(this.getEditorOption('activeButtonClass'));
            delete this.knownState;
        },

        queryCommandState: function () {
            var queryState = null;
            if (this.useQueryState) {
                queryState = this.base.queryCommandState(this.getAction());
            }
            return queryState;
        },

        isAlreadyApplied: function (node) {
            var isMatch = false,
                tagNames = this.getTagNames(),
                styleVals,
                computedStyle;

            if (this.knownState === false || this.knownState === true) {
                return this.knownState;
            }

            if (tagNames && tagNames.length > 0) {
                isMatch = tagNames.indexOf(node.nodeName.toLowerCase()) !== -1;
            }

            if (!isMatch && this.style) {
                styleVals = this.style.value.split('|');
                computedStyle = this.window.getComputedStyle(node, null).getPropertyValue(this.style.prop);
                styleVals.forEach(function (val) {
                    if (!this.knownState) {
                        isMatch = (computedStyle.indexOf(val) !== -1);
                        // text-decoration is not inherited by default
                        // so if the computed style for text-decoration doesn't match
                        // don't write to knownState so we can fallback to other checks
                        if (isMatch || this.style.prop !== 'text-decoration') {
                            this.knownState = isMatch;
                        }
                    }
                }, this);
            }

            return isMatch;
        }
    });

    Button.isBuiltInButton = function (name) {
        return (typeof name === 'string') && MediumEditor.extensions.button.prototype.defaults.hasOwnProperty(name);
    };

    MediumEditor.extensions.button = Button;
}());

(function () {
    'use strict';

    /* MediumEditor.extensions.button.defaults: [Object]
     * Set of default config options for all of the built-in MediumEditor buttons
     */
    MediumEditor.extensions.button.prototype.defaults = {
        'bold': {
            name: 'bold',
            action: 'bold',
            aria: 'bold',
            tagNames: ['b', 'strong'],
            style: {
                prop: 'font-weight',
                value: '700|bold'
            },
            useQueryState: true,
            contentDefault: '<b>B</b>',
            contentFA: '<i class="fa fa-bold"></i>'
        },
        'italic': {
            name: 'italic',
            action: 'italic',
            aria: 'italic',
            tagNames: ['i', 'em'],
            style: {
                prop: 'font-style',
                value: 'italic'
            },
            useQueryState: true,
            contentDefault: '<b><i>I</i></b>',
            contentFA: '<i class="fa fa-italic"></i>'
        },
        'underline': {
            name: 'underline',
            action: 'underline',
            aria: 'underline',
            tagNames: ['u'],
            style: {
                prop: 'text-decoration',
                value: 'underline'
            },
            useQueryState: true,
            contentDefault: '<b><u>U</u></b>',
            contentFA: '<i class="fa fa-underline"></i>'
        },
        'strikethrough': {
            name: 'strikethrough',
            action: 'strikethrough',
            aria: 'strike through',
            tagNames: ['strike'],
            style: {
                prop: 'text-decoration',
                value: 'line-through'
            },
            useQueryState: true,
            contentDefault: '<s>A</s>',
            contentFA: '<i class="fa fa-strikethrough"></i>'
        },
        'superscript': {
            name: 'superscript',
            action: 'superscript',
            aria: 'superscript',
            tagNames: ['sup'],
            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for superscript
               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */
            // useQueryState: true
            contentDefault: '<b>x<sup>1</sup></b>',
            contentFA: '<i class="fa fa-superscript"></i>'
        },
        'subscript': {
            name: 'subscript',
            action: 'subscript',
            aria: 'subscript',
            tagNames: ['sub'],
            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for subscript
               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */
            // useQueryState: true
            contentDefault: '<b>x<sub>1</sub></b>',
            contentFA: '<i class="fa fa-subscript"></i>'
        },
        'image': {
            name: 'image',
            action: 'image',
            aria: 'image',
            tagNames: ['img'],
            contentDefault: '<b>image</b>',
            contentFA: '<i class="fa fa-picture-o"></i>'
        },
        'orderedlist': {
            name: 'orderedlist',
            action: 'insertorderedlist',
            aria: 'ordered list',
            tagNames: ['ol'],
            useQueryState: true,
            contentDefault: '<b>1.</b>',
            contentFA: '<i class="fa fa-list-ol"></i>'
        },
        'unorderedlist': {
            name: 'unorderedlist',
            action: 'insertunorderedlist',
            aria: 'unordered list',
            tagNames: ['ul'],
            useQueryState: true,
            contentDefault: '<b>&bull;</b>',
            contentFA: '<i class="fa fa-list-ul"></i>'
        },
        'indent': {
            name: 'indent',
            action: 'indent',
            aria: 'indent',
            tagNames: [],
            contentDefault: '<b>&rarr;</b>',
            contentFA: '<i class="fa fa-indent"></i>'
        },
        'outdent': {
            name: 'outdent',
            action: 'outdent',
            aria: 'outdent',
            tagNames: [],
            contentDefault: '<b>&larr;</b>',
            contentFA: '<i class="fa fa-outdent"></i>'
        },
        'justifyCenter': {
            name: 'justifyCenter',
            action: 'justifyCenter',
            aria: 'center justify',
            tagNames: [],
            style: {
                prop: 'text-align',
                value: 'center'
            },
            contentDefault: '<b>C</b>',
            contentFA: '<i class="fa fa-align-center"></i>'
        },
        'justifyFull': {
            name: 'justifyFull',
            action: 'justifyFull',
            aria: 'full justify',
            tagNames: [],
            style: {
                prop: 'text-align',
                value: 'justify'
            },
            contentDefault: '<b>J</b>',
            contentFA: '<i class="fa fa-align-justify"></i>'
        },
        'justifyLeft': {
            name: 'justifyLeft',
            action: 'justifyLeft',
            aria: 'left justify',
            tagNames: [],
            style: {
                prop: 'text-align',
                value: 'left'
            },
            contentDefault: '<b>L</b>',
            contentFA: '<i class="fa fa-align-left"></i>'
        },
        'justifyRight': {
            name: 'justifyRight',
            action: 'justifyRight',
            aria: 'right justify',
            tagNames: [],
            style: {
                prop: 'text-align',
                value: 'right'
            },
            contentDefault: '<b>R</b>',
            contentFA: '<i class="fa fa-align-right"></i>'
        },
        // Known inline elements that are not removed, or not removed consistantly across browsers:
        // <span>, <label>, <br>
        'removeFormat': {
            name: 'removeFormat',
            aria: 'remove formatting',
            action: 'removeFormat',
            contentDefault: '<b>X</b>',
            contentFA: '<i class="fa fa-eraser"></i>'
        },

        /***** Buttons for appending block elements (append-<element> action) *****/

        'quote': {
            name: 'quote',
            action: 'append-blockquote',
            aria: 'blockquote',
            tagNames: ['blockquote'],
            contentDefault: '<b>&ldquo;</b>',
            contentFA: '<i class="fa fa-quote-right"></i>'
        },
        'pre': {
            name: 'pre',
            action: 'append-pre',
            aria: 'preformatted text',
            tagNames: ['pre'],
            contentDefault: '<b>0101</b>',
            contentFA: '<i class="fa fa-code fa-lg"></i>'
        },
        'h1': {
            name: 'h1',
            action: 'append-h1',
            aria: 'header type one',
            tagNames: ['h1'],
            contentDefault: '<b>H1</b>',
            contentFA: '<i class="fa fa-header"><sup>1</sup>'
        },
        'h2': {
            name: 'h2',
            action: 'append-h2',
            aria: 'header type two',
            tagNames: ['h2'],
            contentDefault: '<b>H2</b>',
            contentFA: '<i class="fa fa-header"><sup>2</sup>'
        },
        'h3': {
            name: 'h3',
            action: 'append-h3',
            aria: 'header type three',
            tagNames: ['h3'],
            contentDefault: '<b>H3</b>',
            contentFA: '<i class="fa fa-header"><sup>3</sup>'
        },
        'h4': {
            name: 'h4',
            action: 'append-h4',
            aria: 'header type four',
            tagNames: ['h4'],
            contentDefault: '<b>H4</b>',
            contentFA: '<i class="fa fa-header"><sup>4</sup>'
        },
        'h5': {
            name: 'h5',
            action: 'append-h5',
            aria: 'header type five',
            tagNames: ['h5'],
            contentDefault: '<b>H5</b>',
            contentFA: '<i class="fa fa-header"><sup>5</sup>'
        },
        'h6': {
            name: 'h6',
            action: 'append-h6',
            aria: 'header type six',
            tagNames: ['h6'],
            contentDefault: '<b>H6</b>',
            contentFA: '<i class="fa fa-header"><sup>6</sup>'
        }
    };

})();
(function () {
    'use strict';

    /* Base functionality for an extension which will display
     * a 'form' inside the toolbar
     */
    var FormExtension = MediumEditor.extensions.button.extend({

        init: function () {
            MediumEditor.extensions.button.prototype.init.apply(this, arguments);
        },

        // default labels for the form buttons
        formSaveLabel: '&#10003;',
        formCloseLabel: '&times;',

        /* activeClass: [string]
         * set class which added to shown form
         */
        activeClass: 'medium-editor-toolbar-form-active',

        /* hasForm: [boolean]
         *
         * Setting this to true will cause getForm() to be called
         * when the toolbar is created, so the form can be appended
         * inside the toolbar container
         */
        hasForm: true,

        /* getForm: [function ()]
         *
         * When hasForm is true, this function must be implemented
         * and return a DOM Element which will be appended to
         * the toolbar container. The form should start hidden, and
         * the extension can choose when to hide/show it
         */
        getForm: function () {},

        /* isDisplayed: [function ()]
         *
         * This function should return true/false reflecting
         * whether the form is currently displayed
         */
        isDisplayed: function () {
            if (this.hasForm) {
                return this.getForm().classList.contains(this.activeClass);
            }
            return false;
        },

        /* hideForm: [function ()]
         *
         * This function should show the form element inside
         * the toolbar container
         */
        showForm: function () {
            if (this.hasForm) {
                this.getForm().classList.add(this.activeClass);
            }
        },

        /* hideForm: [function ()]
         *
         * This function should hide the form element inside
         * the toolbar container
         */
        hideForm: function () {
            if (this.hasForm) {
                this.getForm().classList.remove(this.activeClass);
            }
        },

        /************************ Helpers ************************
         * The following are helpers that are either set by MediumEditor
         * during initialization, or are helper methods which either
         * route calls to the MediumEditor instance or provide common
         * functionality for all form extensions
         *********************************************************/

        /* showToolbarDefaultActions: [function ()]
         *
         * Helper method which will turn back the toolbar after canceling
         * the customized form
         */
        showToolbarDefaultActions: function () {
            var toolbar = this.base.getExtensionByName('toolbar');
            if (toolbar) {
                toolbar.showToolbarDefaultActions();
            }
        },

        /* hideToolbarDefaultActions: [function ()]
         *
         * Helper function which will hide the default contents of the
         * toolbar, but leave the toolbar container in the same state
         * to allow a form to display its custom contents inside the toolbar
         */
        hideToolbarDefaultActions: function () {
            var toolbar = this.base.getExtensionByName('toolbar');
            if (toolbar) {
                toolbar.hideToolbarDefaultActions();
            }
        },

        /* setToolbarPosition: [function ()]
         *
         * Helper function which will update the size and position
         * of the toolbar based on the toolbar content and the current
         * position of the user's selection
         */
        setToolbarPosition: function () {
            var toolbar = this.base.getExtensionByName('toolbar');
            if (toolbar) {
                toolbar.setToolbarPosition();
            }
        }
    });

    MediumEditor.extensions.form = FormExtension;
})();
(function () {
    'use strict';

    var AnchorForm = MediumEditor.extensions.form.extend({
        /* Anchor Form Options */

        /* customClassOption: [string]  (previously options.anchorButton + options.anchorButtonClass)
         * Custom class name the user can optionally have added to their created links (ie 'button').
         * If passed as a non-empty string, a checkbox will be displayed allowing the user to choose
         * whether to have the class added to the created link or not.
         */
        customClassOption: null,

        /* customClassOptionText: [string]
         * text to be shown in the checkbox when the __customClassOption__ is being used.
         */
        customClassOptionText: 'Button',

        /* linkValidation: [boolean]  (previously options.checkLinkFormat)
         * enables/disables check for common URL protocols on anchor links.
         */
        linkValidation: false,

        /* placeholderText: [string]  (previously options.anchorInputPlaceholder)
         * text to be shown as placeholder of the anchor input.
         */
        placeholderText: 'Paste or type a link',

        /* targetCheckbox: [boolean]  (previously options.anchorTarget)
         * enables/disables displaying a "Open in new window" checkbox, which when checked
         * changes the `target` attribute of the created link.
         */
        targetCheckbox: false,

        /* targetCheckboxText: [string]  (previously options.anchorInputCheckboxLabel)
         * text to be shown in the checkbox enabled via the __targetCheckbox__ option.
         */
        targetCheckboxText: 'Open in new window',

        // Options for the Button base class
        name: 'anchor',
        action: 'createLink',
        aria: 'link',
        tagNames: ['a'],
        contentDefault: '<b>#</b>',
        contentFA: '<i class="fa fa-link"></i>',

        init: function () {
            MediumEditor.extensions.form.prototype.init.apply(this, arguments);

            this.subscribe('editableKeydown', this.handleKeydown.bind(this));
        },

        // Called when the button the toolbar is clicked
        // Overrides ButtonExtension.handleClick
        handleClick: function (event) {
            event.preventDefault();
            event.stopPropagation();

            var range = MediumEditor.selection.getSelectionRange(this.document);

            if (range.startContainer.nodeName.toLowerCase() === 'a' ||
                range.endContainer.nodeName.toLowerCase() === 'a' ||
                MediumEditor.util.getClosestTag(MediumEditor.selection.getSelectedParentElement(range), 'a')) {
                return this.execAction('unlink');
            }

            if (!this.isDisplayed()) {
                this.showForm();
            }

            return false;
        },

        // Called when user hits the defined shortcut (CTRL / COMMAND + K)
        handleKeydown: function (event) {
            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.K) && MediumEditor.util.isMetaCtrlKey(event) && !event.shiftKey) {
                this.handleClick(event);
            }
        },

        // Called by medium-editor to append form to the toolbar
        getForm: function () {
            if (!this.form) {
                this.form = this.createForm();
            }
            return this.form;
        },

        getTemplate: function () {
            var template = [
                '<input type="text" class="medium-editor-toolbar-input" placeholder="', this.placeholderText, '">'
            ];

            template.push(
                '<a href="#" class="medium-editor-toolbar-save">',
                this.getEditorOption('buttonLabels') === 'fontawesome' ? '<i class="fa fa-check"></i>' : this.formSaveLabel,
                '</a>'
            );

            template.push('<a href="#" class="medium-editor-toolbar-close">',
                this.getEditorOption('buttonLabels') === 'fontawesome' ? '<i class="fa fa-times"></i>' : this.formCloseLabel,
                '</a>');

            // both of these options are slightly moot with the ability to
            // override the various form buildup/serialize functions.

            if (this.targetCheckbox) {
                // fixme: ideally, this targetCheckboxText would be a formLabel too,
                // figure out how to deprecate? also consider `fa-` icon default implcations.
                template.push(
                    '<div class="medium-editor-toolbar-form-row">',
                    '<input type="checkbox" class="medium-editor-toolbar-anchor-target">',
                    '<label>',
                    this.targetCheckboxText,
                    '</label>',
                    '</div>'
                );
            }

            if (this.customClassOption) {
                // fixme: expose this `Button` text as a formLabel property, too
                // and provide similar access to a `fa-` icon default.
                template.push(
                    '<div class="medium-editor-toolbar-form-row">',
                    '<input type="checkbox" class="medium-editor-toolbar-anchor-button">',
                    '<label>',
                    this.customClassOptionText,
                    '</label>',
                    '</div>'
                );
            }

            return template.join('');

        },

        // Used by medium-editor when the default toolbar is to be displayed
        isDisplayed: function () {
            return MediumEditor.extensions.form.prototype.isDisplayed.apply(this);
        },

        hideForm: function () {
            MediumEditor.extensions.form.prototype.hideForm.apply(this);
            this.getInput().value = '';
        },

        showForm: function (opts) {
            var input = this.getInput(),
                targetCheckbox = this.getAnchorTargetCheckbox(),
                buttonCheckbox = this.getAnchorButtonCheckbox();

            opts = opts || { url: '' };
            // TODO: This is for backwards compatability
            // We don't need to support the 'string' argument in 6.0.0
            if (typeof opts === 'string') {
                opts = {
                    url: opts
                };
            }

            this.base.saveSelection();
            this.hideToolbarDefaultActions();
            MediumEditor.extensions.form.prototype.showForm.apply(this);
            this.setToolbarPosition();

            input.value = opts.url;
            input.focus();

            // If we have a target checkbox, we want it to be checked/unchecked
            // based on whether the existing link has target=_blank
            if (targetCheckbox) {
                targetCheckbox.checked = opts.target === '_blank';
            }

            // If we have a custom class checkbox, we want it to be checked/unchecked
            // based on whether an existing link already has the class
            if (buttonCheckbox) {
                var classList = opts.buttonClass ? opts.buttonClass.split(' ') : [];
                buttonCheckbox.checked = (classList.indexOf(this.customClassOption) !== -1);
            }
        },

        // Called by core when tearing down medium-editor (destroy)
        destroy: function () {
            if (!this.form) {
                return false;
            }

            if (this.form.parentNode) {
                this.form.parentNode.removeChild(this.form);
            }

            delete this.form;
        },

        // core methods

        getFormOpts: function () {
            // no notion of private functions? wanted `_getFormOpts`
            var targetCheckbox = this.getAnchorTargetCheckbox(),
                buttonCheckbox = this.getAnchorButtonCheckbox(),
                opts = {
                    url: this.getInput().value.trim()
                };

            if (this.linkValidation) {
                opts.url = this.checkLinkFormat(opts.url);
            }

            opts.target = '_self';
            if (targetCheckbox && targetCheckbox.checked) {
                opts.target = '_blank';
            }

            if (buttonCheckbox && buttonCheckbox.checked) {
                opts.buttonClass = this.customClassOption;
            }

            return opts;
        },

        doFormSave: function () {
            var opts = this.getFormOpts();
            this.completeFormSave(opts);
        },

        completeFormSave: function (opts) {
            this.base.restoreSelection();
            this.execAction(this.action, opts);
            this.base.checkSelection();
        },

        checkLinkFormat: function (value) {
            // Matches any alphabetical characters followed by ://
            // Matches protocol relative "//"
            // Matches common external protocols "mailto:" "tel:" "maps:"
            var urlSchemeRegex = /^([a-z]+:)?\/\/|^(mailto|tel|maps):/i,
            // var te is a regex for checking if the string is a telephone number
            telRegex = /^\+?\s?\(?(?:\d\s?\-?\)?){3,20}$/;
            if (telRegex.test(value)) {
                return 'tel:' + value;
            } else {
                // Check for URL scheme and default to http:// if none found
                return (urlSchemeRegex.test(value) ? '' : 'http://') + value;
            }
        },

        doFormCancel: function () {
            this.base.restoreSelection();
            this.base.checkSelection();
        },

        // form creation and event handling
        attachFormEvents: function (form) {
            var close = form.querySelector('.medium-editor-toolbar-close'),
                save = form.querySelector('.medium-editor-toolbar-save'),
                input = form.querySelector('.medium-editor-toolbar-input');

            // Handle clicks on the form itself
            this.on(form, 'click', this.handleFormClick.bind(this));

            // Handle typing in the textbox
            this.on(input, 'keyup', this.handleTextboxKeyup.bind(this));

            // Handle close button clicks
            this.on(close, 'click', this.handleCloseClick.bind(this));

            // Handle save button clicks (capture)
            this.on(save, 'click', this.handleSaveClick.bind(this), true);

        },

        createForm: function () {
            var doc = this.document,
                form = doc.createElement('div');

            // Anchor Form (div)
            form.className = 'medium-editor-toolbar-form';
            form.id = 'medium-editor-toolbar-form-anchor-' + this.getEditorId();
            form.innerHTML = this.getTemplate();
            this.attachFormEvents(form);

            return form;
        },

        getInput: function () {
            return this.getForm().querySelector('input.medium-editor-toolbar-input');
        },

        getAnchorTargetCheckbox: function () {
            return this.getForm().querySelector('.medium-editor-toolbar-anchor-target');
        },

        getAnchorButtonCheckbox: function () {
            return this.getForm().querySelector('.medium-editor-toolbar-anchor-button');
        },

        handleTextboxKeyup: function (event) {
            // For ENTER -> create the anchor
            if (event.keyCode === MediumEditor.util.keyCode.ENTER) {
                event.preventDefault();
                this.doFormSave();
                return;
            }

            // For ESCAPE -> close the form
            if (event.keyCode === MediumEditor.util.keyCode.ESCAPE) {
                event.preventDefault();
                this.doFormCancel();
            }
        },

        handleFormClick: function (event) {
            // make sure not to hide form when clicking inside the form
            event.stopPropagation();
        },

        handleSaveClick: function (event) {
            // Clicking Save -> create the anchor
            event.preventDefault();
            this.doFormSave();
        },

        handleCloseClick: function (event) {
            // Click Close -> close the form
            event.preventDefault();
            this.doFormCancel();
        }
    });

    MediumEditor.extensions.anchor = AnchorForm;
}());

(function () {
    'use strict';

    var AnchorPreview = MediumEditor.Extension.extend({
        name: 'anchor-preview',

        // Anchor Preview Options

        /* hideDelay: [number]  (previously options.anchorPreviewHideDelay)
         * time in milliseconds to show the anchor tag preview after the mouse has left the anchor tag.
         */
        hideDelay: 500,

        /* previewValueSelector: [string]
         * the default selector to locate where to put the activeAnchor value in the preview
         */
        previewValueSelector: 'a',

        /* showWhenToolbarIsVisible: [boolean]
         * determines whether the anchor tag preview shows up when the toolbar is visible
         */
        showWhenToolbarIsVisible: false,

        init: function () {
            this.anchorPreview = this.createPreview();

            this.getEditorOption('elementsContainer').appendChild(this.anchorPreview);

            this.attachToEditables();
        },

        getPreviewElement: function () {
            return this.anchorPreview;
        },

        createPreview: function () {
            var el = this.document.createElement('div');

            el.id = 'medium-editor-anchor-preview-' + this.getEditorId();
            el.className = 'medium-editor-anchor-preview';
            el.innerHTML = this.getTemplate();

            this.on(el, 'click', this.handleClick.bind(this));

            return el;
        },

        getTemplate: function () {
            return '<div class="medium-editor-toolbar-anchor-preview" id="medium-editor-toolbar-anchor-preview">' +
                '    <a class="medium-editor-toolbar-anchor-preview-inner"></a>' +
                '</div>';
        },

        destroy: function () {
            if (this.anchorPreview) {
                if (this.anchorPreview.parentNode) {
                    this.anchorPreview.parentNode.removeChild(this.anchorPreview);
                }
                delete this.anchorPreview;
            }
        },

        hidePreview: function () {
            this.anchorPreview.classList.remove('medium-editor-anchor-preview-active');
            this.activeAnchor = null;
        },

        showPreview: function (anchorEl) {
            if (this.anchorPreview.classList.contains('medium-editor-anchor-preview-active') ||
                    anchorEl.getAttribute('data-disable-preview')) {
                return true;
            }

            if (this.previewValueSelector) {
                this.anchorPreview.querySelector(this.previewValueSelector).textContent = anchorEl.attributes.href.value;
                this.anchorPreview.querySelector(this.previewValueSelector).href = anchorEl.attributes.href.value;
            }

            this.anchorPreview.classList.add('medium-toolbar-arrow-over');
            this.anchorPreview.classList.remove('medium-toolbar-arrow-under');

            if (!this.anchorPreview.classList.contains('medium-editor-anchor-preview-active')) {
                this.anchorPreview.classList.add('medium-editor-anchor-preview-active');
            }

            this.activeAnchor = anchorEl;

            this.positionPreview();
            this.attachPreviewHandlers();

            return this;
        },

        positionPreview: function (activeAnchor) {
            activeAnchor = activeAnchor || this.activeAnchor;
            var buttonHeight = this.anchorPreview.offsetHeight,
                boundary = activeAnchor.getBoundingClientRect(),
                middleBoundary = (boundary.left + boundary.right) / 2,
                diffLeft = this.diffLeft,
                diffTop = this.diffTop,
                halfOffsetWidth,
                defaultLeft;

            halfOffsetWidth = this.anchorPreview.offsetWidth / 2;
            var toolbarExtension = this.base.getExtensionByName('toolbar');
            if (toolbarExtension) {
                diffLeft = toolbarExtension.diffLeft;
                diffTop = toolbarExtension.diffTop;
            }
            defaultLeft = diffLeft - halfOffsetWidth;

            this.anchorPreview.style.top = Math.round(buttonHeight + boundary.bottom - diffTop + this.window.pageYOffset - this.anchorPreview.offsetHeight) + 'px';
            this.anchorPreview.style.right = 'initial';
            if (middleBoundary < halfOffsetWidth) {
                this.anchorPreview.style.left = defaultLeft + halfOffsetWidth + 'px';
                this.anchorPreview.style.right = 'initial';
            } else if ((this.window.innerWidth - middleBoundary) < halfOffsetWidth) {
                this.anchorPreview.style.left = 'auto';
                this.anchorPreview.style.right = 0;
            } else {
                this.anchorPreview.style.left = defaultLeft + middleBoundary + 'px';
                this.anchorPreview.style.right = 'initial';
            }
        },

        attachToEditables: function () {
            this.subscribe('editableMouseover', this.handleEditableMouseover.bind(this));
        },

        handleClick: function (event) {
            var anchorExtension = this.base.getExtensionByName('anchor'),
                activeAnchor = this.activeAnchor;

            if (anchorExtension && activeAnchor) {
                event.preventDefault();

                this.base.selectElement(this.activeAnchor);

                // Using setTimeout + delay because:
                // We may actually be displaying the anchor form, which should be controlled by delay
                this.base.delay(function () {
                    if (activeAnchor) {
                        var opts = {
                            url: activeAnchor.attributes.href.value,
                            target: activeAnchor.getAttribute('target'),
                            buttonClass: activeAnchor.getAttribute('class')
                        };
                        anchorExtension.showForm(opts);
                        activeAnchor = null;
                    }
                }.bind(this));
            }

            this.hidePreview();
        },

        handleAnchorMouseout: function () {
            this.anchorToPreview = null;
            this.off(this.activeAnchor, 'mouseout', this.instanceHandleAnchorMouseout);
            this.instanceHandleAnchorMouseout = null;
        },

        handleEditableMouseover: function (event) {
            var target = MediumEditor.util.getClosestTag(event.target, 'a');

            if (false === target) {
                return;
            }

            // Detect empty href attributes
            // The browser will make href="" or href="#top"
            // into absolute urls when accessed as event.target.href, so check the html
            if (!/href=["']\S+["']/.test(target.outerHTML) || /href=["']#\S+["']/.test(target.outerHTML)) {
                return true;
            }

            // only show when toolbar is not present
            var toolbar = this.base.getExtensionByName('toolbar');
            if (!this.showWhenToolbarIsVisible && toolbar && toolbar.isDisplayed && toolbar.isDisplayed()) {
                return true;
            }

            // detach handler for other anchor in case we hovered multiple anchors quickly
            if (this.activeAnchor && this.activeAnchor !== target) {
                this.detachPreviewHandlers();
            }

            this.anchorToPreview = target;

            this.instanceHandleAnchorMouseout = this.handleAnchorMouseout.bind(this);
            this.on(this.anchorToPreview, 'mouseout', this.instanceHandleAnchorMouseout);
            // Using setTimeout + delay because:
            // - We're going to show the anchor preview according to the configured delay
            //   if the mouse has not left the anchor tag in that time
            this.base.delay(function () {
                if (this.anchorToPreview) {
                    this.showPreview(this.anchorToPreview);
                }
            }.bind(this));
        },

        handlePreviewMouseover: function () {
            this.lastOver = (new Date()).getTime();
            this.hovering = true;
        },

        handlePreviewMouseout: function (event) {
            if (!event.relatedTarget || !/anchor-preview/.test(event.relatedTarget.className)) {
                this.hovering = false;
            }
        },

        updatePreview: function () {
            if (this.hovering) {
                return true;
            }
            var durr = (new Date()).getTime() - this.lastOver;
            if (durr > this.hideDelay) {
                // hide the preview 1/2 second after mouse leaves the link
                this.detachPreviewHandlers();
            }
        },

        detachPreviewHandlers: function () {
            // cleanup
            clearInterval(this.intervalTimer);
            if (this.instanceHandlePreviewMouseover) {
                this.off(this.anchorPreview, 'mouseover', this.instanceHandlePreviewMouseover);
                this.off(this.anchorPreview, 'mouseout', this.instanceHandlePreviewMouseout);
                if (this.activeAnchor) {
                    this.off(this.activeAnchor, 'mouseover', this.instanceHandlePreviewMouseover);
                    this.off(this.activeAnchor, 'mouseout', this.instanceHandlePreviewMouseout);
                }
            }

            this.hidePreview();

            this.hovering = this.instanceHandlePreviewMouseover = this.instanceHandlePreviewMouseout = null;
        },

        // TODO: break up method and extract out handlers
        attachPreviewHandlers: function () {
            this.lastOver = (new Date()).getTime();
            this.hovering = true;

            this.instanceHandlePreviewMouseover = this.handlePreviewMouseover.bind(this);
            this.instanceHandlePreviewMouseout = this.handlePreviewMouseout.bind(this);

            this.intervalTimer = setInterval(this.updatePreview.bind(this), 200);

            this.on(this.anchorPreview, 'mouseover', this.instanceHandlePreviewMouseover);
            this.on(this.anchorPreview, 'mouseout', this.instanceHandlePreviewMouseout);
            this.on(this.activeAnchor, 'mouseover', this.instanceHandlePreviewMouseover);
            this.on(this.activeAnchor, 'mouseout', this.instanceHandlePreviewMouseout);
        }
    });

    MediumEditor.extensions.anchorPreview = AnchorPreview;
}());

(function () {
    'use strict';

    var WHITESPACE_CHARS,
        KNOWN_TLDS_FRAGMENT,
        LINK_REGEXP_TEXT,
        KNOWN_TLDS_REGEXP;

    WHITESPACE_CHARS = [' ', '\t', '\n', '\r', '\u00A0', '\u2000', '\u2001', '\u2002', '\u2003',
                                    '\u2028', '\u2029'];
    KNOWN_TLDS_FRAGMENT = 'com|net|org|edu|gov|mil|aero|asia|biz|cat|coop|info|int|jobs|mobi|museum|name|post|pro|tel|travel|' +
        'xxx|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|' +
        'bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|' +
        'fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|' +
        'is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|' +
        'mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|' +
        'pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|ja|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|' +
        'tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw';

    LINK_REGEXP_TEXT =
        '(' +
        // Version of Gruber URL Regexp optimized for JS: http://stackoverflow.com/a/17733640
        '((?:(https?://|ftps?://|nntp://)|www\\d{0,3}[.]|[a-z0-9.\\-]+[.](' + KNOWN_TLDS_FRAGMENT + ')\\\/)\\S+(?:[^\\s`!\\[\\]{};:\'\".,?\u00AB\u00BB\u201C\u201D\u2018\u2019]))' +
        // Addition to above Regexp to support bare domains/one level subdomains with common non-i18n TLDs and without www prefix:
        ')|(([a-z0-9\\-]+\\.)?[a-z0-9\\-]+\\.(' + KNOWN_TLDS_FRAGMENT + '))';

    KNOWN_TLDS_REGEXP = new RegExp('^(' + KNOWN_TLDS_FRAGMENT + ')$', 'i');

    function nodeIsNotInsideAnchorTag(node) {
        return !MediumEditor.util.getClosestTag(node, 'a');
    }

    var AutoLink = MediumEditor.Extension.extend({
        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            this.disableEventHandling = false;
            this.subscribe('editableKeypress', this.onKeypress.bind(this));
            this.subscribe('editableBlur', this.onBlur.bind(this));
            // MS IE has it's own auto-URL detect feature but ours is better in some ways. Be consistent.
            this.document.execCommand('AutoUrlDetect', false, false);
        },

        isLastInstance: function () {
            var activeInstances = 0;
            for (var i = 0; i < this.window._mediumEditors.length; i++) {
                var editor = this.window._mediumEditors[i];
                if (editor !== null && editor.getExtensionByName('autoLink') !== undefined) {
                    activeInstances++;
                }
            }
            return activeInstances === 1;
        },

        destroy: function () {
            // Turn AutoUrlDetect back on
            if (this.document.queryCommandSupported('AutoUrlDetect') && this.isLastInstance()) {
                this.document.execCommand('AutoUrlDetect', false, true);
            }
        },

        onBlur: function (blurEvent, editable) {
            this.performLinking(editable);
        },

        onKeypress: function (keyPressEvent) {
            if (this.disableEventHandling) {
                return;
            }

            if (MediumEditor.util.isKey(keyPressEvent, [MediumEditor.util.keyCode.SPACE, MediumEditor.util.keyCode.ENTER])) {
                clearTimeout(this.performLinkingTimeout);
                // Saving/restoring the selection in the middle of a keypress doesn't work well...
                this.performLinkingTimeout = setTimeout(function () {
                    try {
                        var sel = this.base.exportSelection();
                        if (this.performLinking(keyPressEvent.target)) {
                            // pass true for favorLaterSelectionAnchor - this is needed for links at the end of a
                            // paragraph in MS IE, or MS IE causes the link to be deleted right after adding it.
                            this.base.importSelection(sel, true);
                        }
                    } catch (e) {
                        if (window.console) {
                            window.console.error('Failed to perform linking', e);
                        }
                        this.disableEventHandling = true;
                    }
                }.bind(this), 0);
            }
        },

        performLinking: function (contenteditable) {
            /*
            Perform linking on blockElement basis, blockElements are HTML elements with text content and without
            child element.

            Example:
            - HTML content
            <blockquote>
              <p>link.</p>
              <p>my</p>
            </blockquote>

            - blockElements
            [<p>link.</p>, <p>my</p>]

            otherwise the detection can wrongly find the end of one paragraph and the beginning of another paragraph
            to constitute a link, such as a paragraph ending "link." and the next paragraph beginning with "my" is
            interpreted into "link.my" and the code tries to create a link across blockElements - which doesn't work
            and is terrible.
            (Medium deletes the spaces/returns between P tags so the textContent ends up without paragraph spacing)
            */
            var blockElements = MediumEditor.util.splitByBlockElements(contenteditable),
                documentModified = false;
            if (blockElements.length === 0) {
                blockElements = [contenteditable];
            }
            for (var i = 0; i < blockElements.length; i++) {
                documentModified = this.removeObsoleteAutoLinkSpans(blockElements[i]) || documentModified;
                documentModified = this.performLinkingWithinElement(blockElements[i]) || documentModified;
            }
            this.base.events.updateInput(contenteditable, { target: contenteditable, currentTarget: contenteditable });
            return documentModified;
        },

        removeObsoleteAutoLinkSpans: function (element) {
            if (!element || element.nodeType === 3) {
                return false;
            }

            var spans = element.querySelectorAll('span[data-auto-link="true"]'),
                documentModified = false;

            for (var i = 0; i < spans.length; i++) {
                var textContent = spans[i].textContent;
                if (textContent.indexOf('://') === -1) {
                    textContent = MediumEditor.util.ensureUrlHasProtocol(textContent);
                }
                if (spans[i].getAttribute('data-href') !== textContent && nodeIsNotInsideAnchorTag(spans[i])) {
                    documentModified = true;
                    var trimmedTextContent = textContent.replace(/\s+$/, '');
                    if (spans[i].getAttribute('data-href') === trimmedTextContent) {
                        var charactersTrimmed = textContent.length - trimmedTextContent.length,
                            subtree = MediumEditor.util.splitOffDOMTree(spans[i], this.splitTextBeforeEnd(spans[i], charactersTrimmed));
                        spans[i].parentNode.insertBefore(subtree, spans[i].nextSibling);
                    } else {
                        // Some editing has happened to the span, so just remove it entirely. The user can put it back
                        // around just the href content if they need to prevent it from linking
                        MediumEditor.util.unwrap(spans[i], this.document);
                    }
                }
            }
            return documentModified;
        },

        splitTextBeforeEnd: function (element, characterCount) {
            var treeWalker = this.document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false),
                lastChildNotExhausted = true;

            // Start the tree walker at the last descendant of the span
            while (lastChildNotExhausted) {
                lastChildNotExhausted = treeWalker.lastChild() !== null;
            }

            var currentNode,
                currentNodeValue,
                previousNode;
            while (characterCount > 0 && previousNode !== null) {
                currentNode = treeWalker.currentNode;
                currentNodeValue = currentNode.nodeValue;
                if (currentNodeValue.length > characterCount) {
                    previousNode = currentNode.splitText(currentNodeValue.length - characterCount);
                    characterCount = 0;
                } else {
                    previousNode = treeWalker.previousNode();
                    characterCount -= currentNodeValue.length;
                }
            }
            return previousNode;
        },

        performLinkingWithinElement: function (element) {
            var matches = this.findLinkableText(element),
                linkCreated = false;

            for (var matchIndex = 0; matchIndex < matches.length; matchIndex++) {
                var matchingTextNodes = MediumEditor.util.findOrCreateMatchingTextNodes(this.document, element,
                        matches[matchIndex]);
                if (this.shouldNotLink(matchingTextNodes)) {
                    continue;
                }
                this.createAutoLink(matchingTextNodes, matches[matchIndex].href);
            }
            return linkCreated;
        },

        shouldNotLink: function (textNodes) {
            var shouldNotLink = false;
            for (var i = 0; i < textNodes.length && shouldNotLink === false; i++) {
                // Do not link if the text node is either inside an anchor or inside span[data-auto-link]
                shouldNotLink = !!MediumEditor.util.traverseUp(textNodes[i], function (node) {
                    return node.nodeName.toLowerCase() === 'a' ||
                        (node.getAttribute && node.getAttribute('data-auto-link') === 'true');
                });
            }
            return shouldNotLink;
        },

        findLinkableText: function (contenteditable) {
            var linkRegExp = new RegExp(LINK_REGEXP_TEXT, 'gi'),
                textContent = contenteditable.textContent,
                match = null,
                matches = [];

            while ((match = linkRegExp.exec(textContent)) !== null) {
                var matchOk = true,
                    matchEnd = match.index + match[0].length;
                // If the regexp detected something as a link that has text immediately preceding/following it, bail out.
                matchOk = (match.index === 0 || WHITESPACE_CHARS.indexOf(textContent[match.index - 1]) !== -1) &&
                    (matchEnd === textContent.length || WHITESPACE_CHARS.indexOf(textContent[matchEnd]) !== -1);
                // If the regexp detected a bare domain that doesn't use one of our expected TLDs, bail out.
                matchOk = matchOk && (match[0].indexOf('/') !== -1 ||
                    KNOWN_TLDS_REGEXP.test(match[0].split('.').pop().split('?').shift()));

                if (matchOk) {
                    matches.push({
                        href: match[0],
                        start: match.index,
                        end: matchEnd
                    });
                }
            }
            return matches;
        },

        createAutoLink: function (textNodes, href) {
            href = MediumEditor.util.ensureUrlHasProtocol(href);
            var anchor = MediumEditor.util.createLink(this.document, textNodes, href, this.getEditorOption('targetBlank') ? '_blank' : null),
                span = this.document.createElement('span');
            span.setAttribute('data-auto-link', 'true');
            span.setAttribute('data-href', href);
            anchor.insertBefore(span, anchor.firstChild);
            while (anchor.childNodes.length > 1) {
                span.appendChild(anchor.childNodes[1]);
            }
        }

    });

    MediumEditor.extensions.autoLink = AutoLink;
}());

(function () {
    'use strict';

    var CLASS_DRAG_OVER = 'medium-editor-dragover';

    function clearClassNames(element) {
        var editable = MediumEditor.util.getContainerEditorElement(element),
            existing = Array.prototype.slice.call(editable.parentElement.querySelectorAll('.' + CLASS_DRAG_OVER));

        existing.forEach(function (el) {
            el.classList.remove(CLASS_DRAG_OVER);
        });
    }

    var FileDragging = MediumEditor.Extension.extend({
        name: 'fileDragging',

        allowedTypes: ['image'],

        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            this.subscribe('editableDrag', this.handleDrag.bind(this));
            this.subscribe('editableDrop', this.handleDrop.bind(this));
        },

        handleDrag: function (event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';

            var target = event.target.classList ? event.target : event.target.parentElement;

            // Ensure the class gets removed from anything that had it before
            clearClassNames(target);

            if (event.type === 'dragover') {
                target.classList.add(CLASS_DRAG_OVER);
            }
        },

        handleDrop: function (event) {
            // Prevent file from opening in the current window
            event.preventDefault();
            event.stopPropagation();
            // Select the dropping target, and set the selection to the end of the target
            // https://github.com/yabwe/medium-editor/issues/980
            this.base.selectElement(event.target);
            var selection = this.base.exportSelection();
            selection.start = selection.end;
            this.base.importSelection(selection);
            // IE9 does not support the File API, so prevent file from opening in the window
            // but also don't try to actually get the file
            if (event.dataTransfer.files) {
                Array.prototype.slice.call(event.dataTransfer.files).forEach(function (file) {
                    if (this.isAllowedFile(file)) {
                        if (file.type.match('image')) {
                            this.insertImageFile(file);
                        }
                    }
                }, this);
            }

            // Make sure we remove our class from everything
            clearClassNames(event.target);
        },

        isAllowedFile: function (file) {
            return this.allowedTypes.some(function (fileType) {
                return !!file.type.match(fileType);
            });
        },

        insertImageFile: function (file) {
            if (typeof FileReader !== 'function') {
                return;
            }
            var fileReader = new FileReader();
            fileReader.readAsDataURL(file);

            // attach the onload event handler, makes it easier to listen in with jasmine
            fileReader.addEventListener('load', function (e) {
                var addImageElement = this.document.createElement('img');
                addImageElement.src = e.target.result;
                MediumEditor.util.insertHTMLCommand(this.document, addImageElement.outerHTML);
            }.bind(this));
        }
    });

    MediumEditor.extensions.fileDragging = FileDragging;
}());

(function () {
    'use strict';

    var KeyboardCommands = MediumEditor.Extension.extend({
        name: 'keyboard-commands',

        /* KeyboardCommands Options */

        /* commands: [Array]
         * Array of objects describing each command and the combination of keys that will trigger it
         * Required for each object:
         *   command [String] (argument passed to editor.execAction())
         *   key [String] (keyboard character that triggers this command)
         *   meta [boolean] (whether the ctrl/meta key has to be active or inactive)
         *   shift [boolean] (whether the shift key has to be active or inactive)
         *   alt [boolean] (whether the alt key has to be active or inactive)
         */
        commands: [
            {
                command: 'bold',
                key: 'B',
                meta: true,
                shift: false,
                alt: false
            },
            {
                command: 'italic',
                key: 'I',
                meta: true,
                shift: false,
                alt: false
            },
            {
                command: 'underline',
                key: 'U',
                meta: true,
                shift: false,
                alt: false
            }
        ],

        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            this.subscribe('editableKeydown', this.handleKeydown.bind(this));
            this.keys = {};
            this.commands.forEach(function (command) {
                var keyCode = command.key.charCodeAt(0);
                if (!this.keys[keyCode]) {
                    this.keys[keyCode] = [];
                }
                this.keys[keyCode].push(command);
            }, this);
        },

        handleKeydown: function (event) {
            var keyCode = MediumEditor.util.getKeyCode(event);
            if (!this.keys[keyCode]) {
                return;
            }

            var isMeta = MediumEditor.util.isMetaCtrlKey(event),
                isShift = !!event.shiftKey,
                isAlt = !!event.altKey;

            this.keys[keyCode].forEach(function (data) {
                if (data.meta === isMeta &&
                    data.shift === isShift &&
                    (data.alt === isAlt ||
                     undefined === data.alt)) { // TODO deprecated: remove check for undefined === data.alt when jumping to 6.0.0
                    event.preventDefault();
                    event.stopPropagation();

                    // command can be false so the shortcut is just disabled
                    if (false !== data.command) {
                        this.execAction(data.command);
                    }
                }
            }, this);
        }
    });

    MediumEditor.extensions.keyboardCommands = KeyboardCommands;
}());

(function () {
    'use strict';

    var FontNameForm = MediumEditor.extensions.form.extend({

        name: 'fontname',
        action: 'fontName',
        aria: 'change font name',
        contentDefault: '&#xB1;', // 
        contentFA: '<i class="fa fa-font"></i>',

        fonts: ['', 'Arial', 'Verdana', 'Times New Roman'],

        init: function () {
            MediumEditor.extensions.form.prototype.init.apply(this, arguments);
        },

        // Called when the button the toolbar is clicked
        // Overrides ButtonExtension.handleClick
        handleClick: function (event) {
            event.preventDefault();
            event.stopPropagation();

            if (!this.isDisplayed()) {
                // Get FontName of current selection (convert to string since IE returns this as number)
                var fontName = this.document.queryCommandValue('fontName') + '';
                this.showForm(fontName);
            }

            return false;
        },

        // Called by medium-editor to append form to the toolbar
        getForm: function () {
            if (!this.form) {
                this.form = this.createForm();
            }
            return this.form;
        },

        // Used by medium-editor when the default toolbar is to be displayed
        isDisplayed: function () {
            return this.getForm().style.display === 'block';
        },

        hideForm: function () {
            this.getForm().style.display = 'none';
            this.getSelect().value = '';
        },

        showForm: function (fontName) {
            var select = this.getSelect();

            this.base.saveSelection();
            this.hideToolbarDefaultActions();
            this.getForm().style.display = 'block';
            this.setToolbarPosition();

            select.value = fontName || '';
            select.focus();
        },

        // Called by core when tearing down medium-editor (destroy)
        destroy: function () {
            if (!this.form) {
                return false;
            }

            if (this.form.parentNode) {
                this.form.parentNode.removeChild(this.form);
            }

            delete this.form;
        },

        // core methods

        doFormSave: function () {
            this.base.restoreSelection();
            this.base.checkSelection();
        },

        doFormCancel: function () {
            this.base.restoreSelection();
            this.clearFontName();
            this.base.checkSelection();
        },

        // form creation and event handling
        createForm: function () {
            var doc = this.document,
                form = doc.createElement('div'),
                select = doc.createElement('select'),
                close = doc.createElement('a'),
                save = doc.createElement('a'),
                option;

            // Font Name Form (div)
            form.className = 'medium-editor-toolbar-form';
            form.id = 'medium-editor-toolbar-form-fontname-' + this.getEditorId();

            // Handle clicks on the form itself
            this.on(form, 'click', this.handleFormClick.bind(this));

            // Add font names
            for (var i = 0; i<this.fonts.length; i++) {
                option = doc.createElement('option');
                option.innerHTML = this.fonts[i];
                option.value = this.fonts[i];
                select.appendChild(option);
            }

            select.className = 'medium-editor-toolbar-select';
            form.appendChild(select);

            // Handle typing in the textbox
            this.on(select, 'change', this.handleFontChange.bind(this));

            // Add save buton
            save.setAttribute('href', '#');
            save.className = 'medium-editor-toobar-save';
            save.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
                             '<i class="fa fa-check"></i>' :
                             '&#10003;';
            form.appendChild(save);

            // Handle save button clicks (capture)
            this.on(save, 'click', this.handleSaveClick.bind(this), true);

            // Add close button
            close.setAttribute('href', '#');
            close.className = 'medium-editor-toobar-close';
            close.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
                              '<i class="fa fa-times"></i>' :
                              '&times;';
            form.appendChild(close);

            // Handle close button clicks
            this.on(close, 'click', this.handleCloseClick.bind(this));

            return form;
        },

        getSelect: function () {
            return this.getForm().querySelector('select.medium-editor-toolbar-select');
        },

        clearFontName: function () {
            MediumEditor.selection.getSelectedElements(this.document).forEach(function (el) {
                if (el.nodeName.toLowerCase() === 'font' && el.hasAttribute('face')) {
                    el.removeAttribute('face');
                }
            });
        },

        handleFontChange: function () {
            var font = this.getSelect().value;
            if (font === '') {
                this.clearFontName();
            } else {
                this.execAction('fontName', { name: font });
            }
        },

        handleFormClick: function (event) {
            // make sure not to hide form when clicking inside the form
            event.stopPropagation();
        },

        handleSaveClick: function (event) {
            // Clicking Save -> create the font size
            event.preventDefault();
            this.doFormSave();
        },

        handleCloseClick: function (event) {
            // Click Close -> close the form
            event.preventDefault();
            this.doFormCancel();
        }
    });

    MediumEditor.extensions.fontName = FontNameForm;
}());

(function () {
    'use strict';

    var FontSizeForm = MediumEditor.extensions.form.extend({

        name: 'fontsize',
        action: 'fontSize',
        aria: 'increase/decrease font size',
        contentDefault: '&#xB1;', // 
        contentFA: '<i class="fa fa-text-height"></i>',

        init: function () {
            MediumEditor.extensions.form.prototype.init.apply(this, arguments);
        },

        // Called when the button the toolbar is clicked
        // Overrides ButtonExtension.handleClick
        handleClick: function (event) {
            event.preventDefault();
            event.stopPropagation();

            if (!this.isDisplayed()) {
                // Get fontsize of current selection (convert to string since IE returns this as number)
                var fontSize = this.document.queryCommandValue('fontSize') + '';
                this.showForm(fontSize);
            }

            return false;
        },

        // Called by medium-editor to append form to the toolbar
        getForm: function () {
            if (!this.form) {
                this.form = this.createForm();
            }
            return this.form;
        },

        // Used by medium-editor when the default toolbar is to be displayed
        isDisplayed: function () {
            return this.getForm().style.display === 'block';
        },

        hideForm: function () {
            this.getForm().style.display = 'none';
            this.getInput().value = '';
        },

        showForm: function (fontSize) {
            var input = this.getInput();

            this.base.saveSelection();
            this.hideToolbarDefaultActions();
            this.getForm().style.display = 'block';
            this.setToolbarPosition();

            input.value = fontSize || '';
            input.focus();
        },

        // Called by core when tearing down medium-editor (destroy)
        destroy: function () {
            if (!this.form) {
                return false;
            }

            if (this.form.parentNode) {
                this.form.parentNode.removeChild(this.form);
            }

            delete this.form;
        },

        // core methods

        doFormSave: function () {
            this.base.restoreSelection();
            this.base.checkSelection();
        },

        doFormCancel: function () {
            this.base.restoreSelection();
            this.clearFontSize();
            this.base.checkSelection();
        },

        // form creation and event handling
        createForm: function () {
            var doc = this.document,
                form = doc.createElement('div'),
                input = doc.createElement('input'),
                close = doc.createElement('a'),
                save = doc.createElement('a');

            // Font Size Form (div)
            form.className = 'medium-editor-toolbar-form';
            form.id = 'medium-editor-toolbar-form-fontsize-' + this.getEditorId();

            // Handle clicks on the form itself
            this.on(form, 'click', this.handleFormClick.bind(this));

            // Add font size slider
            input.setAttribute('type', 'range');
            input.setAttribute('min', '1');
            input.setAttribute('max', '7');
            input.className = 'medium-editor-toolbar-input';
            form.appendChild(input);

            // Handle typing in the textbox
            this.on(input, 'change', this.handleSliderChange.bind(this));

            // Add save buton
            save.setAttribute('href', '#');
            save.className = 'medium-editor-toobar-save';
            save.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
                             '<i class="fa fa-check"></i>' :
                             '&#10003;';
            form.appendChild(save);

            // Handle save button clicks (capture)
            this.on(save, 'click', this.handleSaveClick.bind(this), true);

            // Add close button
            close.setAttribute('href', '#');
            close.className = 'medium-editor-toobar-close';
            close.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
                              '<i class="fa fa-times"></i>' :
                              '&times;';
            form.appendChild(close);

            // Handle close button clicks
            this.on(close, 'click', this.handleCloseClick.bind(this));

            return form;
        },

        getInput: function () {
            return this.getForm().querySelector('input.medium-editor-toolbar-input');
        },

        clearFontSize: function () {
            MediumEditor.selection.getSelectedElements(this.document).forEach(function (el) {
                if (el.nodeName.toLowerCase() === 'font' && el.hasAttribute('size')) {
                    el.removeAttribute('size');
                }
            });
        },

        handleSliderChange: function () {
            var size = this.getInput().value;
            if (size === '4') {
                this.clearFontSize();
            } else {
                this.execAction('fontSize', { size: size });
            }
        },

        handleFormClick: function (event) {
            // make sure not to hide form when clicking inside the form
            event.stopPropagation();
        },

        handleSaveClick: function (event) {
            // Clicking Save -> create the font size
            event.preventDefault();
            this.doFormSave();
        },

        handleCloseClick: function (event) {
            // Click Close -> close the form
            event.preventDefault();
            this.doFormCancel();
        }
    });

    MediumEditor.extensions.fontSize = FontSizeForm;
}());
(function () {
    'use strict';
    /*jslint regexp: true*/
    /*
        jslint does not allow character negation, because the negation
        will not match any unicode characters. In the regexes in this
        block, negation is used specifically to match the end of an html
        tag, and in fact unicode characters *should* be allowed.
    */
    function createReplacements() {
        return [
            // replace two bogus tags that begin pastes from google docs
            [new RegExp(/<[^>]*docs-internal-guid[^>]*>/gi), ''],
            [new RegExp(/<\/b>(<br[^>]*>)?$/gi), ''],

             // un-html spaces and newlines inserted by OS X
            [new RegExp(/<span class="Apple-converted-space">\s+<\/span>/g), ' '],
            [new RegExp(/<br class="Apple-interchange-newline">/g), '<br>'],

            // replace google docs italics+bold with a span to be replaced once the html is inserted
            [new RegExp(/<span[^>]*(font-style:italic;font-weight:bold|font-weight:bold;font-style:italic)[^>]*>/gi), '<span class="replace-with italic bold">'],

            // replace google docs italics with a span to be replaced once the html is inserted
            [new RegExp(/<span[^>]*font-style:italic[^>]*>/gi), '<span class="replace-with italic">'],

            //[replace google docs bolds with a span to be replaced once the html is inserted
            [new RegExp(/<span[^>]*font-weight:bold[^>]*>/gi), '<span class="replace-with bold">'],

             // replace manually entered b/i/a tags with real ones
            [new RegExp(/&lt;(\/?)(i|b|a)&gt;/gi), '<$1$2>'],

             // replace manually a tags with real ones, converting smart-quotes from google docs
            [new RegExp(/&lt;a(?:(?!href).)+href=(?:&quot;|&rdquo;|&ldquo;|"||)(((?!&quot;|&rdquo;|&ldquo;|"||).)*)(?:&quot;|&rdquo;|&ldquo;|"||)(?:(?!&gt;).)*&gt;/gi), '<a href="$1">'],

            // Newlines between paragraphs in html have no syntactic value,
            // but then have a tendency to accidentally become additional paragraphs down the line
            [new RegExp(/<\/p>\n+/gi), '</p>'],
            [new RegExp(/\n+<p/gi), '<p'],

            // Microsoft Word makes these odd tags, like <o:p></o:p>
            [new RegExp(/<\/?o:[a-z]*>/gi), ''],

            // cleanup comments added by Chrome when pasting html
            ['<!--EndFragment-->', ''],
            ['<!--StartFragment-->', '']
        ];
    }
    /*jslint regexp: false*/

    var PasteHandler = MediumEditor.Extension.extend({
        /* Paste Options */

        /* forcePlainText: [boolean]
         * Forces pasting as plain text.
         */
        forcePlainText: true,

        /* cleanPastedHTML: [boolean]
         * cleans pasted content from different sources, like google docs etc.
         */
        cleanPastedHTML: false,

        /* preCleanReplacements: [Array]
         * custom pairs (2 element arrays) of RegExp and replacement text to use during past when
         * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.
         * These replacements are executed before any medium editor defined replacements.
         */
        preCleanReplacements: [],

        /* cleanReplacements: [Array]
         * custom pairs (2 element arrays) of RegExp and replacement text to use during paste when
         * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.
         * These replacements are executed after any medium editor defined replacements.
         */
        cleanReplacements: [],

        /* cleanAttrs:: [Array]
         * list of element attributes to remove during paste when __cleanPastedHTML__ is `true` or when
         * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.
         */
        cleanAttrs: ['class', 'style', 'dir'],

        /* cleanTags: [Array]
         * list of element tag names to remove during paste when __cleanPastedHTML__ is `true` or when
         * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.
         */
        cleanTags: ['meta'],

        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            if (this.forcePlainText || this.cleanPastedHTML) {
                this.subscribe('editablePaste', this.handlePaste.bind(this));
            }
        },

        handlePaste: function (event, element) {
            var paragraphs,
                html = '',
                p,
                dataFormatHTML = 'text/html',
                dataFormatPlain = 'text/plain',
                pastedHTML,
                pastedPlain;

            if (this.window.clipboardData && event.clipboardData === undefined) {
                event.clipboardData = this.window.clipboardData;
                // If window.clipboardData exists, but event.clipboardData doesn't exist,
                // we're probably in IE. IE only has two possibilities for clipboard
                // data format: 'Text' and 'URL'.
                //
                // Of the two, we want 'Text':
                dataFormatHTML = 'Text';
                dataFormatPlain = 'Text';
            }

            if (event.clipboardData &&
                    event.clipboardData.getData &&
                    !event.defaultPrevented) {
                event.preventDefault();

                pastedHTML = event.clipboardData.getData(dataFormatHTML);
                pastedPlain = event.clipboardData.getData(dataFormatPlain);

                if (this.cleanPastedHTML && pastedHTML) {
                    return this.cleanPaste(pastedHTML);
                }

                if (!(this.getEditorOption('disableReturn') || element.getAttribute('data-disable-return'))) {
                    paragraphs = pastedPlain.split(/[\r\n]+/g);
                    // If there are no \r\n in data, don't wrap in <p>
                    if (paragraphs.length > 1) {
                        for (p = 0; p < paragraphs.length; p += 1) {
                            if (paragraphs[p] !== '') {
                                html += '<p>' + MediumEditor.util.htmlEntities(paragraphs[p]) + '</p>';
                            }
                        }
                    } else {
                        html = MediumEditor.util.htmlEntities(paragraphs[0]);
                    }
                } else {
                    html = MediumEditor.util.htmlEntities(pastedPlain);
                }
                MediumEditor.util.insertHTMLCommand(this.document, html);
            }
        },

        cleanPaste: function (text) {
            var i, elList, tmp, workEl,
                multiline = /<p|<br|<div/.test(text),
                replacements = [].concat(
                    this.preCleanReplacements || [],
                    createReplacements(),
                    this.cleanReplacements || []);

            for (i = 0; i < replacements.length; i += 1) {
                text = text.replace(replacements[i][0], replacements[i][1]);
            }

            if (!multiline) {
                return this.pasteHTML(text);
            }

            // create a temporary div to cleanup block elements
            tmp = this.document.createElement('div');

            // double br's aren't converted to p tags, but we want paragraphs.
            tmp.innerHTML = '<p>' + text.split('<br><br>').join('</p><p>') + '</p>';

            // block element cleanup
            elList = tmp.querySelectorAll('a,p,div,br');
            for (i = 0; i < elList.length; i += 1) {
                workEl = elList[i];

                // Microsoft Word replaces some spaces with newlines.
                // While newlines between block elements are meaningless, newlines within
                // elements are sometimes actually spaces.
                workEl.innerHTML = workEl.innerHTML.replace(/\n/gi, ' ');

                switch (workEl.nodeName.toLowerCase()) {
                    case 'p':
                    case 'div':
                        this.filterCommonBlocks(workEl);
                        break;
                    case 'br':
                        this.filterLineBreak(workEl);
                        break;
                }
            }

            this.pasteHTML(tmp.innerHTML);
        },

        pasteHTML: function (html, options) {
            options = MediumEditor.util.defaults({}, options, {
                cleanAttrs: this.cleanAttrs,
                cleanTags: this.cleanTags
            });

            var elList, workEl, i, fragmentBody, pasteBlock = this.document.createDocumentFragment();

            pasteBlock.appendChild(this.document.createElement('body'));

            fragmentBody = pasteBlock.querySelector('body');
            fragmentBody.innerHTML = html;

            this.cleanupSpans(fragmentBody);

            elList = fragmentBody.querySelectorAll('*');
            for (i = 0; i < elList.length; i += 1) {
                workEl = elList[i];

                if ('a' === workEl.nodeName.toLowerCase() && this.getEditorOption('targetBlank')) {
                    MediumEditor.util.setTargetBlank(workEl);
                }

                MediumEditor.util.cleanupAttrs(workEl, options.cleanAttrs);
                MediumEditor.util.cleanupTags(workEl, options.cleanTags);
            }

            MediumEditor.util.insertHTMLCommand(this.document, fragmentBody.innerHTML.replace(/&nbsp;/g, ' '));
        },

        isCommonBlock: function (el) {
            return (el && (el.nodeName.toLowerCase() === 'p' || el.nodeName.toLowerCase() === 'div'));
        },

        filterCommonBlocks: function (el) {
            if (/^\s*$/.test(el.textContent) && el.parentNode) {
                el.parentNode.removeChild(el);
            }
        },

        filterLineBreak: function (el) {
            if (this.isCommonBlock(el.previousElementSibling)) {
                // remove stray br's following common block elements
                this.removeWithParent(el);
            } else if (this.isCommonBlock(el.parentNode) && (el.parentNode.firstChild === el || el.parentNode.lastChild === el)) {
                // remove br's just inside open or close tags of a div/p
                this.removeWithParent(el);
            } else if (el.parentNode && el.parentNode.childElementCount === 1 && el.parentNode.textContent === '') {
                // and br's that are the only child of elements other than div/p
                this.removeWithParent(el);
            }
        },

        // remove an element, including its parent, if it is the only element within its parent
        removeWithParent: function (el) {
            if (el && el.parentNode) {
                if (el.parentNode.parentNode && el.parentNode.childElementCount === 1) {
                    el.parentNode.parentNode.removeChild(el.parentNode);
                } else {
                    el.parentNode.removeChild(el);
                }
            }
        },

        cleanupSpans: function (containerEl) {
            var i,
                el,
                newEl,
                spans = containerEl.querySelectorAll('.replace-with'),
                isCEF = function (el) {
                    return (el && el.nodeName !== '#text' && el.getAttribute('contenteditable') === 'false');
                };

            for (i = 0; i < spans.length; i += 1) {
                el = spans[i];
                newEl = this.document.createElement(el.classList.contains('bold') ? 'b' : 'i');

                if (el.classList.contains('bold') && el.classList.contains('italic')) {
                    // add an i tag as well if this has both italics and bold
                    newEl.innerHTML = '<i>' + el.innerHTML + '</i>';
                } else {
                    newEl.innerHTML = el.innerHTML;
                }
                el.parentNode.replaceChild(newEl, el);
            }

            spans = containerEl.querySelectorAll('span');
            for (i = 0; i < spans.length; i += 1) {
                el = spans[i];

                // bail if span is in contenteditable = false
                if (MediumEditor.util.traverseUp(el, isCEF)) {
                    return false;
                }

                // remove empty spans, replace others with their contents
                MediumEditor.util.unwrap(el, this.document);
            }
        }
    });

    MediumEditor.extensions.paste = PasteHandler;
}());

(function () {
    'use strict';

    var Placeholder = MediumEditor.Extension.extend({
        name: 'placeholder',

        /* Placeholder Options */

        /* text: [string]
         * Text to display in the placeholder
         */
        text: 'Type your text',

        /* hideOnClick: [boolean]
         * Should we hide the placeholder on click (true) or when user starts typing (false)
         */
        hideOnClick: true,

        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            this.initPlaceholders();
            this.attachEventHandlers();
        },

        initPlaceholders: function () {
            this.getEditorElements().forEach(function (el) {
                if (!el.getAttribute('data-placeholder')) {
                    el.setAttribute('data-placeholder', this.text);
                }
                this.updatePlaceholder(el);
            }, this);
        },

        destroy: function () {
            this.getEditorElements().forEach(function (el) {
                if (el.getAttribute('data-placeholder') === this.text) {
                    el.removeAttribute('data-placeholder');
                }
            }, this);
        },

        showPlaceholder: function (el) {
            if (el) {
                el.classList.add('medium-editor-placeholder');
            }
        },

        hidePlaceholder: function (el) {
            if (el) {
                el.classList.remove('medium-editor-placeholder');
            }
        },

        updatePlaceholder: function (el, dontShow) {
            // If the element has content, hide the placeholder
            if (el.querySelector('img, blockquote, ul, ol') || (el.textContent.replace(/^\s+|\s+$/g, '') !== '')) {
                return this.hidePlaceholder(el);
            }

            if (!dontShow) {
                this.showPlaceholder(el);
            }
        },

        attachEventHandlers: function () {
            if (this.hideOnClick) {
                // For the 'hideOnClick' option, the placeholder should always be hidden on focus
                this.subscribe('focus', this.handleFocus.bind(this));
            }

            // If the editor has content, it should always hide the placeholder
            this.subscribe('editableInput', this.handleInput.bind(this));

            // When the editor loses focus, check if the placeholder should be visible
            this.subscribe('blur', this.handleBlur.bind(this));
        },

        handleInput: function (event, element) {
            // If the placeholder should be hidden on focus and the
            // element has focus, don't show the placeholder
            var dontShow = this.hideOnClick && (element === this.base.getFocusedElement());

            // Editor's content has changed, check if the placeholder should be hidden
            this.updatePlaceholder(element, dontShow);
        },

        handleFocus: function (event, element) {
            // Editor has focus, hide the placeholder
            this.hidePlaceholder(element);
        },

        handleBlur: function (event, element) {
            // Editor has lost focus, check if the placeholder should be shown
            this.updatePlaceholder(element);
        }
    });

    MediumEditor.extensions.placeholder = Placeholder;
}());

(function () {
    'use strict';

    var Toolbar = MediumEditor.Extension.extend({
        name: 'toolbar',

        /* Toolbar Options */

        /* align: ['left'|'center'|'right']
         * When the __static__ option is true, this aligns the static toolbar
         * relative to the medium-editor element.
         */
        align: 'center',

        /* allowMultiParagraphSelection: [boolean]
         * enables/disables whether the toolbar should be displayed when
         * selecting multiple paragraphs/block elements
         */
        allowMultiParagraphSelection: true,

        /* buttons: [Array]
         * the names of the set of buttons to display on the toolbar.
         */
        buttons: ['bold', 'italic', 'underline', 'anchor', 'h2', 'h3', 'quote'],

        /* diffLeft: [Number]
         * value in pixels to be added to the X axis positioning of the toolbar.
         */
        diffLeft: 0,

        /* diffTop: [Number]
         * value in pixels to be added to the Y axis positioning of the toolbar.
         */
        diffTop: -10,

        /* firstButtonClass: [string]
         * CSS class added to the first button in the toolbar.
         */
        firstButtonClass: 'medium-editor-button-first',

        /* lastButtonClass: [string]
         * CSS class added to the last button in the toolbar.
         */
        lastButtonClass: 'medium-editor-button-last',

        /* standardizeSelectionStart: [boolean]
         * enables/disables standardizing how the beginning of a range is decided
         * between browsers whenever the selected text is analyzed for updating toolbar buttons status.
         */
        standardizeSelectionStart: false,

        /* static: [boolean]
         * enable/disable the toolbar always displaying in the same location
         * relative to the medium-editor element.
         */
        static: false,

        /* sticky: [boolean]
         * When the __static__ option is true, this enables/disables the toolbar
         * "sticking" to the viewport and staying visible on the screen while
         * the page scrolls.
         */
        sticky: false,

        /* stickyTopOffset: [Number]
         * Value in pixel of the top offset above the toolbar
         */
        stickyTopOffset: 0,

        /* updateOnEmptySelection: [boolean]
         * When the __static__ option is true, this enables/disables updating
         * the state of the toolbar buttons even when the selection is collapsed
         * (there is no selection, just a cursor).
         */
        updateOnEmptySelection: false,

        /* relativeContainer: [node]
         * appending the toolbar to a given node instead of body
         */
        relativeContainer: null,

        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            this.initThrottledMethods();

            if (!this.relativeContainer) {
                this.getEditorOption('elementsContainer').appendChild(this.getToolbarElement());
            } else {
                this.relativeContainer.appendChild(this.getToolbarElement());
            }
        },

        // Helper method to execute method for every extension, but ignoring the toolbar extension
        forEachExtension: function (iterator, context) {
            return this.base.extensions.forEach(function (command) {
                if (command === this) {
                    return;
                }
                return iterator.apply(context || this, arguments);
            }, this);
        },

        // Toolbar creation/deletion

        createToolbar: function () {
            var toolbar = this.document.createElement('div');

            toolbar.id = 'medium-editor-toolbar-' + this.getEditorId();
            toolbar.className = 'medium-editor-toolbar';

            if (this.static) {
                toolbar.className += ' static-toolbar';
            } else if (this.relativeContainer) {
                toolbar.className += ' medium-editor-relative-toolbar';
            } else {
                toolbar.className += ' medium-editor-stalker-toolbar';
            }

            toolbar.appendChild(this.createToolbarButtons());

            // Add any forms that extensions may have
            this.forEachExtension(function (extension) {
                if (extension.hasForm) {
                    toolbar.appendChild(extension.getForm());
                }
            });

            this.attachEventHandlers();

            return toolbar;
        },

        createToolbarButtons: function () {
            var ul = this.document.createElement('ul'),
                li,
                btn,
                buttons,
                extension,
                buttonName,
                buttonOpts;

            ul.id = 'medium-editor-toolbar-actions' + this.getEditorId();
            ul.className = 'medium-editor-toolbar-actions';
            ul.style.display = 'block';

            this.buttons.forEach(function (button) {
                if (typeof button === 'string') {
                    buttonName = button;
                    buttonOpts = null;
                } else {
                    buttonName = button.name;
                    buttonOpts = button;
                }

                // If the button already exists as an extension, it'll be returned
                // othwerise it'll create the default built-in button
                extension = this.base.addBuiltInExtension(buttonName, buttonOpts);

                if (extension && typeof extension.getButton === 'function') {
                    btn = extension.getButton(this.base);
                    li = this.document.createElement('li');
                    if (MediumEditor.util.isElement(btn)) {
                        li.appendChild(btn);
                    } else {
                        li.innerHTML = btn;
                    }
                    ul.appendChild(li);
                }
            }, this);

            buttons = ul.querySelectorAll('button');
            if (buttons.length > 0) {
                buttons[0].classList.add(this.firstButtonClass);
                buttons[buttons.length - 1].classList.add(this.lastButtonClass);
            }

            return ul;
        },

        destroy: function () {
            if (this.toolbar) {
                if (this.toolbar.parentNode) {
                    this.toolbar.parentNode.removeChild(this.toolbar);
                }
                delete this.toolbar;
            }
        },

        // Toolbar accessors

        getToolbarElement: function () {
            if (!this.toolbar) {
                this.toolbar = this.createToolbar();
            }

            return this.toolbar;
        },

        getToolbarActionsElement: function () {
            return this.getToolbarElement().querySelector('.medium-editor-toolbar-actions');
        },

        // Toolbar event handlers

        initThrottledMethods: function () {
            // throttledPositionToolbar is throttled because:
            // - It will be called when the browser is resizing, which can fire many times very quickly
            // - For some event (like resize) a slight lag in UI responsiveness is OK and provides performance benefits
            this.throttledPositionToolbar = MediumEditor.util.throttle(function () {
                if (this.base.isActive) {
                    this.positionToolbarIfShown();
                }
            }.bind(this));
        },

        attachEventHandlers: function () {
            // MediumEditor custom events for when user beings and ends interaction with a contenteditable and its elements
            this.subscribe('blur', this.handleBlur.bind(this));
            this.subscribe('focus', this.handleFocus.bind(this));

            // Updating the state of the toolbar as things change
            this.subscribe('editableClick', this.handleEditableClick.bind(this));
            this.subscribe('editableKeyup', this.handleEditableKeyup.bind(this));

            // Handle mouseup on document for updating the selection in the toolbar
            this.on(this.document.documentElement, 'mouseup', this.handleDocumentMouseup.bind(this));

            // Add a scroll event for sticky toolbar
            if (this.static && this.sticky) {
                // On scroll (capture), re-position the toolbar
                this.on(this.window, 'scroll', this.handleWindowScroll.bind(this), true);
            }

            // On resize, re-position the toolbar
            this.on(this.window, 'resize', this.handleWindowResize.bind(this));
        },

        handleWindowScroll: function () {
            this.positionToolbarIfShown();
        },

        handleWindowResize: function () {
            this.throttledPositionToolbar();
        },

        handleDocumentMouseup: function (event) {
            // Do not trigger checkState when mouseup fires over the toolbar
            if (event &&
                    event.target &&
                    MediumEditor.util.isDescendant(this.getToolbarElement(), event.target)) {
                return false;
            }
            this.checkState();
        },

        handleEditableClick: function () {
            // Delay the call to checkState to handle bug where selection is empty
            // immediately after clicking inside a pre-existing selection
            setTimeout(function () {
                this.checkState();
            }.bind(this), 0);
        },

        handleEditableKeyup: function () {
            this.checkState();
        },

        handleBlur: function () {
            // Kill any previously delayed calls to hide the toolbar
            clearTimeout(this.hideTimeout);

            // Blur may fire even if we have a selection, so we want to prevent any delayed showToolbar
            // calls from happening in this specific case
            clearTimeout(this.delayShowTimeout);

            // Delay the call to hideToolbar to handle bug with multiple editors on the page at once
            this.hideTimeout = setTimeout(function () {
                this.hideToolbar();
            }.bind(this), 1);
        },

        handleFocus: function () {
            this.checkState();
        },

        // Hiding/showing toolbar

        isDisplayed: function () {
            return this.getToolbarElement().classList.contains('medium-editor-toolbar-active');
        },

        showToolbar: function () {
            clearTimeout(this.hideTimeout);
            if (!this.isDisplayed()) {
                this.getToolbarElement().classList.add('medium-editor-toolbar-active');
                this.trigger('showToolbar', {}, this.base.getFocusedElement());
            }
        },

        hideToolbar: function () {
            if (this.isDisplayed()) {
                this.getToolbarElement().classList.remove('medium-editor-toolbar-active');
                this.trigger('hideToolbar', {}, this.base.getFocusedElement());
            }
        },

        isToolbarDefaultActionsDisplayed: function () {
            return this.getToolbarActionsElement().style.display === 'block';
        },

        hideToolbarDefaultActions: function () {
            if (this.isToolbarDefaultActionsDisplayed()) {
                this.getToolbarActionsElement().style.display = 'none';
            }
        },

        showToolbarDefaultActions: function () {
            this.hideExtensionForms();

            if (!this.isToolbarDefaultActionsDisplayed()) {
                this.getToolbarActionsElement().style.display = 'block';
            }

            // Using setTimeout + options.delay because:
            // We will actually be displaying the toolbar, which should be controlled by options.delay
            this.delayShowTimeout = this.base.delay(function () {
                this.showToolbar();
            }.bind(this));
        },

        hideExtensionForms: function () {
            // Hide all extension forms
            this.forEachExtension(function (extension) {
                if (extension.hasForm && extension.isDisplayed()) {
                    extension.hideForm();
                }
            });
        },

        // Responding to changes in user selection

        // Checks for existance of multiple block elements in the current selection
        multipleBlockElementsSelected: function () {
            var regexEmptyHTMLTags = /<[^\/>][^>]*><\/[^>]+>/gim, // http://stackoverflow.com/questions/3129738/remove-empty-tags-using-regex
                regexBlockElements = new RegExp('<(' + MediumEditor.util.blockContainerElementNames.join('|') + ')[^>]*>', 'g'),
                selectionHTML = MediumEditor.selection.getSelectionHtml(this.document).replace(regexEmptyHTMLTags, ''), // Filter out empty blocks from selection
                hasMultiParagraphs = selectionHTML.match(regexBlockElements); // Find how many block elements are within the html

            return !!hasMultiParagraphs && hasMultiParagraphs.length > 1;
        },

        modifySelection: function () {
            var selection = this.window.getSelection(),
                selectionRange = selection.getRangeAt(0);

            /*
            * In firefox, there are cases (ie doubleclick of a word) where the selectionRange start
            * will be at the very end of an element.  In other browsers, the selectionRange start
            * would instead be at the very beginning of an element that actually has content.
            * example:
            *   <span>foo</span><span>bar</span>
            *
            * If the text 'bar' is selected, most browsers will have the selectionRange start at the beginning
            * of the 'bar' span.  However, there are cases where firefox will have the selectionRange start
            * at the end of the 'foo' span.  The contenteditable behavior will be ok, but if there are any
            * properties on the 'bar' span, they won't be reflected accurately in the toolbar
            * (ie 'Bold' button wouldn't be active)
            *
            * So, for cases where the selectionRange start is at the end of an element/node, find the next
            * adjacent text node that actually has content in it, and move the selectionRange start there.
            */
            if (this.standardizeSelectionStart &&
                    selectionRange.startContainer.nodeValue &&
                    (selectionRange.startOffset === selectionRange.startContainer.nodeValue.length)) {
                var adjacentNode = MediumEditor.util.findAdjacentTextNodeWithContent(MediumEditor.selection.getSelectionElement(this.window), selectionRange.startContainer, this.document);
                if (adjacentNode) {
                    var offset = 0;
                    while (adjacentNode.nodeValue.substr(offset, 1).trim().length === 0) {
                        offset = offset + 1;
                    }
                    selectionRange = MediumEditor.selection.select(this.document, adjacentNode, offset,
                        selectionRange.endContainer, selectionRange.endOffset);
                }
            }
        },

        checkState: function () {
            if (this.base.preventSelectionUpdates) {
                return;
            }

            // If no editable has focus OR selection is inside contenteditable = false
            // hide toolbar
            if (!this.base.getFocusedElement() ||
                    MediumEditor.selection.selectionInContentEditableFalse(this.window)) {
                return this.hideToolbar();
            }

            // If there's no selection element, selection element doesn't belong to this editor
            // or toolbar is disabled for this selection element
            // hide toolbar
            var selectionElement = MediumEditor.selection.getSelectionElement(this.window);
            if (!selectionElement ||
                    this.getEditorElements().indexOf(selectionElement) === -1 ||
                    selectionElement.getAttribute('data-disable-toolbar')) {
                return this.hideToolbar();
            }

            // Now we know there's a focused editable with a selection

            // If the updateOnEmptySelection option is true, show the toolbar
            if (this.updateOnEmptySelection && this.static) {
                return this.showAndUpdateToolbar();
            }

            // If we don't have a 'valid' selection -> hide toolbar
            if (!MediumEditor.selection.selectionContainsContent(this.document) ||
                (this.allowMultiParagraphSelection === false && this.multipleBlockElementsSelected())) {
                return this.hideToolbar();
            }

            this.showAndUpdateToolbar();
        },

        // Updating the toolbar

        showAndUpdateToolbar: function () {
            this.modifySelection();
            this.setToolbarButtonStates();
            this.trigger('positionToolbar', {}, this.base.getFocusedElement());
            this.showToolbarDefaultActions();
            this.setToolbarPosition();
        },

        setToolbarButtonStates: function () {
            this.forEachExtension(function (extension) {
                if (typeof extension.isActive === 'function' &&
                    typeof extension.setInactive === 'function') {
                    extension.setInactive();
                }
            });

            this.checkActiveButtons();
        },

        checkActiveButtons: function () {
            var manualStateChecks = [],
                queryState = null,
                selectionRange = MediumEditor.selection.getSelectionRange(this.document),
                parentNode,
                updateExtensionState = function (extension) {
                    if (typeof extension.checkState === 'function') {
                        extension.checkState(parentNode);
                    } else if (typeof extension.isActive === 'function' &&
                               typeof extension.isAlreadyApplied === 'function' &&
                               typeof extension.setActive === 'function') {
                        if (!extension.isActive() && extension.isAlreadyApplied(parentNode)) {
                            extension.setActive();
                        }
                    }
                };

            if (!selectionRange) {
                return;
            }

            // Loop through all extensions
            this.forEachExtension(function (extension) {
                // For those extensions where we can use document.queryCommandState(), do so
                if (typeof extension.queryCommandState === 'function') {
                    queryState = extension.queryCommandState();
                    // If queryCommandState returns a valid value, we can trust the browser
                    // and don't need to do our manual checks
                    if (queryState !== null) {
                        if (queryState && typeof extension.setActive === 'function') {
                            extension.setActive();
                        }
                        return;
                    }
                }
                // We can't use queryCommandState for this extension, so add to manualStateChecks
                manualStateChecks.push(extension);
            });

            parentNode = MediumEditor.selection.getSelectedParentElement(selectionRange);

            // Make sure the selection parent isn't outside of the contenteditable
            if (!this.getEditorElements().some(function (element) {
                    return MediumEditor.util.isDescendant(element, parentNode, true);
                })) {
                return;
            }

            // Climb up the DOM and do manual checks for whether a certain extension is currently enabled for this node
            while (parentNode) {
                manualStateChecks.forEach(updateExtensionState);

                // we can abort the search upwards if we leave the contentEditable element
                if (MediumEditor.util.isMediumEditorElement(parentNode)) {
                    break;
                }
                parentNode = parentNode.parentNode;
            }
        },

        // Positioning toolbar

        positionToolbarIfShown: function () {
            if (this.isDisplayed()) {
                this.setToolbarPosition();
            }
        },

        setToolbarPosition: function () {
            var container = this.base.getFocusedElement(),
                selection = this.window.getSelection(),
                anchorPreview;

            // If there isn't a valid selection, bail
            if (!container) {
                return this;
            }

            if (this.static && !this.relativeContainer) {
                this.showToolbar();
                this.positionStaticToolbar(container);
            } else if (!selection.isCollapsed) {
                this.showToolbar();

                // we don't need any absolute positioning if relativeContainer is set
                if (!this.relativeContainer) {
                    this.positionToolbar(selection);
                }
            }

            anchorPreview = this.base.getExtensionByName('anchor-preview');

            if (anchorPreview && typeof anchorPreview.hidePreview === 'function') {
                anchorPreview.hidePreview();
            }
        },

        positionStaticToolbar: function (container) {
            // position the toolbar at left 0, so we can get the real width of the toolbar
            this.getToolbarElement().style.left = '0';

            // document.documentElement for IE 9
            var scrollTop = (this.document.documentElement && this.document.documentElement.scrollTop) || this.document.body.scrollTop,
                windowWidth = this.window.innerWidth,
                toolbarElement = this.getToolbarElement(),
                containerRect = container.getBoundingClientRect(),
                containerTop = containerRect.top + scrollTop,
                containerCenter = (containerRect.left + (containerRect.width / 2)),
                toolbarHeight = toolbarElement.offsetHeight,
                toolbarWidth = toolbarElement.offsetWidth,
                halfOffsetWidth = toolbarWidth / 2,
                targetLeft;

            if (this.sticky) {
                // If it's beyond the height of the editor, position it at the bottom of the editor
                if (scrollTop > (containerTop + container.offsetHeight - toolbarHeight - this.stickyTopOffset)) {
                    toolbarElement.style.top = (containerTop + container.offsetHeight - toolbarHeight) + 'px';
                    toolbarElement.classList.remove('medium-editor-sticky-toolbar');
                // Stick the toolbar to the top of the window
                } else if (scrollTop > (containerTop - toolbarHeight - this.stickyTopOffset)) {
                    toolbarElement.classList.add('medium-editor-sticky-toolbar');
                    toolbarElement.style.top = this.stickyTopOffset + 'px';
                // Normal static toolbar position
                } else {
                    toolbarElement.classList.remove('medium-editor-sticky-toolbar');
                    toolbarElement.style.top = containerTop - toolbarHeight + 'px';
                }
            } else {
                toolbarElement.style.top = containerTop - toolbarHeight + 'px';
            }

            switch (this.align) {
                case 'left':
                    targetLeft = containerRect.left;
                    break;

                case 'right':
                    targetLeft = containerRect.right - toolbarWidth;
                    break;

                case 'center':
                    targetLeft = containerCenter - halfOffsetWidth;
                    break;
            }

            if (targetLeft < 0) {
                targetLeft = 0;
            } else if ((targetLeft + toolbarWidth) > windowWidth) {
                targetLeft = (windowWidth - Math.ceil(toolbarWidth) - 1);
            }

            toolbarElement.style.left = targetLeft + 'px';
        },

        positionToolbar: function (selection) {
            // position the toolbar at left 0, so we can get the real width of the toolbar
            this.getToolbarElement().style.left = '0';
            this.getToolbarElement().style.right = 'initial';

            var range = selection.getRangeAt(0),
                boundary = range.getBoundingClientRect();

            // Handle selections with just images
            if (!boundary || ((boundary.height === 0 && boundary.width === 0) && range.startContainer === range.endContainer)) {
                // If there's a nested image, use that for the bounding rectangle
                if (range.startContainer.nodeType === 1 && range.startContainer.querySelector('img')) {
                    boundary = range.startContainer.querySelector('img').getBoundingClientRect();
                } else {
                    boundary = range.startContainer.getBoundingClientRect();
                }
            }

            var windowWidth = this.window.innerWidth,
                middleBoundary = (boundary.left + boundary.right) / 2,
                toolbarElement = this.getToolbarElement(),
                toolbarHeight = toolbarElement.offsetHeight,
                toolbarWidth = toolbarElement.offsetWidth,
                halfOffsetWidth = toolbarWidth / 2,
                buttonHeight = 50,
                defaultLeft = this.diffLeft - halfOffsetWidth;

            if (boundary.top < buttonHeight) {
                toolbarElement.classList.add('medium-toolbar-arrow-over');
                toolbarElement.classList.remove('medium-toolbar-arrow-under');
                toolbarElement.style.top = buttonHeight + boundary.bottom - this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';
            } else {
                toolbarElement.classList.add('medium-toolbar-arrow-under');
                toolbarElement.classList.remove('medium-toolbar-arrow-over');
                toolbarElement.style.top = boundary.top + this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';
            }

            if (middleBoundary < halfOffsetWidth) {
                toolbarElement.style.left = defaultLeft + halfOffsetWidth + 'px';
                toolbarElement.style.right = 'initial';
            } else if ((windowWidth - middleBoundary) < halfOffsetWidth) {
                toolbarElement.style.left = 'auto';
                toolbarElement.style.right = 0;
            } else {
                toolbarElement.style.left = defaultLeft + middleBoundary + 'px';
                toolbarElement.style.right = 'initial';
            }
        }
    });

    MediumEditor.extensions.toolbar = Toolbar;
}());

(function () {
    'use strict';

    var ImageDragging = MediumEditor.Extension.extend({
        init: function () {
            MediumEditor.Extension.prototype.init.apply(this, arguments);

            this.subscribe('editableDrag', this.handleDrag.bind(this));
            this.subscribe('editableDrop', this.handleDrop.bind(this));
        },

        handleDrag: function (event) {
            var className = 'medium-editor-dragover';
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';

            if (event.type === 'dragover') {
                event.target.classList.add(className);
            } else if (event.type === 'dragleave') {
                event.target.classList.remove(className);
            }
        },

        handleDrop: function (event) {
            var className = 'medium-editor-dragover',
                files;
            event.preventDefault();
            event.stopPropagation();

            // IE9 does not support the File API, so prevent file from opening in a new window
            // but also don't try to actually get the file
            if (event.dataTransfer.files) {
                files = Array.prototype.slice.call(event.dataTransfer.files, 0);
                files.some(function (file) {
                    if (file.type.match('image')) {
                        var fileReader, id;
                        fileReader = new FileReader();
                        fileReader.readAsDataURL(file);

                        id = 'medium-img-' + (+new Date());
                        MediumEditor.util.insertHTMLCommand(this.document, '<img class="medium-editor-image-loading" id="' + id + '" />');

                        fileReader.onload = function () {
                            var img = this.document.getElementById(id);
                            if (img) {
                                img.removeAttribute('id');
                                img.removeAttribute('class');
                                img.src = fileReader.result;
                            }
                        }.bind(this);
                    }
                }.bind(this));
            }
            event.target.classList.remove(className);
        }
    });

    MediumEditor.extensions.imageDragging = ImageDragging;
}());

(function () {
    'use strict';

    // Event handlers that shouldn't be exposed externally

    function handleDisableExtraSpaces(event) {
        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
            textContent = node.textContent,
            caretPositions = MediumEditor.selection.getCaretOffsets(node);

        if ((textContent[caretPositions.left - 1] === undefined) || (textContent[caretPositions.left - 1].trim() === '') || (textContent[caretPositions.left] !== undefined && textContent[caretPositions.left].trim() === '')) {
            event.preventDefault();
        }
    }

    function handleDisabledEnterKeydown(event, element) {
        if (this.options.disableReturn || element.getAttribute('data-disable-return')) {
            event.preventDefault();
        } else if (this.options.disableDoubleReturn || element.getAttribute('data-disable-double-return')) {
            var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument);

            // if current text selection is empty OR previous sibling text is empty OR it is not a list
            if ((node && node.textContent.trim() === '' && node.nodeName.toLowerCase() !== 'li') ||
                (node.previousElementSibling && node.previousElementSibling.nodeName.toLowerCase() !== 'br' &&
                 node.previousElementSibling.textContent.trim() === '')) {
                event.preventDefault();
            }
        }
    }

    function handleTabKeydown(event) {
        // Override tab only for pre nodes
        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
            tag = node && node.nodeName.toLowerCase();

        if (tag === 'pre') {
            event.preventDefault();
            MediumEditor.util.insertHTMLCommand(this.options.ownerDocument, '    ');
        }

        // Tab to indent list structures!
        if (MediumEditor.util.isListItem(node)) {
            event.preventDefault();

            // If Shift is down, outdent, otherwise indent
            if (event.shiftKey) {
                this.options.ownerDocument.execCommand('outdent', false, null);
            } else {
                this.options.ownerDocument.execCommand('indent', false, null);
            }
        }
    }

    function handleBlockDeleteKeydowns(event) {
        var p, node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
            tagName = node.nodeName.toLowerCase(),
            isEmpty = /^(\s+|<br\/?>)?$/i,
            isHeader = /h\d/i;

        if (MediumEditor.util.isKey(event, [MediumEditor.util.keyCode.BACKSPACE, MediumEditor.util.keyCode.ENTER]) &&
                // has a preceeding sibling
                node.previousElementSibling &&
                // in a header
                isHeader.test(tagName) &&
                // at the very end of the block
                MediumEditor.selection.getCaretOffsets(node).left === 0) {
            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) && isEmpty.test(node.previousElementSibling.innerHTML)) {
                // backspacing the begining of a header into an empty previous element will
                // change the tagName of the current node to prevent one
                // instead delete previous node and cancel the event.
                node.previousElementSibling.parentNode.removeChild(node.previousElementSibling);
                event.preventDefault();
            } else if (!this.options.disableDoubleReturn && MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER)) {
                // hitting return in the begining of a header will create empty header elements before the current one
                // instead, make "<p><br></p>" element, which are what happens if you hit return in an empty paragraph
                p = this.options.ownerDocument.createElement('p');
                p.innerHTML = '<br>';
                node.previousElementSibling.parentNode.insertBefore(p, node);
                event.preventDefault();
            }
        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.DELETE) &&
                    // between two sibling elements
                    node.nextElementSibling &&
                    node.previousElementSibling &&
                    // not in a header
                    !isHeader.test(tagName) &&
                    // in an empty tag
                    isEmpty.test(node.innerHTML) &&
                    // when the next tag *is* a header
                    isHeader.test(node.nextElementSibling.nodeName.toLowerCase())) {
            // hitting delete in an empty element preceding a header, ex:
            //  <p>[CURSOR]</p><h1>Header</h1>
            // Will cause the h1 to become a paragraph.
            // Instead, delete the paragraph node and move the cursor to the begining of the h1

            // remove node and move cursor to start of header
            MediumEditor.selection.moveCursor(this.options.ownerDocument, node.nextElementSibling);

            node.previousElementSibling.parentNode.removeChild(node);

            event.preventDefault();
        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) &&
                tagName === 'li' &&
                // hitting backspace inside an empty li
                isEmpty.test(node.innerHTML) &&
                // is first element (no preceeding siblings)
                !node.previousElementSibling &&
                // parent also does not have a sibling
                !node.parentElement.previousElementSibling &&
                // is not the only li in a list
                node.nextElementSibling &&
                node.nextElementSibling.nodeName.toLowerCase() === 'li') {
            // backspacing in an empty first list element in the first list (with more elements) ex:
            //  <ul><li>[CURSOR]</li><li>List Item 2</li></ul>
            // will remove the first <li> but add some extra element before (varies based on browser)
            // Instead, this will:
            // 1) remove the list element
            // 2) create a paragraph before the list
            // 3) move the cursor into the paragraph

            // create a paragraph before the list
            p = this.options.ownerDocument.createElement('p');
            p.innerHTML = '<br>';
            node.parentElement.parentElement.insertBefore(p, node.parentElement);

            // move the cursor into the new paragraph
            MediumEditor.selection.moveCursor(this.options.ownerDocument, p);

            // remove the list element
            node.parentElement.removeChild(node);

            event.preventDefault();
        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) &&
                (MediumEditor.util.getClosestTag(node, 'blockquote') !== false) &&
                MediumEditor.selection.getCaretOffsets(node).left === 0) {

            // when cursor is at the begining of the element and the element is <blockquote>
            // then pressing backspace key should change the <blockquote> to a <p> tag
            event.preventDefault();
            MediumEditor.util.execFormatBlock(this.options.ownerDocument, 'p');
        }
    }

    function handleKeyup(event) {
        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
            tagName;

        if (!node) {
            return;
        }

        if (MediumEditor.util.isMediumEditorElement(node) && node.children.length === 0) {
            this.options.ownerDocument.execCommand('formatBlock', false, 'p');
        }

        // https://github.com/yabwe/medium-editor/issues/834
        // https://github.com/yabwe/medium-editor/pull/382
        // Don't call format block if this is a block element (ie h1, figCaption, etc.)
        if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER) &&
            !MediumEditor.util.isListItem(node) &&
            !MediumEditor.util.isBlockContainer(node)) {

            tagName = node.nodeName.toLowerCase();
            // For anchor tags, unlink
            if (tagName === 'a') {
                this.options.ownerDocument.execCommand('unlink', false, null);
            } else if (!event.shiftKey && !event.ctrlKey) {
                this.options.ownerDocument.execCommand('formatBlock', false, 'p');
            }
        }
    }

    // Internal helper methods which shouldn't be exposed externally

    function addToEditors(win) {
        if (!win._mediumEditors) {
            // To avoid breaking users who are assuming that the unique id on
            // medium-editor elements will start at 1, inserting a 'null' in the
            // array so the unique-id can always map to the index of the editor instance
            win._mediumEditors = [null];
        }

        // If this already has a unique id, re-use it
        if (!this.id) {
            this.id = win._mediumEditors.length;
        }

        win._mediumEditors[this.id] = this;
    }

    function removeFromEditors(win) {
        if (!win._mediumEditors || !win._mediumEditors[this.id]) {
            return;
        }

        /* Setting the instance to null in the array instead of deleting it allows:
         * 1) Each instance to preserve its own unique-id, even after being destroyed
         *    and initialized again
         * 2) The unique-id to always correspond to an index in the array of medium-editor
         *    instances. Thus, we will be able to look at a contenteditable, and determine
         *    which instance it belongs to, by indexing into the global array.
         */
        win._mediumEditors[this.id] = null;
    }

    function createElementsArray(selector) {
        if (!selector) {
            selector = [];
        }
        // If string, use as query selector
        if (typeof selector === 'string') {
            selector = this.options.ownerDocument.querySelectorAll(selector);
        }
        // If element, put into array
        if (MediumEditor.util.isElement(selector)) {
            selector = [selector];
        }
        // Convert NodeList (or other array like object) into an array
        var elements = Array.prototype.slice.apply(selector);

        // Loop through elements and convert textarea's into divs
        this.elements = [];
        elements.forEach(function (element, index) {
            if (element.nodeName.toLowerCase() === 'textarea') {
                this.elements.push(createContentEditable.call(this, element, index));
            } else {
                this.elements.push(element);
            }
        }, this);
    }

    function setExtensionDefaults(extension, defaults) {
        Object.keys(defaults).forEach(function (prop) {
            if (extension[prop] === undefined) {
                extension[prop] = defaults[prop];
            }
        });
        return extension;
    }

    function initExtension(extension, name, instance) {
        var extensionDefaults = {
            'window': instance.options.contentWindow,
            'document': instance.options.ownerDocument,
            'base': instance
        };

        // Add default options into the extension
        extension = setExtensionDefaults(extension, extensionDefaults);

        // Call init on the extension
        if (typeof extension.init === 'function') {
            extension.init();
        }

        // Set extension name (if not already set)
        if (!extension.name) {
            extension.name = name;
        }
        return extension;
    }

    function isToolbarEnabled() {
        // If any of the elements don't have the toolbar disabled
        // We need a toolbar
        if (this.elements.every(function (element) {
                return !!element.getAttribute('data-disable-toolbar');
            })) {
            return false;
        }

        return this.options.toolbar !== false;
    }

    function isAnchorPreviewEnabled() {
        // If toolbar is disabled, don't add
        if (!isToolbarEnabled.call(this)) {
            return false;
        }

        return this.options.anchorPreview !== false;
    }

    function isPlaceholderEnabled() {
        return this.options.placeholder !== false;
    }

    function isAutoLinkEnabled() {
        return this.options.autoLink !== false;
    }

    function isImageDraggingEnabled() {
        return this.options.imageDragging !== false;
    }

    function isKeyboardCommandsEnabled() {
        return this.options.keyboardCommands !== false;
    }

    function shouldUseFileDraggingExtension() {
        // Since the file-dragging extension replaces the image-dragging extension,
        // we need to check if the user passed an overrided image-dragging extension.
        // If they have, to avoid breaking users, we won't use file-dragging extension.
        return !this.options.extensions['imageDragging'];
    }

    function createContentEditable(textarea, id) {
        var div = this.options.ownerDocument.createElement('div'),
            now = Date.now(),
            uniqueId = 'medium-editor-' + now + '-' + id,
            atts = textarea.attributes;

        // Some browsers can move pretty fast, since we're using a timestamp
        // to make a unique-id, ensure that the id is actually unique on the page
        while (this.options.ownerDocument.getElementById(uniqueId)) {
            now++;
            uniqueId = 'medium-editor-' + now + '-' + id;
        }

        div.className = textarea.className;
        div.id = uniqueId;
        div.innerHTML = textarea.value;

        textarea.setAttribute('medium-editor-textarea-id', uniqueId);

        // re-create all attributes from the textearea to the new created div
        for (var i = 0, n = atts.length; i < n; i++) {
            // do not re-create existing attributes
            if (!div.hasAttribute(atts[i].nodeName)) {
                div.setAttribute(atts[i].nodeName, atts[i].nodeValue);
            }
        }

        textarea.classList.add('medium-editor-hidden');
        textarea.parentNode.insertBefore(
            div,
            textarea
        );

        return div;
    }

    function initElements() {
        var isTextareaUsed = false;

        this.elements.forEach(function (element, index) {
            if (!this.options.disableEditing && !element.getAttribute('data-disable-editing')) {
                element.setAttribute('contentEditable', true);
                element.setAttribute('spellcheck', this.options.spellcheck);
            }
            element.setAttribute('data-medium-editor-element', true);
            element.setAttribute('role', 'textbox');
            element.setAttribute('aria-multiline', true);
            element.setAttribute('medium-editor-index', index);

            if (element.hasAttribute('medium-editor-textarea-id')) {
                isTextareaUsed = true;
            }
        }, this);

        if (isTextareaUsed) {
            this.subscribe('editableInput', function (event, editable) {
                var textarea = editable.parentNode.querySelector('textarea[medium-editor-textarea-id="' + editable.getAttribute('medium-editor-textarea-id') + '"]');
                if (textarea) {
                    textarea.value = this.serialize()[editable.id].value;
                }
            }.bind(this));
        }
    }

    function attachHandlers() {
        var i;

        // attach to tabs
        this.subscribe('editableKeydownTab', handleTabKeydown.bind(this));

        // Bind keys which can create or destroy a block element: backspace, delete, return
        this.subscribe('editableKeydownDelete', handleBlockDeleteKeydowns.bind(this));
        this.subscribe('editableKeydownEnter', handleBlockDeleteKeydowns.bind(this));

        // Bind double space event
        if (this.options.disableExtraSpaces) {
            this.subscribe('editableKeydownSpace', handleDisableExtraSpaces.bind(this));
        }

        // disabling return or double return
        if (this.options.disableReturn || this.options.disableDoubleReturn) {
            this.subscribe('editableKeydownEnter', handleDisabledEnterKeydown.bind(this));
        } else {
            for (i = 0; i < this.elements.length; i += 1) {
                if (this.elements[i].getAttribute('data-disable-return') || this.elements[i].getAttribute('data-disable-double-return')) {
                    this.subscribe('editableKeydownEnter', handleDisabledEnterKeydown.bind(this));
                    break;
                }
            }
        }

        // if we're not disabling return, add a handler to help handle cleanup
        // for certain cases when enter is pressed
        if (!this.options.disableReturn) {
            this.elements.forEach(function (element) {
                if (!element.getAttribute('data-disable-return')) {
                    this.on(element, 'keyup', handleKeyup.bind(this));
                }
            }, this);
        }
    }

    function initExtensions() {

        this.extensions = [];

        // Passed in extensions
        Object.keys(this.options.extensions).forEach(function (name) {
            // Always save the toolbar extension for last
            if (name !== 'toolbar' && this.options.extensions[name]) {
                this.extensions.push(initExtension(this.options.extensions[name], name, this));
            }
        }, this);

        // 4 Cases for imageDragging + fileDragging extensons:
        //
        // 1. ImageDragging ON + No Custom Image Dragging Extension:
        //    * Use fileDragging extension (default options)
        // 2. ImageDragging OFF + No Custom Image Dragging Extension:
        //    * Use fileDragging extension w/ images turned off
        // 3. ImageDragging ON + Custom Image Dragging Extension:
        //    * Don't use fileDragging (could interfere with custom image dragging extension)
        // 4. ImageDragging OFF + Custom Image Dragging:
        //    * Don't use fileDragging (could interfere with custom image dragging extension)
        if (shouldUseFileDraggingExtension.call(this)) {
            var opts = this.options.fileDragging;
            if (!opts) {
                opts = {};

                // Image is in the 'allowedTypes' list by default.
                // If imageDragging is off override the 'allowedTypes' list with an empty one
                if (!isImageDraggingEnabled.call(this)) {
                    opts.allowedTypes = [];
                }
            }
            this.addBuiltInExtension('fileDragging', opts);
        }

        // Built-in extensions
        var builtIns = {
            paste: true,
            'anchor-preview': isAnchorPreviewEnabled.call(this),
            autoLink: isAutoLinkEnabled.call(this),
            keyboardCommands: isKeyboardCommandsEnabled.call(this),
            placeholder: isPlaceholderEnabled.call(this)
        };
        Object.keys(builtIns).forEach(function (name) {
            if (builtIns[name]) {
                this.addBuiltInExtension(name);
            }
        }, this);

        // Users can pass in a custom toolbar extension
        // so check for that first and if it's not present
        // just create the default toolbar
        var toolbarExtension = this.options.extensions['toolbar'];
        if (!toolbarExtension && isToolbarEnabled.call(this)) {
            // Backwards compatability
            var toolbarOptions = MediumEditor.util.extend({}, this.options.toolbar, {
                allowMultiParagraphSelection: this.options.allowMultiParagraphSelection // deprecated
            });
            toolbarExtension = new MediumEditor.extensions.toolbar(toolbarOptions);
        }

        // If the toolbar is not disabled, so we actually have an extension
        // initialize it and add it to the extensions array
        if (toolbarExtension) {
            this.extensions.push(initExtension(toolbarExtension, 'toolbar', this));
        }
    }

    function mergeOptions(defaults, options) {
        var deprecatedProperties = [
            ['allowMultiParagraphSelection', 'toolbar.allowMultiParagraphSelection']
        ];
        // warn about using deprecated properties
        if (options) {
            deprecatedProperties.forEach(function (pair) {
                if (options.hasOwnProperty(pair[0]) && options[pair[0]] !== undefined) {
                    MediumEditor.util.deprecated(pair[0], pair[1], 'v6.0.0');
                }
            });
        }

        return MediumEditor.util.defaults({}, options, defaults);
    }

    function execActionInternal(action, opts) {
        /*jslint regexp: true*/
        var appendAction = /^append-(.+)$/gi,
            justifyAction = /justify([A-Za-z]*)$/g, /* Detecting if is justifyCenter|Right|Left */
            match;
        /*jslint regexp: false*/

        // Actions starting with 'append-' should attempt to format a block of text ('formatBlock') using a specific
        // type of block element (ie append-blockquote, append-h1, append-pre, etc.)
        match = appendAction.exec(action);
        if (match) {
            return MediumEditor.util.execFormatBlock(this.options.ownerDocument, match[1]);
        }

        if (action === 'fontSize') {
            return this.options.ownerDocument.execCommand('fontSize', false, opts.size);
        }

        if (action === 'fontName') {
            return this.options.ownerDocument.execCommand('fontName', false, opts.name);
        }

        if (action === 'createLink') {
            return this.createLink(opts);
        }

        if (action === 'image') {
            var src = this.options.contentWindow.getSelection().toString().trim();
            return this.options.ownerDocument.execCommand('insertImage', false, src);
        }

        /* Issue: https://github.com/yabwe/medium-editor/issues/595
         * If the action is to justify the text */
        if (justifyAction.exec(action)) {
            var result = this.options.ownerDocument.execCommand(action, false, null),
                parentNode = MediumEditor.selection.getSelectedParentElement(MediumEditor.selection.getSelectionRange(this.options.ownerDocument));
            if (parentNode) {
                cleanupJustifyDivFragments.call(this, MediumEditor.util.getTopBlockContainer(parentNode));
            }

            return result;
        }

        return this.options.ownerDocument.execCommand(action, false, null);
    }

    /* If we've just justified text within a container block
     * Chrome may have removed <br> elements and instead wrapped lines in <div> elements
     * with a text-align property.  If so, we want to fix this
     */
    function cleanupJustifyDivFragments(blockContainer) {
        if (!blockContainer) {
            return;
        }

        var textAlign,
            childDivs = Array.prototype.slice.call(blockContainer.childNodes).filter(function (element) {
                var isDiv = element.nodeName.toLowerCase() === 'div';
                if (isDiv && !textAlign) {
                    textAlign = element.style.textAlign;
                }
                return isDiv;
            });

        /* If we found child <div> elements with text-align style attributes
         * we should fix this by:
         *
         * 1) Unwrapping each <div> which has a text-align style
         * 2) Insert a <br> element after each set of 'unwrapped' div children
         * 3) Set the text-align style of the parent block element
         */
        if (childDivs.length) {
            // Since we're mucking with the HTML, preserve selection
            this.saveSelection();
            childDivs.forEach(function (div) {
                if (div.style.textAlign === textAlign) {
                    var lastChild = div.lastChild;
                    if (lastChild) {
                        // Instead of a div, extract the child elements and add a <br>
                        MediumEditor.util.unwrap(div, this.options.ownerDocument);
                        var br = this.options.ownerDocument.createElement('BR');
                        lastChild.parentNode.insertBefore(br, lastChild.nextSibling);
                    }
                }
            }, this);
            blockContainer.style.textAlign = textAlign;
            // We're done, so restore selection
            this.restoreSelection();
        }
    }

    MediumEditor.prototype = {
        // NOT DOCUMENTED - exposed for backwards compatability
        init: function (elements, options) {
            this.options = mergeOptions.call(this, this.defaults, options);
            this.origElements = elements;

            if (!this.options.elementsContainer) {
                this.options.elementsContainer = this.options.ownerDocument.body;
            }

            return this.setup();
        },

        setup: function () {
            if (this.isActive) {
                return;
            }

            createElementsArray.call(this, this.origElements);

            if (this.elements.length === 0) {
                return;
            }

            this.isActive = true;
            addToEditors.call(this, this.options.contentWindow);

            this.events = new MediumEditor.Events(this);

            // Call initialization helpers
            initElements.call(this);
            initExtensions.call(this);
            attachHandlers.call(this);
        },

        destroy: function () {
            if (!this.isActive) {
                return;
            }

            this.isActive = false;

            this.extensions.forEach(function (extension) {
                if (typeof extension.destroy === 'function') {
                    extension.destroy();
                }
            }, this);

            this.events.destroy();

            this.elements.forEach(function (element) {
                // Reset elements content, fix for issue where after editor destroyed the red underlines on spelling errors are left
                if (this.options.spellcheck) {
                    element.innerHTML = element.innerHTML;
                }

                // cleanup extra added attributes
                element.removeAttribute('contentEditable');
                element.removeAttribute('spellcheck');
                element.removeAttribute('data-medium-editor-element');
                element.removeAttribute('role');
                element.removeAttribute('aria-multiline');
                element.removeAttribute('medium-editor-index');

                // Remove any elements created for textareas
                if (element.hasAttribute('medium-editor-textarea-id')) {
                    var textarea = element.parentNode.querySelector('textarea[medium-editor-textarea-id="' + element.getAttribute('medium-editor-textarea-id') + '"]');
                    if (textarea) {
                        // Un-hide the textarea
                        textarea.classList.remove('medium-editor-hidden');
                    }
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                }
            }, this);
            this.elements = [];

            removeFromEditors.call(this, this.options.contentWindow);
        },

        on: function (target, event, listener, useCapture) {
            this.events.attachDOMEvent(target, event, listener, useCapture);
        },

        off: function (target, event, listener, useCapture) {
            this.events.detachDOMEvent(target, event, listener, useCapture);
        },

        subscribe: function (event, listener) {
            this.events.attachCustomEvent(event, listener);
        },

        unsubscribe: function (event, listener) {
            this.events.detachCustomEvent(event, listener);
        },

        trigger: function (name, data, editable) {
            this.events.triggerCustomEvent(name, data, editable);
        },

        delay: function (fn) {
            var self = this;
            return setTimeout(function () {
                if (self.isActive) {
                    fn();
                }
            }, this.options.delay);
        },

        serialize: function () {
            var i,
                elementid,
                content = {};
            for (i = 0; i < this.elements.length; i += 1) {
                elementid = (this.elements[i].id !== '') ? this.elements[i].id : 'element-' + i;
                content[elementid] = {
                    value: this.elements[i].innerHTML.trim()
                };
            }
            return content;
        },

        getExtensionByName: function (name) {
            var extension;
            if (this.extensions && this.extensions.length) {
                this.extensions.some(function (ext) {
                    if (ext.name === name) {
                        extension = ext;
                        return true;
                    }
                    return false;
                });
            }
            return extension;
        },

        /**
         * NOT DOCUMENTED - exposed as a helper for other extensions to use
         */
        addBuiltInExtension: function (name, opts) {
            var extension = this.getExtensionByName(name),
                merged;
            if (extension) {
                return extension;
            }

            switch (name) {
                case 'anchor':
                    merged = MediumEditor.util.extend({}, this.options.anchor, opts);
                    extension = new MediumEditor.extensions.anchor(merged);
                    break;
                case 'anchor-preview':
                    extension = new MediumEditor.extensions.anchorPreview(this.options.anchorPreview);
                    break;
                case 'autoLink':
                    extension = new MediumEditor.extensions.autoLink();
                    break;
                case 'fileDragging':
                    extension = new MediumEditor.extensions.fileDragging(opts);
                    break;
                case 'fontname':
                    extension = new MediumEditor.extensions.fontName(this.options.fontName);
                    break;
                case 'fontsize':
                    extension = new MediumEditor.extensions.fontSize(opts);
                    break;
                case 'keyboardCommands':
                    extension = new MediumEditor.extensions.keyboardCommands(this.options.keyboardCommands);
                    break;
                case 'paste':
                    extension = new MediumEditor.extensions.paste(this.options.paste);
                    break;
                case 'placeholder':
                    extension = new MediumEditor.extensions.placeholder(this.options.placeholder);
                    break;
                default:
                    // All of the built-in buttons for MediumEditor are extensions
                    // so check to see if the extension we're creating is a built-in button
                    if (MediumEditor.extensions.button.isBuiltInButton(name)) {
                        if (opts) {
                            merged = MediumEditor.util.defaults({}, opts, MediumEditor.extensions.button.prototype.defaults[name]);
                            extension = new MediumEditor.extensions.button(merged);
                        } else {
                            extension = new MediumEditor.extensions.button(name);
                        }
                    }
            }

            if (extension) {
                this.extensions.push(initExtension(extension, name, this));
            }

            return extension;
        },

        stopSelectionUpdates: function () {
            this.preventSelectionUpdates = true;
        },

        startSelectionUpdates: function () {
            this.preventSelectionUpdates = false;
        },

        checkSelection: function () {
            var toolbar = this.getExtensionByName('toolbar');
            if (toolbar) {
                toolbar.checkState();
            }
            return this;
        },

        // Wrapper around document.queryCommandState for checking whether an action has already
        // been applied to the current selection
        queryCommandState: function (action) {
            var fullAction = /^full-(.+)$/gi,
                match,
                queryState = null;

            // Actions starting with 'full-' need to be modified since this is a medium-editor concept
            match = fullAction.exec(action);
            if (match) {
                action = match[1];
            }

            try {
                queryState = this.options.ownerDocument.queryCommandState(action);
            } catch (exc) {
                queryState = null;
            }

            return queryState;
        },

        execAction: function (action, opts) {
            /*jslint regexp: true*/
            var fullAction = /^full-(.+)$/gi,
                match,
                result;
            /*jslint regexp: false*/

            // Actions starting with 'full-' should be applied to to the entire contents of the editable element
            // (ie full-bold, full-append-pre, etc.)
            match = fullAction.exec(action);
            if (match) {
                // Store the current selection to be restored after applying the action
                this.saveSelection();
                // Select all of the contents before calling the action
                this.selectAllContents();
                result = execActionInternal.call(this, match[1], opts);
                // Restore the previous selection
                this.restoreSelection();
            } else {
                result = execActionInternal.call(this, action, opts);
            }

            // do some DOM clean-up for known browser issues after the action
            if (action === 'insertunorderedlist' || action === 'insertorderedlist') {
                MediumEditor.util.cleanListDOM(this.options.ownerDocument, this.getSelectedParentElement());
            }

            this.checkSelection();
            return result;
        },

        getSelectedParentElement: function (range) {
            if (range === undefined) {
                range = this.options.contentWindow.getSelection().getRangeAt(0);
            }
            return MediumEditor.selection.getSelectedParentElement(range);
        },

        selectAllContents: function () {
            var currNode = MediumEditor.selection.getSelectionElement(this.options.contentWindow);

            if (currNode) {
                // Move to the lowest descendant node that still selects all of the contents
                while (currNode.children.length === 1) {
                    currNode = currNode.children[0];
                }

                this.selectElement(currNode);
            }
        },

        selectElement: function (element) {
            MediumEditor.selection.selectNode(element, this.options.ownerDocument);

            var selElement = MediumEditor.selection.getSelectionElement(this.options.contentWindow);
            if (selElement) {
                this.events.focusElement(selElement);
            }
        },

        getFocusedElement: function () {
            var focused;
            this.elements.some(function (element) {
                // Find the element that has focus
                if (!focused && element.getAttribute('data-medium-focused')) {
                    focused = element;
                }

                // bail if we found the element that had focus
                return !!focused;
            }, this);

            return focused;
        },

        // Export the state of the selection in respect to one of this
        // instance of MediumEditor's elements
        exportSelection: function () {
            var selectionElement = MediumEditor.selection.getSelectionElement(this.options.contentWindow),
                editableElementIndex = this.elements.indexOf(selectionElement),
                selectionState = null;

            if (editableElementIndex >= 0) {
                selectionState = MediumEditor.selection.exportSelection(selectionElement, this.options.ownerDocument);
            }

            if (selectionState !== null && editableElementIndex !== 0) {
                selectionState.editableElementIndex = editableElementIndex;
            }

            return selectionState;
        },

        saveSelection: function () {
            this.selectionState = this.exportSelection();
        },

        // Restore a selection based on a selectionState returned by a call
        // to MediumEditor.exportSelection
        importSelection: function (selectionState, favorLaterSelectionAnchor) {
            if (!selectionState) {
                return;
            }

            var editableElement = this.elements[selectionState.editableElementIndex || 0];
            MediumEditor.selection.importSelection(selectionState, editableElement, this.options.ownerDocument, favorLaterSelectionAnchor);
        },

        restoreSelection: function () {
            this.importSelection(this.selectionState);
        },

        createLink: function (opts) {
            var currentEditor = MediumEditor.selection.getSelectionElement(this.options.contentWindow),
                customEvent = {};

            // Make sure the selection is within an element this editor is tracking
            if (this.elements.indexOf(currentEditor) === -1) {
                return;
            }

            try {
                this.events.disableCustomEvent('editableInput');
                if (opts.url && opts.url.trim().length > 0) {
                    var currentSelection = this.options.contentWindow.getSelection();
                    if (currentSelection) {
                        var currRange = currentSelection.getRangeAt(0),
                            commonAncestorContainer = currRange.commonAncestorContainer,
                            exportedSelection,
                            startContainerParentElement,
                            endContainerParentElement,
                            textNodes;

                        // If the selection is contained within a single text node
                        // and the selection starts at the beginning of the text node,
                        // MSIE still says the startContainer is the parent of the text node.
                        // If the selection is contained within a single text node, we
                        // want to just use the default browser 'createLink', so we need
                        // to account for this case and adjust the commonAncestorContainer accordingly
                        if (currRange.endContainer.nodeType === 3 &&
                            currRange.startContainer.nodeType !== 3 &&
                            currRange.startOffset === 0 &&
                            currRange.startContainer.firstChild === currRange.endContainer) {
                            commonAncestorContainer = currRange.endContainer;
                        }

                        startContainerParentElement = MediumEditor.util.getClosestBlockContainer(currRange.startContainer);
                        endContainerParentElement = MediumEditor.util.getClosestBlockContainer(currRange.endContainer);

                        // If the selection is not contained within a single text node
                        // but the selection is contained within the same block element
                        // we want to make sure we create a single link, and not multiple links
                        // which can happen with the built in browser functionality
                        if (commonAncestorContainer.nodeType !== 3 && commonAncestorContainer.textContent.length !== 0 && startContainerParentElement === endContainerParentElement) {
                            var parentElement = (startContainerParentElement || currentEditor),
                                fragment = this.options.ownerDocument.createDocumentFragment();

                            // since we are going to create a link from an extracted text,
                            // be sure that if we are updating a link, we won't let an empty link behind (see #754)
                            // (Workaroung for Chrome)
                            this.execAction('unlink');

                            exportedSelection = this.exportSelection();
                            fragment.appendChild(parentElement.cloneNode(true));

                            if (currentEditor === parentElement) {
                                // We have to avoid the editor itself being wiped out when it's the only block element,
                                // as our reference inside this.elements gets detached from the page when insertHTML runs.
                                // If we just use [parentElement, 0] and [parentElement, parentElement.childNodes.length]
                                // as the range boundaries, this happens whenever parentElement === currentEditor.
                                // The tradeoff to this workaround is that a orphaned tag can sometimes be left behind at
                                // the end of the editor's content.
                                // In Gecko:
                                // as an empty <strong></strong> if parentElement.lastChild is a <strong> tag.
                                // In WebKit:
                                // an invented <br /> tag at the end in the same situation
                                MediumEditor.selection.select(
                                    this.options.ownerDocument,
                                    parentElement.firstChild,
                                    0,
                                    parentElement.lastChild,
                                    parentElement.lastChild.nodeType === 3 ?
                                    parentElement.lastChild.nodeValue.length : parentElement.lastChild.childNodes.length
                                );
                            } else {
                                MediumEditor.selection.select(
                                    this.options.ownerDocument,
                                    parentElement,
                                    0,
                                    parentElement,
                                    parentElement.childNodes.length
                                );
                            }

                            var modifiedExportedSelection = this.exportSelection();

                            textNodes = MediumEditor.util.findOrCreateMatchingTextNodes(
                                this.options.ownerDocument,
                                fragment,
                                {
                                    start: exportedSelection.start - modifiedExportedSelection.start,
                                    end: exportedSelection.end - modifiedExportedSelection.start,
                                    editableElementIndex: exportedSelection.editableElementIndex
                                }
                            );
                            // If textNodes are not present, when changing link on images
                            // ex: <a><img src="http://image.test.com"></a>, change fragment to currRange.startContainer
                            // and set textNodes array to [imageElement, imageElement]
                            if (textNodes.length === 0) {
                                fragment = this.options.ownerDocument.createDocumentFragment();
                                fragment.appendChild(commonAncestorContainer.cloneNode(true));
                                textNodes = [fragment.firstChild.firstChild, fragment.firstChild.lastChild];
                            }

                            // Creates the link in the document fragment
                            MediumEditor.util.createLink(this.options.ownerDocument, textNodes, opts.url.trim());

                            // Chrome trims the leading whitespaces when inserting HTML, which messes up restoring the selection.
                            var leadingWhitespacesCount = (fragment.firstChild.innerHTML.match(/^\s+/) || [''])[0].length;

                            // Now move the created link back into the original document in a way to preserve undo/redo history
                            MediumEditor.util.insertHTMLCommand(this.options.ownerDocument, fragment.firstChild.innerHTML.replace(/^\s+/, ''));
                            exportedSelection.start -= leadingWhitespacesCount;
                            exportedSelection.end -= leadingWhitespacesCount;

                            this.importSelection(exportedSelection);
                        } else {
                            this.options.ownerDocument.execCommand('createLink', false, opts.url);
                        }

                        if (this.options.targetBlank || opts.target === '_blank') {
                            MediumEditor.util.setTargetBlank(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), opts.url);
                        } else {
                            MediumEditor.util.removeTargetBlank(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), opts.url);
                        }

                        if (opts.buttonClass) {
                            MediumEditor.util.addClassToAnchors(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), opts.buttonClass);
                        }
                    }
                }
                // Fire input event for backwards compatibility if anyone was listening directly to the DOM input event
                if (this.options.targetBlank || opts.target === '_blank' || opts.buttonClass) {
                    customEvent = this.options.ownerDocument.createEvent('HTMLEvents');
                    customEvent.initEvent('input', true, true, this.options.contentWindow);
                    for (var i = 0; i < this.elements.length; i += 1) {
                        this.elements[i].dispatchEvent(customEvent);
                    }
                }
            } finally {
                this.events.enableCustomEvent('editableInput');
            }
            // Fire our custom editableInput event
            this.events.triggerCustomEvent('editableInput', customEvent, currentEditor);
        },

        cleanPaste: function (text) {
            this.getExtensionByName('paste').cleanPaste(text);
        },

        pasteHTML: function (html, options) {
            this.getExtensionByName('paste').pasteHTML(html, options);
        },

        setContent: function (html, index) {
            index = index || 0;

            if (this.elements[index]) {
                var target = this.elements[index];
                target.innerHTML = html;
                this.events.updateInput(target, { target: target, currentTarget: target });
            }
        }
    };
}());

(function () {
    // summary: The default options hash used by the Editor

    MediumEditor.prototype.defaults = {
        activeButtonClass: 'medium-editor-button-active',
        buttonLabels: false,
        delay: 0,
        disableReturn: false,
        disableDoubleReturn: false,
        disableExtraSpaces: false,
        disableEditing: false,
        autoLink: false,
        elementsContainer: false,
        contentWindow: window,
        ownerDocument: document,
        targetBlank: false,
        extensions: {},
        spellcheck: true
    };
})();

MediumEditor.parseVersionString = function (release) {
    var split = release.split('-'),
        version = split[0].split('.'),
        preRelease = (split.length > 1) ? split[1] : '';
    return {
        major: parseInt(version[0], 10),
        minor: parseInt(version[1], 10),
        revision: parseInt(version[2], 10),
        preRelease: preRelease,
        toString: function () {
            return [version[0], version[1], version[2]].join('.') + (preRelease ? '-' + preRelease : '');
        }
    };
};

MediumEditor.version = MediumEditor.parseVersionString.call(this, ({
    // grunt-bump looks for this:
    'version': '5.15.0'
}).version);

    return MediumEditor;
}()));

},{}],14:[function(require,module,exports){
/**
 * Class Applier module for Rangy.
 * Adds, removes and toggles classes on Ranges and Selections
 *
 * Part of Rangy, a cross-browser JavaScript range and selection library
 * https://github.com/timdown/rangy
 *
 * Depends on Rangy core.
 *
 * Copyright 2015, Tim Down
 * Licensed under the MIT license.
 * Version: 1.3.0
 * Build date: 10 May 2015
 */
(function(factory, root) {
    if (typeof define == "function" && define.amd) {
        // AMD. Register as an anonymous module with a dependency on Rangy.
        define(["./rangy-core"], factory);
    } else if (typeof module != "undefined" && typeof exports == "object") {
        // Node/CommonJS style
        module.exports = factory( require("rangy") );
    } else {
        // No AMD or CommonJS support so we use the rangy property of root (probably the global variable)
        factory(root.rangy);
    }
})(function(rangy) {
    rangy.createModule("ClassApplier", ["WrappedSelection"], function(api, module) {
        var dom = api.dom;
        var DomPosition = dom.DomPosition;
        var contains = dom.arrayContains;
        var util = api.util;
        var forEach = util.forEach;


        var defaultTagName = "span";
        var createElementNSSupported = util.isHostMethod(document, "createElementNS");

        function each(obj, func) {
            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    if (func(i, obj[i]) === false) {
                        return false;
                    }
                }
            }
            return true;
        }

        function trim(str) {
            return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }

        function classNameContainsClass(fullClassName, className) {
            return !!fullClassName && new RegExp("(?:^|\\s)" + className + "(?:\\s|$)").test(fullClassName);
        }

        // Inefficient, inelegant nonsense for IE's svg element, which has no classList and non-HTML className implementation
        function hasClass(el, className) {
            if (typeof el.classList == "object") {
                return el.classList.contains(className);
            } else {
                var classNameSupported = (typeof el.className == "string");
                var elClass = classNameSupported ? el.className : el.getAttribute("class");
                return classNameContainsClass(elClass, className);
            }
        }

        function addClass(el, className) {
            if (typeof el.classList == "object") {
                el.classList.add(className);
            } else {
                var classNameSupported = (typeof el.className == "string");
                var elClass = classNameSupported ? el.className : el.getAttribute("class");
                if (elClass) {
                    if (!classNameContainsClass(elClass, className)) {
                        elClass += " " + className;
                    }
                } else {
                    elClass = className;
                }
                if (classNameSupported) {
                    el.className = elClass;
                } else {
                    el.setAttribute("class", elClass);
                }
            }
        }

        var removeClass = (function() {
            function replacer(matched, whiteSpaceBefore, whiteSpaceAfter) {
                return (whiteSpaceBefore && whiteSpaceAfter) ? " " : "";
            }

            return function(el, className) {
                if (typeof el.classList == "object") {
                    el.classList.remove(className);
                } else {
                    var classNameSupported = (typeof el.className == "string");
                    var elClass = classNameSupported ? el.className : el.getAttribute("class");
                    elClass = elClass.replace(new RegExp("(^|\\s)" + className + "(\\s|$)"), replacer);
                    if (classNameSupported) {
                        el.className = elClass;
                    } else {
                        el.setAttribute("class", elClass);
                    }
                }
            };
        })();

        function getClass(el) {
            var classNameSupported = (typeof el.className == "string");
            return classNameSupported ? el.className : el.getAttribute("class");
        }

        function sortClassName(className) {
            return className && className.split(/\s+/).sort().join(" ");
        }

        function getSortedClassName(el) {
            return sortClassName( getClass(el) );
        }

        function haveSameClasses(el1, el2) {
            return getSortedClassName(el1) == getSortedClassName(el2);
        }

        function hasAllClasses(el, className) {
            var classes = className.split(/\s+/);
            for (var i = 0, len = classes.length; i < len; ++i) {
                if (!hasClass(el, trim(classes[i]))) {
                    return false;
                }
            }
            return true;
        }

        function canTextBeStyled(textNode) {
            var parent = textNode.parentNode;
            return (parent && parent.nodeType == 1 && !/^(textarea|style|script|select|iframe)$/i.test(parent.nodeName));
        }

        function movePosition(position, oldParent, oldIndex, newParent, newIndex) {
            var posNode = position.node, posOffset = position.offset;
            var newNode = posNode, newOffset = posOffset;

            if (posNode == newParent && posOffset > newIndex) {
                ++newOffset;
            }

            if (posNode == oldParent && (posOffset == oldIndex  || posOffset == oldIndex + 1)) {
                newNode = newParent;
                newOffset += newIndex - oldIndex;
            }

            if (posNode == oldParent && posOffset > oldIndex + 1) {
                --newOffset;
            }

            position.node = newNode;
            position.offset = newOffset;
        }

        function movePositionWhenRemovingNode(position, parentNode, index) {
            if (position.node == parentNode && position.offset > index) {
                --position.offset;
            }
        }

        function movePreservingPositions(node, newParent, newIndex, positionsToPreserve) {
            // For convenience, allow newIndex to be -1 to mean "insert at the end".
            if (newIndex == -1) {
                newIndex = newParent.childNodes.length;
            }

            var oldParent = node.parentNode;
            var oldIndex = dom.getNodeIndex(node);

            forEach(positionsToPreserve, function(position) {
                movePosition(position, oldParent, oldIndex, newParent, newIndex);
            });

            // Now actually move the node.
            if (newParent.childNodes.length == newIndex) {
                newParent.appendChild(node);
            } else {
                newParent.insertBefore(node, newParent.childNodes[newIndex]);
            }
        }

        function removePreservingPositions(node, positionsToPreserve) {

            var oldParent = node.parentNode;
            var oldIndex = dom.getNodeIndex(node);

            forEach(positionsToPreserve, function(position) {
                movePositionWhenRemovingNode(position, oldParent, oldIndex);
            });

            dom.removeNode(node);
        }

        function moveChildrenPreservingPositions(node, newParent, newIndex, removeNode, positionsToPreserve) {
            var child, children = [];
            while ( (child = node.firstChild) ) {
                movePreservingPositions(child, newParent, newIndex++, positionsToPreserve);
                children.push(child);
            }
            if (removeNode) {
                removePreservingPositions(node, positionsToPreserve);
            }
            return children;
        }

        function replaceWithOwnChildrenPreservingPositions(element, positionsToPreserve) {
            return moveChildrenPreservingPositions(element, element.parentNode, dom.getNodeIndex(element), true, positionsToPreserve);
        }

        function rangeSelectsAnyText(range, textNode) {
            var textNodeRange = range.cloneRange();
            textNodeRange.selectNodeContents(textNode);

            var intersectionRange = textNodeRange.intersection(range);
            var text = intersectionRange ? intersectionRange.toString() : "";

            return text != "";
        }

        function getEffectiveTextNodes(range) {
            var nodes = range.getNodes([3]);

            // Optimization as per issue 145

            // Remove non-intersecting text nodes from the start of the range
            var start = 0, node;
            while ( (node = nodes[start]) && !rangeSelectsAnyText(range, node) ) {
                ++start;
            }

            // Remove non-intersecting text nodes from the start of the range
            var end = nodes.length - 1;
            while ( (node = nodes[end]) && !rangeSelectsAnyText(range, node) ) {
                --end;
            }

            return nodes.slice(start, end + 1);
        }

        function elementsHaveSameNonClassAttributes(el1, el2) {
            if (el1.attributes.length != el2.attributes.length) return false;
            for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {
                attr1 = el1.attributes[i];
                name = attr1.name;
                if (name != "class") {
                    attr2 = el2.attributes.getNamedItem(name);
                    if ( (attr1 === null) != (attr2 === null) ) return false;
                    if (attr1.specified != attr2.specified) return false;
                    if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) return false;
                }
            }
            return true;
        }

        function elementHasNonClassAttributes(el, exceptions) {
            for (var i = 0, len = el.attributes.length, attrName; i < len; ++i) {
                attrName = el.attributes[i].name;
                if ( !(exceptions && contains(exceptions, attrName)) && el.attributes[i].specified && attrName != "class") {
                    return true;
                }
            }
            return false;
        }

        var getComputedStyleProperty = dom.getComputedStyleProperty;
        var isEditableElement = (function() {
            var testEl = document.createElement("div");
            return typeof testEl.isContentEditable == "boolean" ?
                function (node) {
                    return node && node.nodeType == 1 && node.isContentEditable;
                } :
                function (node) {
                    if (!node || node.nodeType != 1 || node.contentEditable == "false") {
                        return false;
                    }
                    return node.contentEditable == "true" || isEditableElement(node.parentNode);
                };
        })();

        function isEditingHost(node) {
            var parent;
            return node && node.nodeType == 1 &&
                (( (parent = node.parentNode) && parent.nodeType == 9 && parent.designMode == "on") ||
                (isEditableElement(node) && !isEditableElement(node.parentNode)));
        }

        function isEditable(node) {
            return (isEditableElement(node) || (node.nodeType != 1 && isEditableElement(node.parentNode))) && !isEditingHost(node);
        }

        var inlineDisplayRegex = /^inline(-block|-table)?$/i;

        function isNonInlineElement(node) {
            return node && node.nodeType == 1 && !inlineDisplayRegex.test(getComputedStyleProperty(node, "display"));
        }

        // White space characters as defined by HTML 4 (http://www.w3.org/TR/html401/struct/text.html)
        var htmlNonWhiteSpaceRegex = /[^\r\n\t\f \u200B]/;

        function isUnrenderedWhiteSpaceNode(node) {
            if (node.data.length == 0) {
                return true;
            }
            if (htmlNonWhiteSpaceRegex.test(node.data)) {
                return false;
            }
            var cssWhiteSpace = getComputedStyleProperty(node.parentNode, "whiteSpace");
            switch (cssWhiteSpace) {
                case "pre":
                case "pre-wrap":
                case "-moz-pre-wrap":
                    return false;
                case "pre-line":
                    if (/[\r\n]/.test(node.data)) {
                        return false;
                    }
            }

            // We now have a whitespace-only text node that may be rendered depending on its context. If it is adjacent to a
            // non-inline element, it will not be rendered. This seems to be a good enough definition.
            return isNonInlineElement(node.previousSibling) || isNonInlineElement(node.nextSibling);
        }

        function getRangeBoundaries(ranges) {
            var positions = [], i, range;
            for (i = 0; range = ranges[i++]; ) {
                positions.push(
                    new DomPosition(range.startContainer, range.startOffset),
                    new DomPosition(range.endContainer, range.endOffset)
                );
            }
            return positions;
        }

        function updateRangesFromBoundaries(ranges, positions) {
            for (var i = 0, range, start, end, len = ranges.length; i < len; ++i) {
                range = ranges[i];
                start = positions[i * 2];
                end = positions[i * 2 + 1];
                range.setStartAndEnd(start.node, start.offset, end.node, end.offset);
            }
        }

        function isSplitPoint(node, offset) {
            if (dom.isCharacterDataNode(node)) {
                if (offset == 0) {
                    return !!node.previousSibling;
                } else if (offset == node.length) {
                    return !!node.nextSibling;
                } else {
                    return true;
                }
            }

            return offset > 0 && offset < node.childNodes.length;
        }

        function splitNodeAt(node, descendantNode, descendantOffset, positionsToPreserve) {
            var newNode, parentNode;
            var splitAtStart = (descendantOffset == 0);

            if (dom.isAncestorOf(descendantNode, node)) {
                return node;
            }

            if (dom.isCharacterDataNode(descendantNode)) {
                var descendantIndex = dom.getNodeIndex(descendantNode);
                if (descendantOffset == 0) {
                    descendantOffset = descendantIndex;
                } else if (descendantOffset == descendantNode.length) {
                    descendantOffset = descendantIndex + 1;
                } else {
                    throw module.createError("splitNodeAt() should not be called with offset in the middle of a data node (" +
                        descendantOffset + " in " + descendantNode.data);
                }
                descendantNode = descendantNode.parentNode;
            }

            if (isSplitPoint(descendantNode, descendantOffset)) {
                // descendantNode is now guaranteed not to be a text or other character node
                newNode = descendantNode.cloneNode(false);
                parentNode = descendantNode.parentNode;
                if (newNode.id) {
                    newNode.removeAttribute("id");
                }
                var child, newChildIndex = 0;

                while ( (child = descendantNode.childNodes[descendantOffset]) ) {
                    movePreservingPositions(child, newNode, newChildIndex++, positionsToPreserve);
                }
                movePreservingPositions(newNode, parentNode, dom.getNodeIndex(descendantNode) + 1, positionsToPreserve);
                return (descendantNode == node) ? newNode : splitNodeAt(node, parentNode, dom.getNodeIndex(newNode), positionsToPreserve);
            } else if (node != descendantNode) {
                newNode = descendantNode.parentNode;

                // Work out a new split point in the parent node
                var newNodeIndex = dom.getNodeIndex(descendantNode);

                if (!splitAtStart) {
                    newNodeIndex++;
                }
                return splitNodeAt(node, newNode, newNodeIndex, positionsToPreserve);
            }
            return node;
        }

        function areElementsMergeable(el1, el2) {
            return el1.namespaceURI == el2.namespaceURI &&
                el1.tagName.toLowerCase() == el2.tagName.toLowerCase() &&
                haveSameClasses(el1, el2) &&
                elementsHaveSameNonClassAttributes(el1, el2) &&
                getComputedStyleProperty(el1, "display") == "inline" &&
                getComputedStyleProperty(el2, "display") == "inline";
        }

        function createAdjacentMergeableTextNodeGetter(forward) {
            var siblingPropName = forward ? "nextSibling" : "previousSibling";

            return function(textNode, checkParentElement) {
                var el = textNode.parentNode;
                var adjacentNode = textNode[siblingPropName];
                if (adjacentNode) {
                    // Can merge if the node's previous/next sibling is a text node
                    if (adjacentNode && adjacentNode.nodeType == 3) {
                        return adjacentNode;
                    }
                } else if (checkParentElement) {
                    // Compare text node parent element with its sibling
                    adjacentNode = el[siblingPropName];
                    if (adjacentNode && adjacentNode.nodeType == 1 && areElementsMergeable(el, adjacentNode)) {
                        var adjacentNodeChild = adjacentNode[forward ? "firstChild" : "lastChild"];
                        if (adjacentNodeChild && adjacentNodeChild.nodeType == 3) {
                            return adjacentNodeChild;
                        }
                    }
                }
                return null;
            };
        }

        var getPreviousMergeableTextNode = createAdjacentMergeableTextNodeGetter(false),
            getNextMergeableTextNode = createAdjacentMergeableTextNodeGetter(true);

    
        function Merge(firstNode) {
            this.isElementMerge = (firstNode.nodeType == 1);
            this.textNodes = [];
            var firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;
            if (firstTextNode) {
                this.textNodes[0] = firstTextNode;
            }
        }

        Merge.prototype = {
            doMerge: function(positionsToPreserve) {
                var textNodes = this.textNodes;
                var firstTextNode = textNodes[0];
                if (textNodes.length > 1) {
                    var firstTextNodeIndex = dom.getNodeIndex(firstTextNode);
                    var textParts = [], combinedTextLength = 0, textNode, parent;
                    forEach(textNodes, function(textNode, i) {
                        parent = textNode.parentNode;
                        if (i > 0) {
                            parent.removeChild(textNode);
                            if (!parent.hasChildNodes()) {
                                dom.removeNode(parent);
                            }
                            if (positionsToPreserve) {
                                forEach(positionsToPreserve, function(position) {
                                    // Handle case where position is inside the text node being merged into a preceding node
                                    if (position.node == textNode) {
                                        position.node = firstTextNode;
                                        position.offset += combinedTextLength;
                                    }
                                    // Handle case where both text nodes precede the position within the same parent node
                                    if (position.node == parent && position.offset > firstTextNodeIndex) {
                                        --position.offset;
                                        if (position.offset == firstTextNodeIndex + 1 && i < len - 1) {
                                            position.node = firstTextNode;
                                            position.offset = combinedTextLength;
                                        }
                                    }
                                });
                            }
                        }
                        textParts[i] = textNode.data;
                        combinedTextLength += textNode.data.length;
                    });
                    firstTextNode.data = textParts.join("");
                }
                return firstTextNode.data;
            },

            getLength: function() {
                var i = this.textNodes.length, len = 0;
                while (i--) {
                    len += this.textNodes[i].length;
                }
                return len;
            },

            toString: function() {
                var textParts = [];
                forEach(this.textNodes, function(textNode, i) {
                    textParts[i] = "'" + textNode.data + "'";
                });
                return "[Merge(" + textParts.join(",") + ")]";
            }
        };

        var optionProperties = ["elementTagName", "ignoreWhiteSpace", "applyToEditableOnly", "useExistingElements",
            "removeEmptyElements", "onElementCreate"];

        // TODO: Populate this with every attribute name that corresponds to a property with a different name. Really??
        var attrNamesForProperties = {};

        function ClassApplier(className, options, tagNames) {
            var normalize, i, len, propName, applier = this;
            applier.cssClass = applier.className = className; // cssClass property is for backward compatibility

            var elementPropertiesFromOptions = null, elementAttributes = {};

            // Initialize from options object
            if (typeof options == "object" && options !== null) {
                if (typeof options.elementTagName !== "undefined") {
                    options.elementTagName = options.elementTagName.toLowerCase();
                }
                tagNames = options.tagNames;
                elementPropertiesFromOptions = options.elementProperties;
                elementAttributes = options.elementAttributes;

                for (i = 0; propName = optionProperties[i++]; ) {
                    if (options.hasOwnProperty(propName)) {
                        applier[propName] = options[propName];
                    }
                }
                normalize = options.normalize;
            } else {
                normalize = options;
            }

            // Backward compatibility: the second parameter can also be a Boolean indicating to normalize after unapplying
            applier.normalize = (typeof normalize == "undefined") ? true : normalize;

            // Initialize element properties and attribute exceptions
            applier.attrExceptions = [];
            var el = document.createElement(applier.elementTagName);
            applier.elementProperties = applier.copyPropertiesToElement(elementPropertiesFromOptions, el, true);
            each(elementAttributes, function(attrName, attrValue) {
                applier.attrExceptions.push(attrName);
                // Ensure each attribute value is a string
                elementAttributes[attrName] = "" + attrValue;
            });
            applier.elementAttributes = elementAttributes;

            applier.elementSortedClassName = applier.elementProperties.hasOwnProperty("className") ?
                sortClassName(applier.elementProperties.className + " " + className) : className;

            // Initialize tag names
            applier.applyToAnyTagName = false;
            var type = typeof tagNames;
            if (type == "string") {
                if (tagNames == "*") {
                    applier.applyToAnyTagName = true;
                } else {
                    applier.tagNames = trim(tagNames.toLowerCase()).split(/\s*,\s*/);
                }
            } else if (type == "object" && typeof tagNames.length == "number") {
                applier.tagNames = [];
                for (i = 0, len = tagNames.length; i < len; ++i) {
                    if (tagNames[i] == "*") {
                        applier.applyToAnyTagName = true;
                    } else {
                        applier.tagNames.push(tagNames[i].toLowerCase());
                    }
                }
            } else {
                applier.tagNames = [applier.elementTagName];
            }
        }

        ClassApplier.prototype = {
            elementTagName: defaultTagName,
            elementProperties: {},
            elementAttributes: {},
            ignoreWhiteSpace: true,
            applyToEditableOnly: false,
            useExistingElements: true,
            removeEmptyElements: true,
            onElementCreate: null,

            copyPropertiesToElement: function(props, el, createCopy) {
                var s, elStyle, elProps = {}, elPropsStyle, propValue, elPropValue, attrName;

                for (var p in props) {
                    if (props.hasOwnProperty(p)) {
                        propValue = props[p];
                        elPropValue = el[p];

                        // Special case for class. The copied properties object has the applier's class as well as its own
                        // to simplify checks when removing styling elements
                        if (p == "className") {
                            addClass(el, propValue);
                            addClass(el, this.className);
                            el[p] = sortClassName(el[p]);
                            if (createCopy) {
                                elProps[p] = propValue;
                            }
                        }

                        // Special case for style
                        else if (p == "style") {
                            elStyle = elPropValue;
                            if (createCopy) {
                                elProps[p] = elPropsStyle = {};
                            }
                            for (s in props[p]) {
                                if (props[p].hasOwnProperty(s)) {
                                    elStyle[s] = propValue[s];
                                    if (createCopy) {
                                        elPropsStyle[s] = elStyle[s];
                                    }
                                }
                            }
                            this.attrExceptions.push(p);
                        } else {
                            el[p] = propValue;
                            // Copy the property back from the dummy element so that later comparisons to check whether
                            // elements may be removed are checking against the right value. For example, the href property
                            // of an element returns a fully qualified URL even if it was previously assigned a relative
                            // URL.
                            if (createCopy) {
                                elProps[p] = el[p];

                                // Not all properties map to identically-named attributes
                                attrName = attrNamesForProperties.hasOwnProperty(p) ? attrNamesForProperties[p] : p;
                                this.attrExceptions.push(attrName);
                            }
                        }
                    }
                }

                return createCopy ? elProps : "";
            },

            copyAttributesToElement: function(attrs, el) {
                for (var attrName in attrs) {
                    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {
                        el.setAttribute(attrName, attrs[attrName]);
                    }
                }
            },

            appliesToElement: function(el) {
                return contains(this.tagNames, el.tagName.toLowerCase());
            },

            getEmptyElements: function(range) {
                var applier = this;
                return range.getNodes([1], function(el) {
                    return applier.appliesToElement(el) && !el.hasChildNodes();
                });
            },

            hasClass: function(node) {
                return node.nodeType == 1 &&
                    (this.applyToAnyTagName || this.appliesToElement(node)) &&
                    hasClass(node, this.className);
            },

            getSelfOrAncestorWithClass: function(node) {
                while (node) {
                    if (this.hasClass(node)) {
                        return node;
                    }
                    node = node.parentNode;
                }
                return null;
            },

            isModifiable: function(node) {
                return !this.applyToEditableOnly || isEditable(node);
            },

            // White space adjacent to an unwrappable node can be ignored for wrapping
            isIgnorableWhiteSpaceNode: function(node) {
                return this.ignoreWhiteSpace && node && node.nodeType == 3 && isUnrenderedWhiteSpaceNode(node);
            },

            // Normalizes nodes after applying a class to a Range.
            postApply: function(textNodes, range, positionsToPreserve, isUndo) {
                var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];

                var merges = [], currentMerge;

                var rangeStartNode = firstNode, rangeEndNode = lastNode;
                var rangeStartOffset = 0, rangeEndOffset = lastNode.length;

                var textNode, precedingTextNode;

                // Check for every required merge and create a Merge object for each
                forEach(textNodes, function(textNode) {
                    precedingTextNode = getPreviousMergeableTextNode(textNode, !isUndo);
                    if (precedingTextNode) {
                        if (!currentMerge) {
                            currentMerge = new Merge(precedingTextNode);
                            merges.push(currentMerge);
                        }
                        currentMerge.textNodes.push(textNode);
                        if (textNode === firstNode) {
                            rangeStartNode = currentMerge.textNodes[0];
                            rangeStartOffset = rangeStartNode.length;
                        }
                        if (textNode === lastNode) {
                            rangeEndNode = currentMerge.textNodes[0];
                            rangeEndOffset = currentMerge.getLength();
                        }
                    } else {
                        currentMerge = null;
                    }
                });

                // Test whether the first node after the range needs merging
                var nextTextNode = getNextMergeableTextNode(lastNode, !isUndo);

                if (nextTextNode) {
                    if (!currentMerge) {
                        currentMerge = new Merge(lastNode);
                        merges.push(currentMerge);
                    }
                    currentMerge.textNodes.push(nextTextNode);
                }

                // Apply the merges
                if (merges.length) {
                    for (i = 0, len = merges.length; i < len; ++i) {
                        merges[i].doMerge(positionsToPreserve);
                    }

                    // Set the range boundaries
                    range.setStartAndEnd(rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);
                }
            },

            createContainer: function(parentNode) {
                var doc = dom.getDocument(parentNode);
                var namespace;
                var el = createElementNSSupported && !dom.isHtmlNamespace(parentNode) && (namespace = parentNode.namespaceURI) ?
                    doc.createElementNS(parentNode.namespaceURI, this.elementTagName) :
                    doc.createElement(this.elementTagName);

                this.copyPropertiesToElement(this.elementProperties, el, false);
                this.copyAttributesToElement(this.elementAttributes, el);
                addClass(el, this.className);
                if (this.onElementCreate) {
                    this.onElementCreate(el, this);
                }
                return el;
            },

            elementHasProperties: function(el, props) {
                var applier = this;
                return each(props, function(p, propValue) {
                    if (p == "className") {
                        // For checking whether we should reuse an existing element, we just want to check that the element
                        // has all the classes specified in the className property. When deciding whether the element is
                        // removable when unapplying a class, there is separate special handling to check whether the
                        // element has extra classes so the same simple check will do.
                        return hasAllClasses(el, propValue);
                    } else if (typeof propValue == "object") {
                        if (!applier.elementHasProperties(el[p], propValue)) {
                            return false;
                        }
                    } else if (el[p] !== propValue) {
                        return false;
                    }
                });
            },

            elementHasAttributes: function(el, attrs) {
                return each(attrs, function(name, value) {
                    if (el.getAttribute(name) !== value) {
                        return false;
                    }
                });
            },

            applyToTextNode: function(textNode, positionsToPreserve) {

                // Check whether the text node can be styled. Text within a <style> or <script> element, for example,
                // should not be styled. See issue 283.
                if (canTextBeStyled(textNode)) {
                    var parent = textNode.parentNode;
                    if (parent.childNodes.length == 1 &&
                        this.useExistingElements &&
                        this.appliesToElement(parent) &&
                        this.elementHasProperties(parent, this.elementProperties) &&
                        this.elementHasAttributes(parent, this.elementAttributes)) {

                        addClass(parent, this.className);
                    } else {
                        var textNodeParent = textNode.parentNode;
                        var el = this.createContainer(textNodeParent);
                        textNodeParent.insertBefore(el, textNode);
                        el.appendChild(textNode);
                    }
                }

            },

            isRemovable: function(el) {
                return el.tagName.toLowerCase() == this.elementTagName &&
                    getSortedClassName(el) == this.elementSortedClassName &&
                    this.elementHasProperties(el, this.elementProperties) &&
                    !elementHasNonClassAttributes(el, this.attrExceptions) &&
                    this.elementHasAttributes(el, this.elementAttributes) &&
                    this.isModifiable(el);
            },

            isEmptyContainer: function(el) {
                var childNodeCount = el.childNodes.length;
                return el.nodeType == 1 &&
                    this.isRemovable(el) &&
                    (childNodeCount == 0 || (childNodeCount == 1 && this.isEmptyContainer(el.firstChild)));
            },

            removeEmptyContainers: function(range) {
                var applier = this;
                var nodesToRemove = range.getNodes([1], function(el) {
                    return applier.isEmptyContainer(el);
                });

                var rangesToPreserve = [range];
                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);

                forEach(nodesToRemove, function(node) {
                    removePreservingPositions(node, positionsToPreserve);
                });

                // Update the range from the preserved boundary positions
                updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
            },

            undoToTextNode: function(textNode, range, ancestorWithClass, positionsToPreserve) {
                if (!range.containsNode(ancestorWithClass)) {
                    // Split out the portion of the ancestor from which we can remove the class
                    //var parent = ancestorWithClass.parentNode, index = dom.getNodeIndex(ancestorWithClass);
                    var ancestorRange = range.cloneRange();
                    ancestorRange.selectNode(ancestorWithClass);
                    if (ancestorRange.isPointInRange(range.endContainer, range.endOffset)) {
                        splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset, positionsToPreserve);
                        range.setEndAfter(ancestorWithClass);
                    }
                    if (ancestorRange.isPointInRange(range.startContainer, range.startOffset)) {
                        ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset, positionsToPreserve);
                    }
                }

                if (this.isRemovable(ancestorWithClass)) {
                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
                } else {
                    removeClass(ancestorWithClass, this.className);
                }
            },

            splitAncestorWithClass: function(container, offset, positionsToPreserve) {
                var ancestorWithClass = this.getSelfOrAncestorWithClass(container);
                if (ancestorWithClass) {
                    splitNodeAt(ancestorWithClass, container, offset, positionsToPreserve);
                }
            },

            undoToAncestor: function(ancestorWithClass, positionsToPreserve) {
                if (this.isRemovable(ancestorWithClass)) {
                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
                } else {
                    removeClass(ancestorWithClass, this.className);
                }
            },

            applyToRange: function(range, rangesToPreserve) {
                var applier = this;
                rangesToPreserve = rangesToPreserve || [];

                // Create an array of range boundaries to preserve
                var positionsToPreserve = getRangeBoundaries(rangesToPreserve || []);

                range.splitBoundariesPreservingPositions(positionsToPreserve);

                // Tidy up the DOM by removing empty containers
                if (applier.removeEmptyElements) {
                    applier.removeEmptyContainers(range);
                }

                var textNodes = getEffectiveTextNodes(range);

                if (textNodes.length) {
                    forEach(textNodes, function(textNode) {
                        if (!applier.isIgnorableWhiteSpaceNode(textNode) && !applier.getSelfOrAncestorWithClass(textNode) &&
                                applier.isModifiable(textNode)) {
                            applier.applyToTextNode(textNode, positionsToPreserve);
                        }
                    });
                    var lastTextNode = textNodes[textNodes.length - 1];
                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);
                    if (applier.normalize) {
                        applier.postApply(textNodes, range, positionsToPreserve, false);
                    }

                    // Update the ranges from the preserved boundary positions
                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
                }

                // Apply classes to any appropriate empty elements
                var emptyElements = applier.getEmptyElements(range);

                forEach(emptyElements, function(el) {
                    addClass(el, applier.className);
                });
            },

            applyToRanges: function(ranges) {

                var i = ranges.length;
                while (i--) {
                    this.applyToRange(ranges[i], ranges);
                }


                return ranges;
            },

            applyToSelection: function(win) {
                var sel = api.getSelection(win);
                sel.setRanges( this.applyToRanges(sel.getAllRanges()) );
            },

            undoToRange: function(range, rangesToPreserve) {
                var applier = this;
                // Create an array of range boundaries to preserve
                rangesToPreserve = rangesToPreserve || [];
                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);


                range.splitBoundariesPreservingPositions(positionsToPreserve);

                // Tidy up the DOM by removing empty containers
                if (applier.removeEmptyElements) {
                    applier.removeEmptyContainers(range, positionsToPreserve);
                }

                var textNodes = getEffectiveTextNodes(range);
                var textNode, ancestorWithClass;
                var lastTextNode = textNodes[textNodes.length - 1];

                if (textNodes.length) {
                    applier.splitAncestorWithClass(range.endContainer, range.endOffset, positionsToPreserve);
                    applier.splitAncestorWithClass(range.startContainer, range.startOffset, positionsToPreserve);
                    for (var i = 0, len = textNodes.length; i < len; ++i) {
                        textNode = textNodes[i];
                        ancestorWithClass = applier.getSelfOrAncestorWithClass(textNode);
                        if (ancestorWithClass && applier.isModifiable(textNode)) {
                            applier.undoToAncestor(ancestorWithClass, positionsToPreserve);
                        }
                    }
                    // Ensure the range is still valid
                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);


                    if (applier.normalize) {
                        applier.postApply(textNodes, range, positionsToPreserve, true);
                    }

                    // Update the ranges from the preserved boundary positions
                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
                }

                // Remove class from any appropriate empty elements
                var emptyElements = applier.getEmptyElements(range);

                forEach(emptyElements, function(el) {
                    removeClass(el, applier.className);
                });
            },

            undoToRanges: function(ranges) {
                // Get ranges returned in document order
                var i = ranges.length;

                while (i--) {
                    this.undoToRange(ranges[i], ranges);
                }

                return ranges;
            },

            undoToSelection: function(win) {
                var sel = api.getSelection(win);
                var ranges = api.getSelection(win).getAllRanges();
                this.undoToRanges(ranges);
                sel.setRanges(ranges);
            },

            isAppliedToRange: function(range) {
                if (range.collapsed || range.toString() == "") {
                    return !!this.getSelfOrAncestorWithClass(range.commonAncestorContainer);
                } else {
                    var textNodes = range.getNodes( [3] );
                    if (textNodes.length)
                    for (var i = 0, textNode; textNode = textNodes[i++]; ) {
                        if (!this.isIgnorableWhiteSpaceNode(textNode) && rangeSelectsAnyText(range, textNode) &&
                                this.isModifiable(textNode) && !this.getSelfOrAncestorWithClass(textNode)) {
                            return false;
                        }
                    }
                    return true;
                }
            },

            isAppliedToRanges: function(ranges) {
                var i = ranges.length;
                if (i == 0) {
                    return false;
                }
                while (i--) {
                    if (!this.isAppliedToRange(ranges[i])) {
                        return false;
                    }
                }
                return true;
            },

            isAppliedToSelection: function(win) {
                var sel = api.getSelection(win);
                return this.isAppliedToRanges(sel.getAllRanges());
            },

            toggleRange: function(range) {
                if (this.isAppliedToRange(range)) {
                    this.undoToRange(range);
                } else {
                    this.applyToRange(range);
                }
            },

            toggleSelection: function(win) {
                if (this.isAppliedToSelection(win)) {
                    this.undoToSelection(win);
                } else {
                    this.applyToSelection(win);
                }
            },

            getElementsWithClassIntersectingRange: function(range) {
                var elements = [];
                var applier = this;
                range.getNodes([3], function(textNode) {
                    var el = applier.getSelfOrAncestorWithClass(textNode);
                    if (el && !contains(elements, el)) {
                        elements.push(el);
                    }
                });
                return elements;
            },

            detach: function() {}
        };

        function createClassApplier(className, options, tagNames) {
            return new ClassApplier(className, options, tagNames);
        }

        ClassApplier.util = {
            hasClass: hasClass,
            addClass: addClass,
            removeClass: removeClass,
            getClass: getClass,
            hasSameClasses: haveSameClasses,
            hasAllClasses: hasAllClasses,
            replaceWithOwnChildren: replaceWithOwnChildrenPreservingPositions,
            elementsHaveSameNonClassAttributes: elementsHaveSameNonClassAttributes,
            elementHasNonClassAttributes: elementHasNonClassAttributes,
            splitNodeAt: splitNodeAt,
            isEditableElement: isEditableElement,
            isEditingHost: isEditingHost,
            isEditable: isEditable
        };

        api.CssClassApplier = api.ClassApplier = ClassApplier;
        api.createClassApplier = createClassApplier;
        util.createAliasForDeprecatedMethod(api, "createCssClassApplier", "createClassApplier", module);
    });
    
    return rangy;
}, this);

},{"rangy":15}],15:[function(require,module,exports){
/**
 * Rangy, a cross-browser JavaScript range and selection library
 * https://github.com/timdown/rangy
 *
 * Copyright 2015, Tim Down
 * Licensed under the MIT license.
 * Version: 1.3.0
 * Build date: 10 May 2015
 */

(function(factory, root) {
    if (typeof define == "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof module != "undefined" && typeof exports == "object") {
        // Node/CommonJS style
        module.exports = factory();
    } else {
        // No AMD or CommonJS support so we place Rangy in (probably) the global variable
        root.rangy = factory();
    }
})(function() {

    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";

    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START
    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.
    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
        "commonAncestorContainer"];

    // Minimal set of methods required for DOM Level 2 Range compliance
    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",
        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",
        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];

    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];

    // Subset of TextRange's full set of methods that we're interested in
    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",
        "setEndPoint", "getBoundingClientRect"];

    /*----------------------------------------------------------------------------------------------------------------*/

    // Trio of functions taken from Peter Michaux's article:
    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
    function isHostMethod(o, p) {
        var t = typeof o[p];
        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";
    }

    function isHostObject(o, p) {
        return !!(typeof o[p] == OBJECT && o[p]);
    }

    function isHostProperty(o, p) {
        return typeof o[p] != UNDEFINED;
    }

    // Creates a convenience function to save verbose repeated calls to tests functions
    function createMultiplePropertyTest(testFunc) {
        return function(o, props) {
            var i = props.length;
            while (i--) {
                if (!testFunc(o, props[i])) {
                    return false;
                }
            }
            return true;
        };
    }

    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions
    var areHostMethods = createMultiplePropertyTest(isHostMethod);
    var areHostObjects = createMultiplePropertyTest(isHostObject);
    var areHostProperties = createMultiplePropertyTest(isHostProperty);

    function isTextRange(range) {
        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
    }

    function getBody(doc) {
        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
    }

    var forEach = [].forEach ?
        function(arr, func) {
            arr.forEach(func);
        } :
        function(arr, func) {
            for (var i = 0, len = arr.length; i < len; ++i) {
                func(arr[i], i);
            }
        };

    var modules = {};

    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);

    var util = {
        isHostMethod: isHostMethod,
        isHostObject: isHostObject,
        isHostProperty: isHostProperty,
        areHostMethods: areHostMethods,
        areHostObjects: areHostObjects,
        areHostProperties: areHostProperties,
        isTextRange: isTextRange,
        getBody: getBody,
        forEach: forEach
    };

    var api = {
        version: "1.3.0",
        initialized: false,
        isBrowser: isBrowser,
        supported: true,
        util: util,
        features: {},
        modules: modules,
        config: {
            alertOnFail: false,
            alertOnWarn: false,
            preferTextRange: false,
            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize
        }
    };

    function consoleLog(msg) {
        if (typeof console != UNDEFINED && isHostMethod(console, "log")) {
            console.log(msg);
        }
    }

    function alertOrLog(msg, shouldAlert) {
        if (isBrowser && shouldAlert) {
            alert(msg);
        } else  {
            consoleLog(msg);
        }
    }

    function fail(reason) {
        api.initialized = true;
        api.supported = false;
        alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);
    }

    api.fail = fail;

    function warn(msg) {
        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
    }

    api.warn = warn;

    // Add utility extend() method
    var extend;
    if ({}.hasOwnProperty) {
        util.extend = extend = function(obj, props, deep) {
            var o, p;
            for (var i in props) {
                if (props.hasOwnProperty(i)) {
                    o = obj[i];
                    p = props[i];
                    if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {
                        extend(o, p, true);
                    }
                    obj[i] = p;
                }
            }
            // Special case for toString, which does not show up in for...in loops in IE <= 8
            if (props.hasOwnProperty("toString")) {
                obj.toString = props.toString;
            }
            return obj;
        };

        util.createOptions = function(optionsParam, defaults) {
            var options = {};
            extend(options, defaults);
            if (optionsParam) {
                extend(options, optionsParam);
            }
            return options;
        };
    } else {
        fail("hasOwnProperty not supported");
    }

    // Test whether we're in a browser and bail out if not
    if (!isBrowser) {
        fail("Rangy can only run in a browser");
    }

    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not
    (function() {
        var toArray;

        if (isBrowser) {
            var el = document.createElement("div");
            el.appendChild(document.createElement("span"));
            var slice = [].slice;
            try {
                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
                    toArray = function(arrayLike) {
                        return slice.call(arrayLike, 0);
                    };
                }
            } catch (e) {}
        }

        if (!toArray) {
            toArray = function(arrayLike) {
                var arr = [];
                for (var i = 0, len = arrayLike.length; i < len; ++i) {
                    arr[i] = arrayLike[i];
                }
                return arr;
            };
        }

        util.toArray = toArray;
    })();

    // Very simple event handler wrapper function that doesn't attempt to solve issues such as "this" handling or
    // normalization of event properties
    var addListener;
    if (isBrowser) {
        if (isHostMethod(document, "addEventListener")) {
            addListener = function(obj, eventType, listener) {
                obj.addEventListener(eventType, listener, false);
            };
        } else if (isHostMethod(document, "attachEvent")) {
            addListener = function(obj, eventType, listener) {
                obj.attachEvent("on" + eventType, listener);
            };
        } else {
            fail("Document does not have required addEventListener or attachEvent method");
        }

        util.addListener = addListener;
    }

    var initListeners = [];

    function getErrorDesc(ex) {
        return ex.message || ex.description || String(ex);
    }

    // Initialization
    function init() {
        if (!isBrowser || api.initialized) {
            return;
        }
        var testRange;
        var implementsDomRange = false, implementsTextRange = false;

        // First, perform basic feature tests

        if (isHostMethod(document, "createRange")) {
            testRange = document.createRange();
            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
                implementsDomRange = true;
            }
        }

        var body = getBody(document);
        if (!body || body.nodeName.toLowerCase() != "body") {
            fail("No body element found");
            return;
        }

        if (body && isHostMethod(body, "createTextRange")) {
            testRange = body.createTextRange();
            if (isTextRange(testRange)) {
                implementsTextRange = true;
            }
        }

        if (!implementsDomRange && !implementsTextRange) {
            fail("Neither Range nor TextRange are available");
            return;
        }

        api.initialized = true;
        api.features = {
            implementsDomRange: implementsDomRange,
            implementsTextRange: implementsTextRange
        };

        // Initialize modules
        var module, errorMessage;
        for (var moduleName in modules) {
            if ( (module = modules[moduleName]) instanceof Module ) {
                module.init(module, api);
            }
        }

        // Call init listeners
        for (var i = 0, len = initListeners.length; i < len; ++i) {
            try {
                initListeners[i](api);
            } catch (ex) {
                errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
                consoleLog(errorMessage);
            }
        }
    }

    function deprecationNotice(deprecated, replacement, module) {
        if (module) {
            deprecated += " in module " + module.name;
        }
        api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " +
        replacement + " instead.");
    }

    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {
        owner[deprecated] = function() {
            deprecationNotice(deprecated, replacement, module);
            return owner[replacement].apply(owner, util.toArray(arguments));
        };
    }

    util.deprecationNotice = deprecationNotice;
    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;

    // Allow external scripts to initialize this library in case it's loaded after the document has loaded
    api.init = init;

    // Execute listener immediately if already initialized
    api.addInitListener = function(listener) {
        if (api.initialized) {
            listener(api);
        } else {
            initListeners.push(listener);
        }
    };

    var shimListeners = [];

    api.addShimListener = function(listener) {
        shimListeners.push(listener);
    };

    function shim(win) {
        win = win || window;
        init();

        // Notify listeners
        for (var i = 0, len = shimListeners.length; i < len; ++i) {
            shimListeners[i](win);
        }
    }

    if (isBrowser) {
        api.shim = api.createMissingNativeApi = shim;
        createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");
    }

    function Module(name, dependencies, initializer) {
        this.name = name;
        this.dependencies = dependencies;
        this.initialized = false;
        this.supported = false;
        this.initializer = initializer;
    }

    Module.prototype = {
        init: function() {
            var requiredModuleNames = this.dependencies || [];
            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
                moduleName = requiredModuleNames[i];

                requiredModule = modules[moduleName];
                if (!requiredModule || !(requiredModule instanceof Module)) {
                    throw new Error("required module '" + moduleName + "' not found");
                }

                requiredModule.init();

                if (!requiredModule.supported) {
                    throw new Error("required module '" + moduleName + "' not supported");
                }
            }

            // Now run initializer
            this.initializer(this);
        },

        fail: function(reason) {
            this.initialized = true;
            this.supported = false;
            throw new Error(reason);
        },

        warn: function(msg) {
            api.warn("Module " + this.name + ": " + msg);
        },

        deprecationNotice: function(deprecated, replacement) {
            api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " +
                replacement + " instead");
        },

        createError: function(msg) {
            return new Error("Error in Rangy " + this.name + " module: " + msg);
        }
    };

    function createModule(name, dependencies, initFunc) {
        var newModule = new Module(name, dependencies, function(module) {
            if (!module.initialized) {
                module.initialized = true;
                try {
                    initFunc(api, module);
                    module.supported = true;
                } catch (ex) {
                    var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
                    consoleLog(errorMessage);
                    if (ex.stack) {
                        consoleLog(ex.stack);
                    }
                }
            }
        });
        modules[name] = newModule;
        return newModule;
    }

    api.createModule = function(name) {
        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)
        var initFunc, dependencies;
        if (arguments.length == 2) {
            initFunc = arguments[1];
            dependencies = [];
        } else {
            initFunc = arguments[2];
            dependencies = arguments[1];
        }

        var module = createModule(name, dependencies, initFunc);

        // Initialize the module immediately if the core is already initialized
        if (api.initialized && api.supported) {
            module.init();
        }
    };

    api.createCoreModule = function(name, dependencies, initFunc) {
        createModule(name, dependencies, initFunc);
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately

    function RangePrototype() {}
    api.RangePrototype = RangePrototype;
    api.rangePrototype = new RangePrototype();

    function SelectionPrototype() {}
    api.selectionPrototype = new SelectionPrototype();

    /*----------------------------------------------------------------------------------------------------------------*/

    // DOM utility methods used by Rangy
    api.createCoreModule("DomUtil", [], function(api, module) {
        var UNDEF = "undefined";
        var util = api.util;
        var getBody = util.getBody;

        // Perform feature tests
        if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
            module.fail("document missing a Node creation method");
        }

        if (!util.isHostMethod(document, "getElementsByTagName")) {
            module.fail("document missing getElementsByTagName method");
        }

        var el = document.createElement("div");
        if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||
                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {
            module.fail("Incomplete Element implementation");
        }

        // innerHTML is required for Range's createContextualFragment method
        if (!util.isHostProperty(el, "innerHTML")) {
            module.fail("Element is missing innerHTML property");
        }

        var textNode = document.createTextNode("test");
        if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||
                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||
                !util.areHostProperties(textNode, ["data"]))) {
            module.fail("Incomplete Text Node implementation");
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been
        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that
        // contains just the document as a single element and the value searched for is the document.
        var arrayContains = /*Array.prototype.indexOf ?
            function(arr, val) {
                return arr.indexOf(val) > -1;
            }:*/

            function(arr, val) {
                var i = arr.length;
                while (i--) {
                    if (arr[i] === val) {
                        return true;
                    }
                }
                return false;
            };

        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI
        function isHtmlNamespace(node) {
            var ns;
            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
        }

        function parentElement(node) {
            var parent = node.parentNode;
            return (parent.nodeType == 1) ? parent : null;
        }

        function getNodeIndex(node) {
            var i = 0;
            while( (node = node.previousSibling) ) {
                ++i;
            }
            return i;
        }

        function getNodeLength(node) {
            switch (node.nodeType) {
                case 7:
                case 10:
                    return 0;
                case 3:
                case 8:
                    return node.length;
                default:
                    return node.childNodes.length;
            }
        }

        function getCommonAncestor(node1, node2) {
            var ancestors = [], n;
            for (n = node1; n; n = n.parentNode) {
                ancestors.push(n);
            }

            for (n = node2; n; n = n.parentNode) {
                if (arrayContains(ancestors, n)) {
                    return n;
                }
            }

            return null;
        }

        function isAncestorOf(ancestor, descendant, selfIsAncestor) {
            var n = selfIsAncestor ? descendant : descendant.parentNode;
            while (n) {
                if (n === ancestor) {
                    return true;
                } else {
                    n = n.parentNode;
                }
            }
            return false;
        }

        function isOrIsAncestorOf(ancestor, descendant) {
            return isAncestorOf(ancestor, descendant, true);
        }

        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
            var p, n = selfIsAncestor ? node : node.parentNode;
            while (n) {
                p = n.parentNode;
                if (p === ancestor) {
                    return n;
                }
                n = p;
            }
            return null;
        }

        function isCharacterDataNode(node) {
            var t = node.nodeType;
            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment
        }

        function isTextOrCommentNode(node) {
            if (!node) {
                return false;
            }
            var t = node.nodeType;
            return t == 3 || t == 8 ; // Text or Comment
        }

        function insertAfter(node, precedingNode) {
            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
            if (nextNode) {
                parent.insertBefore(node, nextNode);
            } else {
                parent.appendChild(node);
            }
            return node;
        }

        // Note that we cannot use splitText() because it is bugridden in IE 9.
        function splitDataNode(node, index, positionsToPreserve) {
            var newNode = node.cloneNode(false);
            newNode.deleteData(0, index);
            node.deleteData(index, node.length - index);
            insertAfter(newNode, node);

            // Preserve positions
            if (positionsToPreserve) {
                for (var i = 0, position; position = positionsToPreserve[i++]; ) {
                    // Handle case where position was inside the portion of node after the split point
                    if (position.node == node && position.offset > index) {
                        position.node = newNode;
                        position.offset -= index;
                    }
                    // Handle the case where the position is a node offset within node's parent
                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {
                        ++position.offset;
                    }
                }
            }
            return newNode;
        }

        function getDocument(node) {
            if (node.nodeType == 9) {
                return node;
            } else if (typeof node.ownerDocument != UNDEF) {
                return node.ownerDocument;
            } else if (typeof node.document != UNDEF) {
                return node.document;
            } else if (node.parentNode) {
                return getDocument(node.parentNode);
            } else {
                throw module.createError("getDocument: no document found for node");
            }
        }

        function getWindow(node) {
            var doc = getDocument(node);
            if (typeof doc.defaultView != UNDEF) {
                return doc.defaultView;
            } else if (typeof doc.parentWindow != UNDEF) {
                return doc.parentWindow;
            } else {
                throw module.createError("Cannot get a window object for node");
            }
        }

        function getIframeDocument(iframeEl) {
            if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument;
            } else if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow.document;
            } else {
                throw module.createError("getIframeDocument: No Document object found for iframe element");
            }
        }

        function getIframeWindow(iframeEl) {
            if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow;
            } else if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument.defaultView;
            } else {
                throw module.createError("getIframeWindow: No Window object found for iframe element");
            }
        }

        // This looks bad. Is it worth it?
        function isWindow(obj) {
            return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");
        }

        function getContentDocument(obj, module, methodName) {
            var doc;

            if (!obj) {
                doc = document;
            }

            // Test if a DOM node has been passed and obtain a document object for it if so
            else if (util.isHostProperty(obj, "nodeType")) {
                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?
                    getIframeDocument(obj) : getDocument(obj);
            }

            // Test if the doc parameter appears to be a Window object
            else if (isWindow(obj)) {
                doc = obj.document;
            }

            if (!doc) {
                throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");
            }

            return doc;
        }

        function getRootContainer(node) {
            var parent;
            while ( (parent = node.parentNode) ) {
                node = parent;
            }
            return node;
        }

        function comparePoints(nodeA, offsetA, nodeB, offsetB) {
            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing
            var nodeC, root, childA, childB, n;
            if (nodeA == nodeB) {
                // Case 1: nodes are the same
                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;
            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {
                // Case 2: node C (container B or an ancestor) is a child node of A
                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {
                // Case 3: node C (container A or an ancestor) is a child node of B
                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;
            } else {
                root = getCommonAncestor(nodeA, nodeB);
                if (!root) {
                    throw new Error("comparePoints error: nodes have no common ancestor");
                }

                // Case 4: containers are siblings or descendants of siblings
                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);
                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);

                if (childA === childB) {
                    // This shouldn't be possible
                    throw module.createError("comparePoints got to case 4 and childA and childB are the same!");
                } else {
                    n = root.firstChild;
                    while (n) {
                        if (n === childA) {
                            return -1;
                        } else if (n === childB) {
                            return 1;
                        }
                        n = n.nextSibling;
                    }
                }
            }
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried
        var crashyTextNodes = false;

        function isBrokenNode(node) {
            var n;
            try {
                n = node.parentNode;
                return false;
            } catch (e) {
                return true;
            }
        }

        (function() {
            var el = document.createElement("b");
            el.innerHTML = "1";
            var textNode = el.firstChild;
            el.innerHTML = "<br />";
            crashyTextNodes = isBrokenNode(textNode);

            api.features.crashyTextNodes = crashyTextNodes;
        })();

        /*----------------------------------------------------------------------------------------------------------------*/

        function inspectNode(node) {
            if (!node) {
                return "[No node]";
            }
            if (crashyTextNodes && isBrokenNode(node)) {
                return "[Broken node]";
            }
            if (isCharacterDataNode(node)) {
                return '"' + node.data + '"';
            }
            if (node.nodeType == 1) {
                var idAttr = node.id ? ' id="' + node.id + '"' : "";
                return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
            }
            return node.nodeName;
        }

        function fragmentFromNodeChildren(node) {
            var fragment = getDocument(node).createDocumentFragment(), child;
            while ( (child = node.firstChild) ) {
                fragment.appendChild(child);
            }
            return fragment;
        }

        var getComputedStyleProperty;
        if (typeof window.getComputedStyle != UNDEF) {
            getComputedStyleProperty = function(el, propName) {
                return getWindow(el).getComputedStyle(el, null)[propName];
            };
        } else if (typeof document.documentElement.currentStyle != UNDEF) {
            getComputedStyleProperty = function(el, propName) {
                return el.currentStyle ? el.currentStyle[propName] : "";
            };
        } else {
            module.fail("No means of obtaining computed style properties found");
        }

        function createTestElement(doc, html, contentEditable) {
            var body = getBody(doc);
            var el = doc.createElement("div");
            el.contentEditable = "" + !!contentEditable;
            if (html) {
                el.innerHTML = html;
            }

            // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)
            var bodyFirstChild = body.firstChild;
            if (bodyFirstChild) {
                body.insertBefore(el, bodyFirstChild);
            } else {
                body.appendChild(el);
            }

            return el;
        }

        function removeNode(node) {
            return node.parentNode.removeChild(node);
        }

        function NodeIterator(root) {
            this.root = root;
            this._next = root;
        }

        NodeIterator.prototype = {
            _current: null,

            hasNext: function() {
                return !!this._next;
            },

            next: function() {
                var n = this._current = this._next;
                var child, next;
                if (this._current) {
                    child = n.firstChild;
                    if (child) {
                        this._next = child;
                    } else {
                        next = null;
                        while ((n !== this.root) && !(next = n.nextSibling)) {
                            n = n.parentNode;
                        }
                        this._next = next;
                    }
                }
                return this._current;
            },

            detach: function() {
                this._current = this._next = this.root = null;
            }
        };

        function createIterator(root) {
            return new NodeIterator(root);
        }

        function DomPosition(node, offset) {
            this.node = node;
            this.offset = offset;
        }

        DomPosition.prototype = {
            equals: function(pos) {
                return !!pos && this.node === pos.node && this.offset == pos.offset;
            },

            inspect: function() {
                return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
            },

            toString: function() {
                return this.inspect();
            }
        };

        function DOMException(codeName) {
            this.code = this[codeName];
            this.codeName = codeName;
            this.message = "DOMException: " + this.codeName;
        }

        DOMException.prototype = {
            INDEX_SIZE_ERR: 1,
            HIERARCHY_REQUEST_ERR: 3,
            WRONG_DOCUMENT_ERR: 4,
            NO_MODIFICATION_ALLOWED_ERR: 7,
            NOT_FOUND_ERR: 8,
            NOT_SUPPORTED_ERR: 9,
            INVALID_STATE_ERR: 11,
            INVALID_NODE_TYPE_ERR: 24
        };

        DOMException.prototype.toString = function() {
            return this.message;
        };

        api.dom = {
            arrayContains: arrayContains,
            isHtmlNamespace: isHtmlNamespace,
            parentElement: parentElement,
            getNodeIndex: getNodeIndex,
            getNodeLength: getNodeLength,
            getCommonAncestor: getCommonAncestor,
            isAncestorOf: isAncestorOf,
            isOrIsAncestorOf: isOrIsAncestorOf,
            getClosestAncestorIn: getClosestAncestorIn,
            isCharacterDataNode: isCharacterDataNode,
            isTextOrCommentNode: isTextOrCommentNode,
            insertAfter: insertAfter,
            splitDataNode: splitDataNode,
            getDocument: getDocument,
            getWindow: getWindow,
            getIframeWindow: getIframeWindow,
            getIframeDocument: getIframeDocument,
            getBody: getBody,
            isWindow: isWindow,
            getContentDocument: getContentDocument,
            getRootContainer: getRootContainer,
            comparePoints: comparePoints,
            isBrokenNode: isBrokenNode,
            inspectNode: inspectNode,
            getComputedStyleProperty: getComputedStyleProperty,
            createTestElement: createTestElement,
            removeNode: removeNode,
            fragmentFromNodeChildren: fragmentFromNodeChildren,
            createIterator: createIterator,
            DomPosition: DomPosition
        };

        api.DOMException = DOMException;
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // Pure JavaScript implementation of DOM Range
    api.createCoreModule("DomRange", ["DomUtil"], function(api, module) {
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DOMException = api.DOMException;

        var isCharacterDataNode = dom.isCharacterDataNode;
        var getNodeIndex = dom.getNodeIndex;
        var isOrIsAncestorOf = dom.isOrIsAncestorOf;
        var getDocument = dom.getDocument;
        var comparePoints = dom.comparePoints;
        var splitDataNode = dom.splitDataNode;
        var getClosestAncestorIn = dom.getClosestAncestorIn;
        var getNodeLength = dom.getNodeLength;
        var arrayContains = dom.arrayContains;
        var getRootContainer = dom.getRootContainer;
        var crashyTextNodes = api.features.crashyTextNodes;

        var removeNode = dom.removeNode;

        /*----------------------------------------------------------------------------------------------------------------*/

        // Utility functions

        function isNonTextPartiallySelected(node, range) {
            return (node.nodeType != 3) &&
                   (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));
        }

        function getRangeDocument(range) {
            return range.document || getDocument(range.startContainer);
        }

        function getRangeRoot(range) {
            return getRootContainer(range.startContainer);
        }

        function getBoundaryBeforeNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node));
        }

        function getBoundaryAfterNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);
        }

        function insertNodeAtPosition(node, n, o) {
            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
            if (isCharacterDataNode(n)) {
                if (o == n.length) {
                    dom.insertAfter(node, n);
                } else {
                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));
                }
            } else if (o >= n.childNodes.length) {
                n.appendChild(node);
            } else {
                n.insertBefore(node, n.childNodes[o]);
            }
            return firstNodeInserted;
        }

        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
            assertRangeValid(rangeA);
            assertRangeValid(rangeB);

            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }

            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),
                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);

            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        }

        function cloneSubtree(iterator) {
            var partiallySelected;
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
                partiallySelected = iterator.isPartiallySelectedSubtree();
                node = node.cloneNode(!partiallySelected);
                if (partiallySelected) {
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(cloneSubtree(subIterator));
                    subIterator.detach();
                }

                if (node.nodeType == 10) { // DocumentType
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }

        function iterateSubtree(rangeIterator, func, iteratorState) {
            var it, n;
            iteratorState = iteratorState || { stop: false };
            for (var node, subRangeIterator; node = rangeIterator.next(); ) {
                if (rangeIterator.isPartiallySelectedSubtree()) {
                    if (func(node) === false) {
                        iteratorState.stop = true;
                        return;
                    } else {
                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of
                        // the node selected by the Range.
                        subRangeIterator = rangeIterator.getSubtreeIterator();
                        iterateSubtree(subRangeIterator, func, iteratorState);
                        subRangeIterator.detach();
                        if (iteratorState.stop) {
                            return;
                        }
                    }
                } else {
                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its
                    // descendants
                    it = dom.createIterator(node);
                    while ( (n = it.next()) ) {
                        if (func(n) === false) {
                            iteratorState.stop = true;
                            return;
                        }
                    }
                }
            }
        }

        function deleteSubtree(iterator) {
            var subIterator;
            while (iterator.next()) {
                if (iterator.isPartiallySelectedSubtree()) {
                    subIterator = iterator.getSubtreeIterator();
                    deleteSubtree(subIterator);
                    subIterator.detach();
                } else {
                    iterator.remove();
                }
            }
        }

        function extractSubtree(iterator) {
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {

                if (iterator.isPartiallySelectedSubtree()) {
                    node = node.cloneNode(false);
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(extractSubtree(subIterator));
                    subIterator.detach();
                } else {
                    iterator.remove();
                }
                if (node.nodeType == 10) { // DocumentType
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }

        function getNodesInRange(range, nodeTypes, filter) {
            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
            var filterExists = !!filter;
            if (filterNodeTypes) {
                regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
            }

            var nodes = [];
            iterateSubtree(new RangeIterator(range, false), function(node) {
                if (filterNodeTypes && !regex.test(node.nodeType)) {
                    return;
                }
                if (filterExists && !filter(node)) {
                    return;
                }
                // Don't include a boundary container if it is a character data node and the range does not contain any
                // of its character data. See issue 190.
                var sc = range.startContainer;
                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
                    return;
                }

                var ec = range.endContainer;
                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
                    return;
                }

                nodes.push(node);
            });
            return nodes;
        }

        function inspect(range) {
            var name = (typeof range.getName == "undefined") ? "Range" : range.getName();
            return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +
                    dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)

        function RangeIterator(range, clonePartiallySelectedTextNodes) {
            this.range = range;
            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;


            if (!range.collapsed) {
                this.sc = range.startContainer;
                this.so = range.startOffset;
                this.ec = range.endContainer;
                this.eo = range.endOffset;
                var root = range.commonAncestorContainer;

                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
                    this.isSingleCharacterDataNode = true;
                    this._first = this._last = this._next = this.sc;
                } else {
                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?
                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?
                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
                }
            }
        }

        RangeIterator.prototype = {
            _current: null,
            _next: null,
            _first: null,
            _last: null,
            isSingleCharacterDataNode: false,

            reset: function() {
                this._current = null;
                this._next = this._first;
            },

            hasNext: function() {
                return !!this._next;
            },

            next: function() {
                // Move to next node
                var current = this._current = this._next;
                if (current) {
                    this._next = (current !== this._last) ? current.nextSibling : null;

                    // Check for partially selected text nodes
                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
                        if (current === this.ec) {
                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
                        }
                        if (this._current === this.sc) {
                            (current = current.cloneNode(true)).deleteData(0, this.so);
                        }
                    }
                }

                return current;
            },

            remove: function() {
                var current = this._current, start, end;

                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
                    start = (current === this.sc) ? this.so : 0;
                    end = (current === this.ec) ? this.eo : current.length;
                    if (start != end) {
                        current.deleteData(start, end - start);
                    }
                } else {
                    if (current.parentNode) {
                        removeNode(current);
                    } else {
                    }
                }
            },

            // Checks if the current node is partially selected
            isPartiallySelectedSubtree: function() {
                var current = this._current;
                return isNonTextPartiallySelected(current, this.range);
            },

            getSubtreeIterator: function() {
                var subRange;
                if (this.isSingleCharacterDataNode) {
                    subRange = this.range.cloneRange();
                    subRange.collapse(false);
                } else {
                    subRange = new Range(getRangeDocument(this.range));
                    var current = this._current;
                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);

                    if (isOrIsAncestorOf(current, this.sc)) {
                        startContainer = this.sc;
                        startOffset = this.so;
                    }
                    if (isOrIsAncestorOf(current, this.ec)) {
                        endContainer = this.ec;
                        endOffset = this.eo;
                    }

                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
                }
                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
            },

            detach: function() {
                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
            }
        };

        /*----------------------------------------------------------------------------------------------------------------*/

        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
        var rootContainerNodeTypes = [2, 9, 11];
        var readonlyNodeTypes = [5, 6, 10, 12];
        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];

        function createAncestorFinder(nodeTypes) {
            return function(node, selfIsAncestor) {
                var t, n = selfIsAncestor ? node : node.parentNode;
                while (n) {
                    t = n.nodeType;
                    if (arrayContains(nodeTypes, t)) {
                        return n;
                    }
                    n = n.parentNode;
                }
                return null;
            };
        }

        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );
        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );

        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }

        function assertValidNodeType(node, invalidTypes) {
            if (!arrayContains(invalidTypes, node.nodeType)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }

        function assertValidOffset(node, offset) {
            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
                throw new DOMException("INDEX_SIZE_ERR");
            }
        }

        function assertSameDocumentOrFragment(node1, node2) {
            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }

        function assertNodeNotReadOnly(node) {
            if (getReadonlyAncestor(node, true)) {
                throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");
            }
        }

        function assertNode(node, codeName) {
            if (!node) {
                throw new DOMException(codeName);
            }
        }

        function isValidOffset(node, offset) {
            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
        }

        function isRangeValid(range) {
            return (!!range.startContainer && !!range.endContainer &&
                    !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&
                    getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&
                    isValidOffset(range.startContainer, range.startOffset) &&
                    isValidOffset(range.endContainer, range.endOffset));
        }

        function assertRangeValid(range) {
            if (!isRangeValid(range)) {
                throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");
            }
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Test the browser's innerHTML support to decide how to implement createContextualFragment
        var styleEl = document.createElement("style");
        var htmlParsingConforms = false;
        try {
            styleEl.innerHTML = "<b>x</b>";
            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node
        } catch (e) {
            // IE 6 and 7 throw
        }

        api.features.htmlParsingConforms = htmlParsingConforms;

        var createContextualFragment = htmlParsingConforms ?

            // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See
            // discussion and base code for this implementation at issue 67.
            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface
            // Thanks to Aleks Williams.
            function(fragmentStr) {
                // "Let node the context object's start's node."
                var node = this.startContainer;
                var doc = getDocument(node);

                // "If the context object's start's node is null, raise an INVALID_STATE_ERR
                // exception and abort these steps."
                if (!node) {
                    throw new DOMException("INVALID_STATE_ERR");
                }

                // "Let element be as follows, depending on node's interface:"
                // Document, Document Fragment: null
                var el = null;

                // "Element: node"
                if (node.nodeType == 1) {
                    el = node;

                // "Text, Comment: node's parentElement"
                } else if (isCharacterDataNode(node)) {
                    el = dom.parentElement(node);
                }

                // "If either element is null or element's ownerDocument is an HTML document
                // and element's local name is "html" and element's namespace is the HTML
                // namespace"
                if (el === null || (
                    el.nodeName == "HTML" &&
                    dom.isHtmlNamespace(getDocument(el).documentElement) &&
                    dom.isHtmlNamespace(el)
                )) {

                // "let element be a new Element with "body" as its local name and the HTML
                // namespace as its namespace.""
                    el = doc.createElement("body");
                } else {
                    el = el.cloneNode(false);
                }

                // "If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm."
                // "If the node's document is an XML document: Invoke the XML fragment parsing algorithm."
                // "In either case, the algorithm must be invoked with fragment as the input
                // and element as the context element."
                el.innerHTML = fragmentStr;

                // "If this raises an exception, then abort these steps. Otherwise, let new
                // children be the nodes returned."

                // "Let fragment be a new DocumentFragment."
                // "Append all new children to fragment."
                // "Return fragment."
                return dom.fragmentFromNodeChildren(el);
            } :

            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that
            // previous versions of Rangy used (with the exception of using a body element rather than a div)
            function(fragmentStr) {
                var doc = getRangeDocument(this);
                var el = doc.createElement("body");
                el.innerHTML = fragmentStr;

                return dom.fragmentFromNodeChildren(el);
            };

        function splitRangeBoundaries(range, positionsToPreserve) {
            assertRangeValid(range);

            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
            var startEndSame = (sc === ec);

            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
                splitDataNode(ec, eo, positionsToPreserve);
            }

            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
                sc = splitDataNode(sc, so, positionsToPreserve);
                if (startEndSame) {
                    eo -= so;
                    ec = sc;
                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
                    eo++;
                }
                so = 0;
            }
            range.setStartAndEnd(sc, so, ec, eo);
        }

        function rangeToHtml(range) {
            assertRangeValid(range);
            var container = range.commonAncestorContainer.parentNode.cloneNode(false);
            container.appendChild( range.cloneContents() );
            return container.innerHTML;
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
            "commonAncestorContainer"];

        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;

        util.extend(api.rangePrototype, {
            compareBoundaryPoints: function(how, range) {
                assertRangeValid(this);
                assertSameDocumentOrFragment(this.startContainer, range.startContainer);

                var nodeA, offsetA, nodeB, offsetB;
                var prefixA = (how == e2s || how == s2s) ? "start" : "end";
                var prefixB = (how == s2e || how == s2s) ? "start" : "end";
                nodeA = this[prefixA + "Container"];
                offsetA = this[prefixA + "Offset"];
                nodeB = range[prefixB + "Container"];
                offsetB = range[prefixB + "Offset"];
                return comparePoints(nodeA, offsetA, nodeB, offsetB);
            },

            insertNode: function(node) {
                assertRangeValid(this);
                assertValidNodeType(node, insertableNodeTypes);
                assertNodeNotReadOnly(this.startContainer);

                if (isOrIsAncestorOf(node, this.startContainer)) {
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }

                // No check for whether the container of the start of the Range is of a type that does not allow
                // children of the type of node: the browser's DOM implementation should do this for us when we attempt
                // to add the node

                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
                this.setStartBefore(firstNodeInserted);
            },

            cloneContents: function() {
                assertRangeValid(this);

                var clone, frag;
                if (this.collapsed) {
                    return getRangeDocument(this).createDocumentFragment();
                } else {
                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
                        clone = this.startContainer.cloneNode(true);
                        clone.data = clone.data.slice(this.startOffset, this.endOffset);
                        frag = getRangeDocument(this).createDocumentFragment();
                        frag.appendChild(clone);
                        return frag;
                    } else {
                        var iterator = new RangeIterator(this, true);
                        clone = cloneSubtree(iterator);
                        iterator.detach();
                    }
                    return clone;
                }
            },

            canSurroundContents: function() {
                assertRangeValid(this);
                assertNodeNotReadOnly(this.startContainer);
                assertNodeNotReadOnly(this.endContainer);

                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
                // no non-text nodes.
                var iterator = new RangeIterator(this, true);
                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                iterator.detach();
                return !boundariesInvalid;
            },

            surroundContents: function(node) {
                assertValidNodeType(node, surroundNodeTypes);

                if (!this.canSurroundContents()) {
                    throw new DOMException("INVALID_STATE_ERR");
                }

                // Extract the contents
                var content = this.extractContents();

                // Clear the children of the node
                if (node.hasChildNodes()) {
                    while (node.lastChild) {
                        node.removeChild(node.lastChild);
                    }
                }

                // Insert the new node and add the extracted contents
                insertNodeAtPosition(node, this.startContainer, this.startOffset);
                node.appendChild(content);

                this.selectNode(node);
            },

            cloneRange: function() {
                assertRangeValid(this);
                var range = new Range(getRangeDocument(this));
                var i = rangeProperties.length, prop;
                while (i--) {
                    prop = rangeProperties[i];
                    range[prop] = this[prop];
                }
                return range;
            },

            toString: function() {
                assertRangeValid(this);
                var sc = this.startContainer;
                if (sc === this.endContainer && isCharacterDataNode(sc)) {
                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";
                } else {
                    var textParts = [], iterator = new RangeIterator(this, true);
                    iterateSubtree(iterator, function(node) {
                        // Accept only text or CDATA nodes, not comments
                        if (node.nodeType == 3 || node.nodeType == 4) {
                            textParts.push(node.data);
                        }
                    });
                    iterator.detach();
                    return textParts.join("");
                }
            },

            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since
            // been removed from Mozilla.

            compareNode: function(node) {
                assertRangeValid(this);

                var parent = node.parentNode;
                var nodeIndex = getNodeIndex(node);

                if (!parent) {
                    throw new DOMException("NOT_FOUND_ERR");
                }

                var startComparison = this.comparePoint(parent, nodeIndex),
                    endComparison = this.comparePoint(parent, nodeIndex + 1);

                if (startComparison < 0) { // Node starts before
                    return (endComparison > 0) ? n_b_a : n_b;
                } else {
                    return (endComparison > 0) ? n_a : n_i;
                }
            },

            comparePoint: function(node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);

                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
                    return -1;
                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
                    return 1;
                }
                return 0;
            },

            createContextualFragment: createContextualFragment,

            toHtml: function() {
                return rangeToHtml(this);
            },

            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects
            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)
            intersectsNode: function(node, touchingIsIntersecting) {
                assertRangeValid(this);
                if (getRootContainer(node) != getRangeRoot(this)) {
                    return false;
                }

                var parent = node.parentNode, offset = getNodeIndex(node);
                if (!parent) {
                    return true;
                }

                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),
                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);

                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
            },

            isPointInRange: function(node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);

                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&
                       (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);
            },

            // The methods below are non-standard and invented by me.

            // Sharing a boundary start-to-end or end-to-start does not count as intersection.
            intersectsRange: function(range) {
                return rangesIntersect(this, range, false);
            },

            // Sharing a boundary start-to-end or end-to-start does count as intersection.
            intersectsOrTouchesRange: function(range) {
                return rangesIntersect(this, range, true);
            },

            intersection: function(range) {
                if (this.intersectsRange(range)) {
                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),
                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);

                    var intersectionRange = this.cloneRange();
                    if (startComparison == -1) {
                        intersectionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (endComparison == 1) {
                        intersectionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return intersectionRange;
                }
                return null;
            },

            union: function(range) {
                if (this.intersectsOrTouchesRange(range)) {
                    var unionRange = this.cloneRange();
                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
                        unionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
                        unionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return unionRange;
                } else {
                    throw new DOMException("Ranges do not intersect");
                }
            },

            containsNode: function(node, allowPartial) {
                if (allowPartial) {
                    return this.intersectsNode(node, false);
                } else {
                    return this.compareNode(node) == n_i;
                }
            },

            containsNodeContents: function(node) {
                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
            },

            containsRange: function(range) {
                var intersection = this.intersection(range);
                return intersection !== null && range.equals(intersection);
            },

            containsNodeText: function(node) {
                var nodeRange = this.cloneRange();
                nodeRange.selectNode(node);
                var textNodes = nodeRange.getNodes([3]);
                if (textNodes.length > 0) {
                    nodeRange.setStart(textNodes[0], 0);
                    var lastTextNode = textNodes.pop();
                    nodeRange.setEnd(lastTextNode, lastTextNode.length);
                    return this.containsRange(nodeRange);
                } else {
                    return this.containsNodeContents(node);
                }
            },

            getNodes: function(nodeTypes, filter) {
                assertRangeValid(this);
                return getNodesInRange(this, nodeTypes, filter);
            },

            getDocument: function() {
                return getRangeDocument(this);
            },

            collapseBefore: function(node) {
                this.setEndBefore(node);
                this.collapse(false);
            },

            collapseAfter: function(node) {
                this.setStartAfter(node);
                this.collapse(true);
            },

            getBookmark: function(containerNode) {
                var doc = getRangeDocument(this);
                var preSelectionRange = api.createRange(doc);
                containerNode = containerNode || dom.getBody(doc);
                preSelectionRange.selectNodeContents(containerNode);
                var range = this.intersection(preSelectionRange);
                var start = 0, end = 0;
                if (range) {
                    preSelectionRange.setEnd(range.startContainer, range.startOffset);
                    start = preSelectionRange.toString().length;
                    end = start + range.toString().length;
                }

                return {
                    start: start,
                    end: end,
                    containerNode: containerNode
                };
            },

            moveToBookmark: function(bookmark) {
                var containerNode = bookmark.containerNode;
                var charIndex = 0;
                this.setStart(containerNode, 0);
                this.collapse(true);
                var nodeStack = [containerNode], node, foundStart = false, stop = false;
                var nextCharIndex, i, childNodes;

                while (!stop && (node = nodeStack.pop())) {
                    if (node.nodeType == 3) {
                        nextCharIndex = charIndex + node.length;
                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
                            this.setStart(node, bookmark.start - charIndex);
                            foundStart = true;
                        }
                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
                            this.setEnd(node, bookmark.end - charIndex);
                            stop = true;
                        }
                        charIndex = nextCharIndex;
                    } else {
                        childNodes = node.childNodes;
                        i = childNodes.length;
                        while (i--) {
                            nodeStack.push(childNodes[i]);
                        }
                    }
                }
            },

            getName: function() {
                return "DomRange";
            },

            equals: function(range) {
                return Range.rangesEqual(this, range);
            },

            isValid: function() {
                return isRangeValid(this);
            },

            inspect: function() {
                return inspect(this);
            },

            detach: function() {
                // In DOM4, detach() is now a no-op.
            }
        });

        function copyComparisonConstantsToObject(obj) {
            obj.START_TO_START = s2s;
            obj.START_TO_END = s2e;
            obj.END_TO_END = e2e;
            obj.END_TO_START = e2s;

            obj.NODE_BEFORE = n_b;
            obj.NODE_AFTER = n_a;
            obj.NODE_BEFORE_AND_AFTER = n_b_a;
            obj.NODE_INSIDE = n_i;
        }

        function copyComparisonConstants(constructor) {
            copyComparisonConstantsToObject(constructor);
            copyComparisonConstantsToObject(constructor.prototype);
        }

        function createRangeContentRemover(remover, boundaryUpdater) {
            return function() {
                assertRangeValid(this);

                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;

                var iterator = new RangeIterator(this, true);

                // Work out where to position the range after content removal
                var node, boundary;
                if (sc !== root) {
                    node = getClosestAncestorIn(sc, root, true);
                    boundary = getBoundaryAfterNode(node);
                    sc = boundary.node;
                    so = boundary.offset;
                }

                // Check none of the range is read-only
                iterateSubtree(iterator, assertNodeNotReadOnly);

                iterator.reset();

                // Remove the content
                var returnValue = remover(iterator);
                iterator.detach();

                // Move to the new position
                boundaryUpdater(this, sc, so, sc, so);

                return returnValue;
            };
        }

        function createPrototypeRange(constructor, boundaryUpdater) {
            function createBeforeAfterNodeSetter(isBefore, isStart) {
                return function(node) {
                    assertValidNodeType(node, beforeAfterNodeTypes);
                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);

                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
                };
            }

            function setRangeStart(range, node, offset) {
                var ec = range.endContainer, eo = range.endOffset;
                if (node !== range.startContainer || offset !== range.startOffset) {
                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
                    // is after the current end. In either case, collapse the range to the new position
                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
                        ec = node;
                        eo = offset;
                    }
                    boundaryUpdater(range, node, offset, ec, eo);
                }
            }

            function setRangeEnd(range, node, offset) {
                var sc = range.startContainer, so = range.startOffset;
                if (node !== range.endContainer || offset !== range.endOffset) {
                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
                    // is after the current end. In either case, collapse the range to the new position
                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
                        sc = node;
                        so = offset;
                    }
                    boundaryUpdater(range, sc, so, node, offset);
                }
            }

            // Set up inheritance
            var F = function() {};
            F.prototype = api.rangePrototype;
            constructor.prototype = new F();

            util.extend(constructor.prototype, {
                setStart: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);

                    setRangeStart(this, node, offset);
                },

                setEnd: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);

                    setRangeEnd(this, node, offset);
                },

                /**
                 * Convenience method to set a range's start and end boundaries. Overloaded as follows:
                 * - Two parameters (node, offset) creates a collapsed range at that position
                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at
                 *   startOffset and ending at endOffset
                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in
                 *   startNode and ending at endOffset in endNode
                 */
                setStartAndEnd: function() {
                    var args = arguments;
                    var sc = args[0], so = args[1], ec = sc, eo = so;

                    switch (args.length) {
                        case 3:
                            eo = args[2];
                            break;
                        case 4:
                            ec = args[2];
                            eo = args[3];
                            break;
                    }

                    boundaryUpdater(this, sc, so, ec, eo);
                },

                setBoundary: function(node, offset, isStart) {
                    this["set" + (isStart ? "Start" : "End")](node, offset);
                },

                setStartBefore: createBeforeAfterNodeSetter(true, true),
                setStartAfter: createBeforeAfterNodeSetter(false, true),
                setEndBefore: createBeforeAfterNodeSetter(true, false),
                setEndAfter: createBeforeAfterNodeSetter(false, false),

                collapse: function(isStart) {
                    assertRangeValid(this);
                    if (isStart) {
                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
                    } else {
                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
                    }
                },

                selectNodeContents: function(node) {
                    assertNoDocTypeNotationEntityAncestor(node, true);

                    boundaryUpdater(this, node, 0, node, getNodeLength(node));
                },

                selectNode: function(node) {
                    assertNoDocTypeNotationEntityAncestor(node, false);
                    assertValidNodeType(node, beforeAfterNodeTypes);

                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
                },

                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),

                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),

                canSurroundContents: function() {
                    assertRangeValid(this);
                    assertNodeNotReadOnly(this.startContainer);
                    assertNodeNotReadOnly(this.endContainer);

                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
                    // no non-text nodes.
                    var iterator = new RangeIterator(this, true);
                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||
                            (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                    iterator.detach();
                    return !boundariesInvalid;
                },

                splitBoundaries: function() {
                    splitRangeBoundaries(this);
                },

                splitBoundariesPreservingPositions: function(positionsToPreserve) {
                    splitRangeBoundaries(this, positionsToPreserve);
                },

                normalizeBoundaries: function() {
                    assertRangeValid(this);

                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;

                    var mergeForward = function(node) {
                        var sibling = node.nextSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            ec = node;
                            eo = node.length;
                            node.appendData(sibling.data);
                            removeNode(sibling);
                        }
                    };

                    var mergeBackward = function(node) {
                        var sibling = node.previousSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            sc = node;
                            var nodeLength = node.length;
                            so = sibling.length;
                            node.insertData(0, sibling.data);
                            removeNode(sibling);
                            if (sc == ec) {
                                eo += so;
                                ec = sc;
                            } else if (ec == node.parentNode) {
                                var nodeIndex = getNodeIndex(node);
                                if (eo == nodeIndex) {
                                    ec = node;
                                    eo = nodeLength;
                                } else if (eo > nodeIndex) {
                                    eo--;
                                }
                            }
                        }
                    };

                    var normalizeStart = true;
                    var sibling;

                    if (isCharacterDataNode(ec)) {
                        if (eo == ec.length) {
                            mergeForward(ec);
                        } else if (eo == 0) {
                            sibling = ec.previousSibling;
                            if (sibling && sibling.nodeType == ec.nodeType) {
                                eo = sibling.length;
                                if (sc == ec) {
                                    normalizeStart = false;
                                }
                                sibling.appendData(ec.data);
                                removeNode(ec);
                                ec = sibling;
                            }
                        }
                    } else {
                        if (eo > 0) {
                            var endNode = ec.childNodes[eo - 1];
                            if (endNode && isCharacterDataNode(endNode)) {
                                mergeForward(endNode);
                            }
                        }
                        normalizeStart = !this.collapsed;
                    }

                    if (normalizeStart) {
                        if (isCharacterDataNode(sc)) {
                            if (so == 0) {
                                mergeBackward(sc);
                            } else if (so == sc.length) {
                                sibling = sc.nextSibling;
                                if (sibling && sibling.nodeType == sc.nodeType) {
                                    if (ec == sibling) {
                                        ec = sc;
                                        eo += sc.length;
                                    }
                                    sc.appendData(sibling.data);
                                    removeNode(sibling);
                                }
                            }
                        } else {
                            if (so < sc.childNodes.length) {
                                var startNode = sc.childNodes[so];
                                if (startNode && isCharacterDataNode(startNode)) {
                                    mergeBackward(startNode);
                                }
                            }
                        }
                    } else {
                        sc = ec;
                        so = eo;
                    }

                    boundaryUpdater(this, sc, so, ec, eo);
                },

                collapseToPoint: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);
                    this.setStartAndEnd(node, offset);
                }
            });

            copyComparisonConstants(constructor);
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Updates commonAncestorContainer and collapsed after boundary change
        function updateCollapsedAndCommonAncestor(range) {
            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
            range.commonAncestorContainer = range.collapsed ?
                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
        }

        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
            range.startContainer = startContainer;
            range.startOffset = startOffset;
            range.endContainer = endContainer;
            range.endOffset = endOffset;
            range.document = dom.getDocument(startContainer);

            updateCollapsedAndCommonAncestor(range);
        }

        function Range(doc) {
            this.startContainer = doc;
            this.startOffset = 0;
            this.endContainer = doc;
            this.endOffset = 0;
            this.document = doc;
            updateCollapsedAndCommonAncestor(this);
        }

        createPrototypeRange(Range, updateBoundaries);

        util.extend(Range, {
            rangeProperties: rangeProperties,
            RangeIterator: RangeIterator,
            copyComparisonConstants: copyComparisonConstants,
            createPrototypeRange: createPrototypeRange,
            inspect: inspect,
            toHtml: rangeToHtml,
            getRangeDocument: getRangeDocument,
            rangesEqual: function(r1, r2) {
                return r1.startContainer === r2.startContainer &&
                    r1.startOffset === r2.startOffset &&
                    r1.endContainer === r2.endContainer &&
                    r1.endOffset === r2.endOffset;
            }
        });

        api.DomRange = Range;
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // Wrappers for the browser's native DOM Range and/or TextRange implementation
    api.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {
        var WrappedRange, WrappedTextRange;
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DomRange = api.DomRange;
        var getBody = dom.getBody;
        var getContentDocument = dom.getContentDocument;
        var isCharacterDataNode = dom.isCharacterDataNode;


        /*----------------------------------------------------------------------------------------------------------------*/

        if (api.features.implementsDomRange) {
            // This is a wrapper around the browser's native DOM Range. It has two aims:
            // - Provide workarounds for specific browser bugs
            // - provide convenient extensions, which are inherited from Rangy's DomRange

            (function() {
                var rangeProto;
                var rangeProperties = DomRange.rangeProperties;

                function updateRangeProperties(range) {
                    var i = rangeProperties.length, prop;
                    while (i--) {
                        prop = rangeProperties[i];
                        range[prop] = range.nativeRange[prop];
                    }
                    // Fix for broken collapsed property in IE 9.
                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
                }

                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {
                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);
                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);
                    var nativeRangeDifferent = !range.equals(range.nativeRange);

                    // Always set both boundaries for the benefit of IE9 (see issue 35)
                    if (startMoved || endMoved || nativeRangeDifferent) {
                        range.setEnd(endContainer, endOffset);
                        range.setStart(startContainer, startOffset);
                    }
                }

                var createBeforeAfterNodeSetter;

                WrappedRange = function(range) {
                    if (!range) {
                        throw module.createError("WrappedRange: Range must be specified");
                    }
                    this.nativeRange = range;
                    updateRangeProperties(this);
                };

                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);

                rangeProto = WrappedRange.prototype;

                rangeProto.selectNode = function(node) {
                    this.nativeRange.selectNode(node);
                    updateRangeProperties(this);
                };

                rangeProto.cloneContents = function() {
                    return this.nativeRange.cloneContents();
                };

                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,
                // insertNode() is never delegated to the native range.

                rangeProto.surroundContents = function(node) {
                    this.nativeRange.surroundContents(node);
                    updateRangeProperties(this);
                };

                rangeProto.collapse = function(isStart) {
                    this.nativeRange.collapse(isStart);
                    updateRangeProperties(this);
                };

                rangeProto.cloneRange = function() {
                    return new WrappedRange(this.nativeRange.cloneRange());
                };

                rangeProto.refresh = function() {
                    updateRangeProperties(this);
                };

                rangeProto.toString = function() {
                    return this.nativeRange.toString();
                };

                // Create test range and node for feature detection

                var testTextNode = document.createTextNode("test");
                getBody(document).appendChild(testTextNode);
                var range = document.createRange();

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and
                // correct for it

                range.setStart(testTextNode, 0);
                range.setEnd(testTextNode, 0);

                try {
                    range.setStart(testTextNode, 1);

                    rangeProto.setStart = function(node, offset) {
                        this.nativeRange.setStart(node, offset);
                        updateRangeProperties(this);
                    };

                    rangeProto.setEnd = function(node, offset) {
                        this.nativeRange.setEnd(node, offset);
                        updateRangeProperties(this);
                    };

                    createBeforeAfterNodeSetter = function(name) {
                        return function(node) {
                            this.nativeRange[name](node);
                            updateRangeProperties(this);
                        };
                    };

                } catch(ex) {

                    rangeProto.setStart = function(node, offset) {
                        try {
                            this.nativeRange.setStart(node, offset);
                        } catch (ex) {
                            this.nativeRange.setEnd(node, offset);
                            this.nativeRange.setStart(node, offset);
                        }
                        updateRangeProperties(this);
                    };

                    rangeProto.setEnd = function(node, offset) {
                        try {
                            this.nativeRange.setEnd(node, offset);
                        } catch (ex) {
                            this.nativeRange.setStart(node, offset);
                            this.nativeRange.setEnd(node, offset);
                        }
                        updateRangeProperties(this);
                    };

                    createBeforeAfterNodeSetter = function(name, oppositeName) {
                        return function(node) {
                            try {
                                this.nativeRange[name](node);
                            } catch (ex) {
                                this.nativeRange[oppositeName](node);
                                this.nativeRange[name](node);
                            }
                            updateRangeProperties(this);
                        };
                    };
                }

                rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
                rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
                rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
                rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");

                /*--------------------------------------------------------------------------------------------------------*/

                // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing
                // whether the native implementation can be trusted
                rangeProto.selectNodeContents = function(node) {
                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));
                };

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for
                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738

                range.selectNodeContents(testTextNode);
                range.setEnd(testTextNode, 3);

                var range2 = document.createRange();
                range2.selectNodeContents(testTextNode);
                range2.setEnd(testTextNode, 4);
                range2.setStart(testTextNode, 2);

                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&
                        range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
                    // This is the wrong way round, so correct for it

                    rangeProto.compareBoundaryPoints = function(type, range) {
                        range = range.nativeRange || range;
                        if (type == range.START_TO_END) {
                            type = range.END_TO_START;
                        } else if (type == range.END_TO_START) {
                            type = range.START_TO_END;
                        }
                        return this.nativeRange.compareBoundaryPoints(type, range);
                    };
                } else {
                    rangeProto.compareBoundaryPoints = function(type, range) {
                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
                    };
                }

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.

                var el = document.createElement("div");
                el.innerHTML = "123";
                var textNode = el.firstChild;
                var body = getBody(document);
                body.appendChild(el);

                range.setStart(textNode, 1);
                range.setEnd(textNode, 2);
                range.deleteContents();

                if (textNode.data == "13") {
                    // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and
                    // extractContents()
                    rangeProto.deleteContents = function() {
                        this.nativeRange.deleteContents();
                        updateRangeProperties(this);
                    };

                    rangeProto.extractContents = function() {
                        var frag = this.nativeRange.extractContents();
                        updateRangeProperties(this);
                        return frag;
                    };
                } else {
                }

                body.removeChild(el);
                body = null;

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for existence of createContextualFragment and delegate to it if it exists
                if (util.isHostMethod(range, "createContextualFragment")) {
                    rangeProto.createContextualFragment = function(fragmentStr) {
                        return this.nativeRange.createContextualFragment(fragmentStr);
                    };
                }

                /*--------------------------------------------------------------------------------------------------------*/

                // Clean up
                getBody(document).removeChild(testTextNode);

                rangeProto.getName = function() {
                    return "WrappedRange";
                };

                api.WrappedRange = WrappedRange;

                api.createNativeRange = function(doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return doc.createRange();
                };
            })();
        }

        if (api.features.implementsTextRange) {
            /*
            This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()
            method. For example, in the following (where pipes denote the selection boundaries):

            <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>

            var range = document.selection.createRange();
            alert(range.parentElement().id); // Should alert "ul" but alerts "b"

            This method returns the common ancestor node of the following:
            - the parentElement() of the textRange
            - the parentElement() of the textRange after calling collapse(true)
            - the parentElement() of the textRange after calling collapse(false)
            */
            var getTextRangeContainerElement = function(textRange) {
                var parentEl = textRange.parentElement();
                var range = textRange.duplicate();
                range.collapse(true);
                var startEl = range.parentElement();
                range = textRange.duplicate();
                range.collapse(false);
                var endEl = range.parentElement();
                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);

                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
            };

            var textRangeIsCollapsed = function(textRange) {
                return textRange.compareEndPoints("StartToEnd", textRange) == 0;
            };

            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started
            // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)
            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange
            // bugs, handling for inputs and images, plus optimizations.
            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
                var workingRange = textRange.duplicate();
                workingRange.collapse(isStart);
                var containerElement = workingRange.parentElement();

                // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so
                // check for that
                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
                    containerElement = wholeRangeContainerElement;
                }


                // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and
                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx
                if (!containerElement.canHaveHTML) {
                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
                    return {
                        boundaryPosition: pos,
                        nodeInfo: {
                            nodeIndex: pos.offset,
                            containerElement: pos.node
                        }
                    };
                }

                var workingNode = dom.getDocument(containerElement).createElement("span");

                // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5
                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64
                if (workingNode.parentNode) {
                    dom.removeNode(workingNode);
                }

                var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
                var previousNode, nextNode, boundaryPosition, boundaryNode;
                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;
                var childNodeCount = containerElement.childNodes.length;
                var end = childNodeCount;

                // Check end first. Code within the loop assumes that the endth child node of the container is definitely
                // after the range boundary.
                var nodeIndex = end;

                while (true) {
                    if (nodeIndex == childNodeCount) {
                        containerElement.appendChild(workingNode);
                    } else {
                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
                    }
                    workingRange.moveToElementText(workingNode);
                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
                    if (comparison == 0 || start == end) {
                        break;
                    } else if (comparison == -1) {
                        if (end == start + 1) {
                            // We know the endth child node is after the range boundary, so we must be done.
                            break;
                        } else {
                            start = nodeIndex;
                        }
                    } else {
                        end = (end == start + 1) ? start : nodeIndex;
                    }
                    nodeIndex = Math.floor((start + end) / 2);
                    containerElement.removeChild(workingNode);
                }


                // We've now reached or gone past the boundary of the text range we're interested in
                // so have identified the node we want
                boundaryNode = workingNode.nextSibling;

                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of
                    // the node containing the text range's boundary, so we move the end of the working range to the
                    // boundary point and measure the length of its text to get the boundary's offset within the node.
                    workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);

                    var offset;

                    if (/[\r\n]/.test(boundaryNode.data)) {
                        /*
                        For the particular case of a boundary within a text node containing rendered line breaks (within a
                        <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in
                        IE. The facts:

                        - Each line break is represented as \r in the text node's data/nodeValue properties
                        - Each line break is represented as \r\n in the TextRange's 'text' property
                        - The 'text' property of the TextRange does not contain trailing line breaks

                        To get round the problem presented by the final fact above, we can use the fact that TextRange's
                        moveStart() and moveEnd() methods return the actual number of characters moved, which is not
                        necessarily the same as the number of characters it was instructed to move. The simplest approach is
                        to use this to store the characters moved when moving both the start and end of the range to the
                        start of the document body and subtracting the start offset from the end offset (the
                        "move-negative-gazillion" method). However, this is extremely slow when the document is large and
                        the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to
                        the end of the document) has the same problem.

                        Another approach that works is to use moveStart() to move the start boundary of the range up to the
                        end boundary one character at a time and incrementing a counter with the value returned by the
                        moveStart() call. However, the check for whether the start boundary has reached the end boundary is
                        expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected
                        by the location of the range within the document).

                        The approach used below is a hybrid of the two methods above. It uses the fact that a string
                        containing the TextRange's 'text' property with each \r\n converted to a single \r character cannot
                        be longer than the text of the TextRange, so the start of the range is moved that length initially
                        and then a character at a time to make up for any trailing line breaks not contained in the 'text'
                        property. This has good performance in most situations compared to the previous two methods.
                        */
                        var tempRange = workingRange.duplicate();
                        var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;

                        offset = tempRange.moveStart("character", rangeLength);
                        while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
                            offset++;
                            tempRange.moveStart("character", 1);
                        }
                    } else {
                        offset = workingRange.text.length;
                    }
                    boundaryPosition = new DomPosition(boundaryNode, offset);
                } else {

                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour
                    // a position within that, and likewise for a start boundary preceding a character data node
                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
                    if (nextNode && isCharacterDataNode(nextNode)) {
                        boundaryPosition = new DomPosition(nextNode, 0);
                    } else if (previousNode && isCharacterDataNode(previousNode)) {
                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
                    } else {
                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
                    }
                }

                // Clean up
                dom.removeNode(workingNode);

                return {
                    boundaryPosition: boundaryPosition,
                    nodeInfo: {
                        nodeIndex: nodeIndex,
                        containerElement: containerElement
                    }
                };
            };

            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that
            // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange
            // (http://code.google.com/p/ierange/)
            var createBoundaryTextRange = function(boundaryPosition, isStart) {
                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
                var doc = dom.getDocument(boundaryPosition.node);
                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();
                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);

                if (nodeIsDataNode) {
                    boundaryNode = boundaryPosition.node;
                    boundaryParent = boundaryNode.parentNode;
                } else {
                    childNodes = boundaryPosition.node.childNodes;
                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;
                    boundaryParent = boundaryPosition.node;
                }

                // Position the range immediately before the node containing the boundary
                workingNode = doc.createElement("span");

                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within
                // the element rather than immediately before or after it
                workingNode.innerHTML = "&#feff;";

                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report
                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12
                if (boundaryNode) {
                    boundaryParent.insertBefore(workingNode, boundaryNode);
                } else {
                    boundaryParent.appendChild(workingNode);
                }

                workingRange.moveToElementText(workingNode);
                workingRange.collapse(!isStart);

                // Clean up
                boundaryParent.removeChild(workingNode);

                // Move the working range to the text offset, if required
                if (nodeIsDataNode) {
                    workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
                }

                return workingRange;
            };

            /*------------------------------------------------------------------------------------------------------------*/

            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a
            // prototype

            WrappedTextRange = function(textRange) {
                this.textRange = textRange;
                this.refresh();
            };

            WrappedTextRange.prototype = new DomRange(document);

            WrappedTextRange.prototype.refresh = function() {
                var start, end, startBoundary;

                // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.
                var rangeContainerElement = getTextRangeContainerElement(this.textRange);

                if (textRangeIsCollapsed(this.textRange)) {
                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,
                        true).boundaryPosition;
                } else {
                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
                    start = startBoundary.boundaryPosition;

                    // An optimization used here is that if the start and end boundaries have the same parent element, the
                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes
                    // the start boundary
                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,
                        startBoundary.nodeInfo).boundaryPosition;
                }

                this.setStart(start.node, start.offset);
                this.setEnd(end.node, end.offset);
            };

            WrappedTextRange.prototype.getName = function() {
                return "WrappedTextRange";
            };

            DomRange.copyComparisonConstants(WrappedTextRange);

            var rangeToTextRange = function(range) {
                if (range.collapsed) {
                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                } else {
                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();
                    textRange.setEndPoint("StartToStart", startRange);
                    textRange.setEndPoint("EndToEnd", endRange);
                    return textRange;
                }
            };

            WrappedTextRange.rangeToTextRange = rangeToTextRange;

            WrappedTextRange.prototype.toTextRange = function() {
                return rangeToTextRange(this);
            };

            api.WrappedTextRange = WrappedTextRange;

            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which
            // implementation to use by default.
            if (!api.features.implementsDomRange || api.config.preferTextRange) {
                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work
                var globalObj = (function(f) { return f("return this;")(); })(Function);
                if (typeof globalObj.Range == "undefined") {
                    globalObj.Range = WrappedTextRange;
                }

                api.createNativeRange = function(doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return getBody(doc).createTextRange();
                };

                api.WrappedRange = WrappedTextRange;
            }
        }

        api.createRange = function(doc) {
            doc = getContentDocument(doc, module, "createRange");
            return new api.WrappedRange(api.createNativeRange(doc));
        };

        api.createRangyRange = function(doc) {
            doc = getContentDocument(doc, module, "createRangyRange");
            return new DomRange(doc);
        };

        util.createAliasForDeprecatedMethod(api, "createIframeRange", "createRange");
        util.createAliasForDeprecatedMethod(api, "createIframeRangyRange", "createRangyRange");

        api.addShimListener(function(win) {
            var doc = win.document;
            if (typeof doc.createRange == "undefined") {
                doc.createRange = function() {
                    return api.createRange(doc);
                };
            }
            doc = win = null;
        });
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification
    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)
    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {
        api.config.checkSelectionRanges = true;

        var BOOLEAN = "boolean";
        var NUMBER = "number";
        var dom = api.dom;
        var util = api.util;
        var isHostMethod = util.isHostMethod;
        var DomRange = api.DomRange;
        var WrappedRange = api.WrappedRange;
        var DOMException = api.DOMException;
        var DomPosition = dom.DomPosition;
        var getNativeSelection;
        var selectionIsCollapsed;
        var features = api.features;
        var CONTROL = "Control";
        var getDocument = dom.getDocument;
        var getBody = dom.getBody;
        var rangesEqual = DomRange.rangesEqual;


        // Utility function to support direction parameters in the API that may be a string ("backward", "backwards",
        // "forward" or "forwards") or a Boolean (true for backwards).
        function isDirectionBackward(dir) {
            return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;
        }

        function getWindow(win, methodName) {
            if (!win) {
                return window;
            } else if (dom.isWindow(win)) {
                return win;
            } else if (win instanceof WrappedSelection) {
                return win.win;
            } else {
                var doc = dom.getContentDocument(win, module, methodName);
                return dom.getWindow(doc);
            }
        }

        function getWinSelection(winParam) {
            return getWindow(winParam, "getWinSelection").getSelection();
        }

        function getDocSelection(winParam) {
            return getWindow(winParam, "getDocSelection").document.selection;
        }

        function winSelectionIsBackward(sel) {
            var backward = false;
            if (sel.anchorNode) {
                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);
            }
            return backward;
        }

        // Test for the Range/TextRange and Selection features required
        // Test for ability to retrieve selection
        var implementsWinGetSelection = isHostMethod(window, "getSelection"),
            implementsDocSelection = util.isHostObject(document, "selection");

        features.implementsWinGetSelection = implementsWinGetSelection;
        features.implementsDocSelection = implementsDocSelection;

        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);

        if (useDocumentSelection) {
            getNativeSelection = getDocSelection;
            api.isSelectionValid = function(winParam) {
                var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;

                // Check whether the selection TextRange is actually contained within the correct document
                return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);
            };
        } else if (implementsWinGetSelection) {
            getNativeSelection = getWinSelection;
            api.isSelectionValid = function() {
                return true;
            };
        } else {
            module.fail("Neither document.selection or window.getSelection() detected.");
            return false;
        }

        api.getNativeSelection = getNativeSelection;

        var testSelection = getNativeSelection();

        // In Firefox, the selection is null in an iframe with display: none. See issue #138.
        if (!testSelection) {
            module.fail("Native selection was null (possibly issue 138?)");
            return false;
        }

        var testRange = api.createNativeRange(document);
        var body = getBody(document);

        // Obtaining a range from a selection
        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,
            ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);

        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;

        // Test for existence of native selection extend() method
        var selectionHasExtend = isHostMethod(testSelection, "extend");
        features.selectionHasExtend = selectionHasExtend;

        // Test if rangeCount exists
        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);
        features.selectionHasRangeCount = selectionHasRangeCount;

        var selectionSupportsMultipleRanges = false;
        var collapsedNonEditableSelectionsSupported = true;

        var addRangeBackwardToNative = selectionHasExtend ?
            function(nativeSelection, range) {
                var doc = DomRange.getRangeDocument(range);
                var endRange = api.createRange(doc);
                endRange.collapseToPoint(range.endContainer, range.endOffset);
                nativeSelection.addRange(getNativeRange(endRange));
                nativeSelection.extend(range.startContainer, range.startOffset);
            } : null;

        if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&
                typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {

            (function() {
                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are
                // performed on the current document's selection. See issue 109.

                // Note also that if a selection previously existed, it is wiped and later restored by these tests. This
                // will result in the selection direction begin reversed if the original selection was backwards and the
                // browser does not support setting backwards selections (Internet Explorer, I'm looking at you).
                var sel = window.getSelection();
                if (sel) {
                    // Store the current selection
                    var originalSelectionRangeCount = sel.rangeCount;
                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);
                    var originalSelectionRanges = [];
                    var originalSelectionBackward = winSelectionIsBackward(sel);
                    for (var i = 0; i < originalSelectionRangeCount; ++i) {
                        originalSelectionRanges[i] = sel.getRangeAt(i);
                    }

                    // Create some test elements
                    var testEl = dom.createTestElement(document, "", false);
                    var textNode = testEl.appendChild( document.createTextNode("\u00a0\u00a0\u00a0") );

                    // Test whether the native selection will allow a collapsed selection within a non-editable element
                    var r1 = document.createRange();

                    r1.setStart(textNode, 1);
                    r1.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(r1);
                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);
                    sel.removeAllRanges();

                    // Test whether the native selection is capable of supporting multiple ranges.
                    if (!selectionHasMultipleRanges) {
                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a
                        // console error of "Discontiguous selection is not supported." that cannot be suppressed. There's
                        // nothing we can do about this while retaining the feature test so we have to resort to a browser
                        // sniff. I'm not happy about it. See
                        // https://code.google.com/p/chromium/issues/detail?id=399791
                        var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
                            selectionSupportsMultipleRanges = false;
                        } else {
                            var r2 = r1.cloneRange();
                            r1.setStart(textNode, 0);
                            r2.setEnd(textNode, 3);
                            r2.setStart(textNode, 2);
                            sel.addRange(r1);
                            sel.addRange(r2);
                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);
                        }
                    }

                    // Clean up
                    dom.removeNode(testEl);
                    sel.removeAllRanges();

                    for (i = 0; i < originalSelectionRangeCount; ++i) {
                        if (i == 0 && originalSelectionBackward) {
                            if (addRangeBackwardToNative) {
                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);
                            } else {
                                api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
                                sel.addRange(originalSelectionRanges[i]);
                            }
                        } else {
                            sel.addRange(originalSelectionRanges[i]);
                        }
                    }
                }
            })();
        }

        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;

        // ControlRanges
        var implementsControlRange = false, testControlRange;

        if (body && isHostMethod(body, "createControlRange")) {
            testControlRange = body.createControlRange();
            if (util.areHostProperties(testControlRange, ["item", "add"])) {
                implementsControlRange = true;
            }
        }
        features.implementsControlRange = implementsControlRange;

        // Selection collapsedness
        if (selectionHasAnchorAndFocus) {
            selectionIsCollapsed = function(sel) {
                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
            };
        } else {
            selectionIsCollapsed = function(sel) {
                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
            };
        }

        function updateAnchorAndFocusFromRange(sel, range, backward) {
            var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
            sel.anchorNode = range[anchorPrefix + "Container"];
            sel.anchorOffset = range[anchorPrefix + "Offset"];
            sel.focusNode = range[focusPrefix + "Container"];
            sel.focusOffset = range[focusPrefix + "Offset"];
        }

        function updateAnchorAndFocusFromNativeSelection(sel) {
            var nativeSel = sel.nativeSelection;
            sel.anchorNode = nativeSel.anchorNode;
            sel.anchorOffset = nativeSel.anchorOffset;
            sel.focusNode = nativeSel.focusNode;
            sel.focusOffset = nativeSel.focusOffset;
        }

        function updateEmptySelection(sel) {
            sel.anchorNode = sel.focusNode = null;
            sel.anchorOffset = sel.focusOffset = 0;
            sel.rangeCount = 0;
            sel.isCollapsed = true;
            sel._ranges.length = 0;
        }

        function getNativeRange(range) {
            var nativeRange;
            if (range instanceof DomRange) {
                nativeRange = api.createNativeRange(range.getDocument());
                nativeRange.setEnd(range.endContainer, range.endOffset);
                nativeRange.setStart(range.startContainer, range.startOffset);
            } else if (range instanceof WrappedRange) {
                nativeRange = range.nativeRange;
            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {
                nativeRange = range;
            }
            return nativeRange;
        }

        function rangeContainsSingleElement(rangeNodes) {
            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
                return false;
            }
            for (var i = 1, len = rangeNodes.length; i < len; ++i) {
                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
                    return false;
                }
            }
            return true;
        }

        function getSingleElementFromRange(range) {
            var nodes = range.getNodes();
            if (!rangeContainsSingleElement(nodes)) {
                throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
            }
            return nodes[0];
        }

        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange
        function isTextRange(range) {
            return !!range && typeof range.text != "undefined";
        }

        function updateFromTextRange(sel, range) {
            // Create a Range from the selected TextRange
            var wrappedRange = new WrappedRange(range);
            sel._ranges = [wrappedRange];

            updateAnchorAndFocusFromRange(sel, wrappedRange, false);
            sel.rangeCount = 1;
            sel.isCollapsed = wrappedRange.collapsed;
        }

        function updateControlSelection(sel) {
            // Update the wrapped selection based on what's now in the native selection
            sel._ranges.length = 0;
            if (sel.docSelection.type == "None") {
                updateEmptySelection(sel);
            } else {
                var controlRange = sel.docSelection.createRange();
                if (isTextRange(controlRange)) {
                    // This case (where the selection type is "Control" and calling createRange() on the selection returns
                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected
                    // ControlRange have been removed from the ControlRange and removed from the document.
                    updateFromTextRange(sel, controlRange);
                } else {
                    sel.rangeCount = controlRange.length;
                    var range, doc = getDocument(controlRange.item(0));
                    for (var i = 0; i < sel.rangeCount; ++i) {
                        range = api.createRange(doc);
                        range.selectNode(controlRange.item(i));
                        sel._ranges.push(range);
                    }
                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
                }
            }
        }

        function addRangeToControlSelection(sel, range) {
            var controlRange = sel.docSelection.createRange();
            var rangeElement = getSingleElementFromRange(range);

            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element
            // contained by the supplied range
            var doc = getDocument(controlRange.item(0));
            var newControlRange = getBody(doc).createControlRange();
            for (var i = 0, len = controlRange.length; i < len; ++i) {
                newControlRange.add(controlRange.item(i));
            }
            try {
                newControlRange.add(rangeElement);
            } catch (ex) {
                throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
            }
            newControlRange.select();

            // Update the wrapped selection based on what's now in the native selection
            updateControlSelection(sel);
        }

        var getSelectionRangeAt;

        if (isHostMethod(testSelection, "getRangeAt")) {
            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.
            // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a
            // lesson to us all, especially me.
            getSelectionRangeAt = function(sel, index) {
                try {
                    return sel.getRangeAt(index);
                } catch (ex) {
                    return null;
                }
            };
        } else if (selectionHasAnchorAndFocus) {
            getSelectionRangeAt = function(sel) {
                var doc = getDocument(sel.anchorNode);
                var range = api.createRange(doc);
                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);

                // Handle the case when the selection was selected backwards (from the end to the start in the
                // document)
                if (range.collapsed !== this.isCollapsed) {
                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
                }

                return range;
            };
        }

        function WrappedSelection(selection, docSelection, win) {
            this.nativeSelection = selection;
            this.docSelection = docSelection;
            this._ranges = [];
            this.win = win;
            this.refresh();
        }

        WrappedSelection.prototype = api.selectionPrototype;

        function deleteProperties(sel) {
            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
            sel.detached = true;
        }

        var cachedRangySelections = [];

        function actOnCachedSelection(win, action) {
            var i = cachedRangySelections.length, cached, sel;
            while (i--) {
                cached = cachedRangySelections[i];
                sel = cached.selection;
                if (action == "deleteAll") {
                    deleteProperties(sel);
                } else if (cached.win == win) {
                    if (action == "delete") {
                        cachedRangySelections.splice(i, 1);
                        return true;
                    } else {
                        return sel;
                    }
                }
            }
            if (action == "deleteAll") {
                cachedRangySelections.length = 0;
            }
            return null;
        }

        var getSelection = function(win) {
            // Check if the parameter is a Rangy Selection object
            if (win && win instanceof WrappedSelection) {
                win.refresh();
                return win;
            }

            win = getWindow(win, "getNativeSelection");

            var sel = actOnCachedSelection(win);
            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
            if (sel) {
                sel.nativeSelection = nativeSel;
                sel.docSelection = docSel;
                sel.refresh();
            } else {
                sel = new WrappedSelection(nativeSel, docSel, win);
                cachedRangySelections.push( { win: win, selection: sel } );
            }
            return sel;
        };

        api.getSelection = getSelection;

        util.createAliasForDeprecatedMethod(api, "getIframeSelection", "getSelection");

        var selProto = WrappedSelection.prototype;

        function createControlSelection(sel, ranges) {
            // Ensure that the selection becomes of type "Control"
            var doc = getDocument(ranges[0].startContainer);
            var controlRange = getBody(doc).createControlRange();
            for (var i = 0, el, len = ranges.length; i < len; ++i) {
                el = getSingleElementFromRange(ranges[i]);
                try {
                    controlRange.add(el);
                } catch (ex) {
                    throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
                }
            }
            controlRange.select();

            // Update the wrapped selection based on what's now in the native selection
            updateControlSelection(sel);
        }

        // Selecting a range
        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
            selProto.removeAllRanges = function() {
                this.nativeSelection.removeAllRanges();
                updateEmptySelection(this);
            };

            var addRangeBackward = function(sel, range) {
                addRangeBackwardToNative(sel.nativeSelection, range);
                sel.refresh();
            };

            if (selectionHasRangeCount) {
                selProto.addRange = function(range, direction) {
                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                        addRangeToControlSelection(this, range);
                    } else {
                        if (isDirectionBackward(direction) && selectionHasExtend) {
                            addRangeBackward(this, range);
                        } else {
                            var previousRangeCount;
                            if (selectionSupportsMultipleRanges) {
                                previousRangeCount = this.rangeCount;
                            } else {
                                this.removeAllRanges();
                                previousRangeCount = 0;
                            }
                            // Clone the native range so that changing the selected range does not affect the selection.
                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See
                            // issue 80.
                            var clonedNativeRange = getNativeRange(range).cloneRange();
                            try {
                                this.nativeSelection.addRange(clonedNativeRange);
                            } catch (ex) {
                            }

                            // Check whether adding the range was successful
                            this.rangeCount = this.nativeSelection.rangeCount;

                            if (this.rangeCount == previousRangeCount + 1) {
                                // The range was added successfully

                                // Check whether the range that we added to the selection is reflected in the last range extracted from
                                // the selection
                                if (api.config.checkSelectionRanges) {
                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                                    if (nativeRange && !rangesEqual(nativeRange, range)) {
                                        // Happens in WebKit with, for example, a selection placed at the start of a text node
                                        range = new WrappedRange(nativeRange);
                                    }
                                }
                                this._ranges[this.rangeCount - 1] = range;
                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
                                this.isCollapsed = selectionIsCollapsed(this);
                            } else {
                                // The range was not added successfully. The simplest thing is to refresh
                                this.refresh();
                            }
                        }
                    }
                };
            } else {
                selProto.addRange = function(range, direction) {
                    if (isDirectionBackward(direction) && selectionHasExtend) {
                        addRangeBackward(this, range);
                    } else {
                        this.nativeSelection.addRange(getNativeRange(range));
                        this.refresh();
                    }
                };
            }

            selProto.setRanges = function(ranges) {
                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
                    createControlSelection(this, ranges);
                } else {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        this.addRange(ranges[i]);
                    }
                }
            };
        } else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&
                   implementsControlRange && useDocumentSelection) {

            selProto.removeAllRanges = function() {
                // Added try/catch as fix for issue #21
                try {
                    this.docSelection.empty();

                    // Check for empty() not working (issue #24)
                    if (this.docSelection.type != "None") {
                        // Work around failure to empty a control selection by instead selecting a TextRange and then
                        // calling empty()
                        var doc;
                        if (this.anchorNode) {
                            doc = getDocument(this.anchorNode);
                        } else if (this.docSelection.type == CONTROL) {
                            var controlRange = this.docSelection.createRange();
                            if (controlRange.length) {
                                doc = getDocument( controlRange.item(0) );
                            }
                        }
                        if (doc) {
                            var textRange = getBody(doc).createTextRange();
                            textRange.select();
                            this.docSelection.empty();
                        }
                    }
                } catch(ex) {}
                updateEmptySelection(this);
            };

            selProto.addRange = function(range) {
                if (this.docSelection.type == CONTROL) {
                    addRangeToControlSelection(this, range);
                } else {
                    api.WrappedTextRange.rangeToTextRange(range).select();
                    this._ranges[0] = range;
                    this.rangeCount = 1;
                    this.isCollapsed = this._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(this, range, false);
                }
            };

            selProto.setRanges = function(ranges) {
                this.removeAllRanges();
                var rangeCount = ranges.length;
                if (rangeCount > 1) {
                    createControlSelection(this, ranges);
                } else if (rangeCount) {
                    this.addRange(ranges[0]);
                }
            };
        } else {
            module.fail("No means of selecting a Range or TextRange was found");
            return false;
        }

        selProto.getRangeAt = function(index) {
            if (index < 0 || index >= this.rangeCount) {
                throw new DOMException("INDEX_SIZE_ERR");
            } else {
                // Clone the range to preserve selection-range independence. See issue 80.
                return this._ranges[index].cloneRange();
            }
        };

        var refreshSelection;

        if (useDocumentSelection) {
            refreshSelection = function(sel) {
                var range;
                if (api.isSelectionValid(sel.win)) {
                    range = sel.docSelection.createRange();
                } else {
                    range = getBody(sel.win.document).createTextRange();
                    range.collapse(true);
                }

                if (sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                } else if (isTextRange(range)) {
                    updateFromTextRange(sel, range);
                } else {
                    updateEmptySelection(sel);
                }
            };
        } else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
            refreshSelection = function(sel) {
                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                } else {
                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
                    if (sel.rangeCount) {
                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
                        }
                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
                        sel.isCollapsed = selectionIsCollapsed(sel);
                    } else {
                        updateEmptySelection(sel);
                    }
                }
            };
        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
            refreshSelection = function(sel) {
                var range, nativeSel = sel.nativeSelection;
                if (nativeSel.anchorNode) {
                    range = getSelectionRangeAt(nativeSel, 0);
                    sel._ranges = [range];
                    sel.rangeCount = 1;
                    updateAnchorAndFocusFromNativeSelection(sel);
                    sel.isCollapsed = selectionIsCollapsed(sel);
                } else {
                    updateEmptySelection(sel);
                }
            };
        } else {
            module.fail("No means of obtaining a Range or TextRange from the user's selection was found");
            return false;
        }

        selProto.refresh = function(checkForChanges) {
            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;

            refreshSelection(this);
            if (checkForChanges) {
                // Check the range count first
                var i = oldRanges.length;
                if (i != this._ranges.length) {
                    return true;
                }

                // Now check the direction. Checking the anchor position is the same is enough since we're checking all the
                // ranges after this
                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
                    return true;
                }

                // Finally, compare each range in turn
                while (i--) {
                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {
                        return true;
                    }
                }
                return false;
            }
        };

        // Removal of a single range
        var removeRangeManually = function(sel, range) {
            var ranges = sel.getAllRanges();
            sel.removeAllRanges();
            for (var i = 0, len = ranges.length; i < len; ++i) {
                if (!rangesEqual(range, ranges[i])) {
                    sel.addRange(ranges[i]);
                }
            }
            if (!sel.rangeCount) {
                updateEmptySelection(sel);
            }
        };

        if (implementsControlRange && implementsDocSelection) {
            selProto.removeRange = function(range) {
                if (this.docSelection.type == CONTROL) {
                    var controlRange = this.docSelection.createRange();
                    var rangeElement = getSingleElementFromRange(range);

                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the
                    // element contained by the supplied range
                    var doc = getDocument(controlRange.item(0));
                    var newControlRange = getBody(doc).createControlRange();
                    var el, removed = false;
                    for (var i = 0, len = controlRange.length; i < len; ++i) {
                        el = controlRange.item(i);
                        if (el !== rangeElement || removed) {
                            newControlRange.add(controlRange.item(i));
                        } else {
                            removed = true;
                        }
                    }
                    newControlRange.select();

                    // Update the wrapped selection based on what's now in the native selection
                    updateControlSelection(this);
                } else {
                    removeRangeManually(this, range);
                }
            };
        } else {
            selProto.removeRange = function(range) {
                removeRangeManually(this, range);
            };
        }

        // Detecting if a selection is backward
        var selectionIsBackward;
        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
            selectionIsBackward = winSelectionIsBackward;

            selProto.isBackward = function() {
                return selectionIsBackward(this);
            };
        } else {
            selectionIsBackward = selProto.isBackward = function() {
                return false;
            };
        }

        // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"
        selProto.isBackwards = selProto.isBackward;

        // Selection stringifier
        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.
        // The current spec does not yet define this method.
        selProto.toString = function() {
            var rangeTexts = [];
            for (var i = 0, len = this.rangeCount; i < len; ++i) {
                rangeTexts[i] = "" + this._ranges[i];
            }
            return rangeTexts.join("");
        };

        function assertNodeInSameDocument(sel, node) {
            if (sel.win.document != getDocument(node)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }

        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used
        selProto.collapse = function(node, offset) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.collapseToPoint(node, offset);
            this.setSingleRange(range);
            this.isCollapsed = true;
        };

        selProto.collapseToStart = function() {
            if (this.rangeCount) {
                var range = this._ranges[0];
                this.collapse(range.startContainer, range.startOffset);
            } else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };

        selProto.collapseToEnd = function() {
            if (this.rangeCount) {
                var range = this._ranges[this.rangeCount - 1];
                this.collapse(range.endContainer, range.endOffset);
            } else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };

        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as
        // specified so the native implementation is never used by Rangy.
        selProto.selectAllChildren = function(node) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.selectNodeContents(node);
            this.setSingleRange(range);
        };

        selProto.deleteFromDocument = function() {
            // Sepcial behaviour required for IE's control selections
            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                var controlRange = this.docSelection.createRange();
                var element;
                while (controlRange.length) {
                    element = controlRange.item(0);
                    controlRange.remove(element);
                    dom.removeNode(element);
                }
                this.refresh();
            } else if (this.rangeCount) {
                var ranges = this.getAllRanges();
                if (ranges.length) {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        ranges[i].deleteContents();
                    }
                    // The spec says nothing about what the selection should contain after calling deleteContents on each
                    // range. Firefox moves the selection to where the final selected range was, so we emulate that
                    this.addRange(ranges[len - 1]);
                }
            }
        };

        // The following are non-standard extensions
        selProto.eachRange = function(func, returnValue) {
            for (var i = 0, len = this._ranges.length; i < len; ++i) {
                if ( func( this.getRangeAt(i) ) ) {
                    return returnValue;
                }
            }
        };

        selProto.getAllRanges = function() {
            var ranges = [];
            this.eachRange(function(range) {
                ranges.push(range);
            });
            return ranges;
        };

        selProto.setSingleRange = function(range, direction) {
            this.removeAllRanges();
            this.addRange(range, direction);
        };

        selProto.callMethodOnEachRange = function(methodName, params) {
            var results = [];
            this.eachRange( function(range) {
                results.push( range[methodName].apply(range, params || []) );
            } );
            return results;
        };

        function createStartOrEndSetter(isStart) {
            return function(node, offset) {
                var range;
                if (this.rangeCount) {
                    range = this.getRangeAt(0);
                    range["set" + (isStart ? "Start" : "End")](node, offset);
                } else {
                    range = api.createRange(this.win.document);
                    range.setStartAndEnd(node, offset);
                }
                this.setSingleRange(range, this.isBackward());
            };
        }

        selProto.setStart = createStartOrEndSetter(true);
        selProto.setEnd = createStartOrEndSetter(false);

        // Add select() method to Range prototype. Any existing selection will be removed.
        api.rangePrototype.select = function(direction) {
            getSelection( this.getDocument() ).setSingleRange(this, direction);
        };

        selProto.changeEachRange = function(func) {
            var ranges = [];
            var backward = this.isBackward();

            this.eachRange(function(range) {
                func(range);
                ranges.push(range);
            });

            this.removeAllRanges();
            if (backward && ranges.length == 1) {
                this.addRange(ranges[0], "backward");
            } else {
                this.setRanges(ranges);
            }
        };

        selProto.containsNode = function(node, allowPartial) {
            return this.eachRange( function(range) {
                return range.containsNode(node, allowPartial);
            }, true ) || false;
        };

        selProto.getBookmark = function(containerNode) {
            return {
                backward: this.isBackward(),
                rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
            };
        };

        selProto.moveToBookmark = function(bookmark) {
            var selRanges = [];
            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {
                range = api.createRange(this.win);
                range.moveToBookmark(rangeBookmark);
                selRanges.push(range);
            }
            if (bookmark.backward) {
                this.setSingleRange(selRanges[0], "backward");
            } else {
                this.setRanges(selRanges);
            }
        };

        selProto.saveRanges = function() {
            return {
                backward: this.isBackward(),
                ranges: this.callMethodOnEachRange("cloneRange")
            };
        };

        selProto.restoreRanges = function(selRanges) {
            this.removeAllRanges();
            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {
                this.addRange(range, (selRanges.backward && i == 0));
            }
        };

        selProto.toHtml = function() {
            var rangeHtmls = [];
            this.eachRange(function(range) {
                rangeHtmls.push( DomRange.toHtml(range) );
            });
            return rangeHtmls.join("");
        };

        if (features.implementsTextRange) {
            selProto.getNativeTextRange = function() {
                var sel, textRange;
                if ( (sel = this.docSelection) ) {
                    var range = sel.createRange();
                    if (isTextRange(range)) {
                        return range;
                    } else {
                        throw module.createError("getNativeTextRange: selection is a control selection");
                    }
                } else if (this.rangeCount > 0) {
                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );
                } else {
                    throw module.createError("getNativeTextRange: selection contains no range");
                }
            };
        }

        function inspect(sel) {
            var rangeInspects = [];
            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
            var focus = new DomPosition(sel.focusNode, sel.focusOffset);
            var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";

            if (typeof sel.rangeCount != "undefined") {
                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
                }
            }
            return "[" + name + "(Ranges: " + rangeInspects.join(", ") +
                    ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
        }

        selProto.getName = function() {
            return "WrappedSelection";
        };

        selProto.inspect = function() {
            return inspect(this);
        };

        selProto.detach = function() {
            actOnCachedSelection(this.win, "delete");
            deleteProperties(this);
        };

        WrappedSelection.detachAll = function() {
            actOnCachedSelection(null, "deleteAll");
        };

        WrappedSelection.inspect = inspect;
        WrappedSelection.isDirectionBackward = isDirectionBackward;

        api.Selection = WrappedSelection;

        api.selectionPrototype = selProto;

        api.addShimListener(function(win) {
            if (typeof win.getSelection == "undefined") {
                win.getSelection = function() {
                    return getSelection(win);
                };
            }
            win = null;
        });
    });
    

    /*----------------------------------------------------------------------------------------------------------------*/

    // Wait for document to load before initializing
    var docReady = false;

    var loadHandler = function(e) {
        if (!docReady) {
            docReady = true;
            if (!api.initialized && api.config.autoInitialize) {
                init();
            }
        }
    };

    if (isBrowser) {
        // Test whether the document has already been loaded and initialize immediately if so
        if (document.readyState == "complete") {
            loadHandler();
        } else {
            if (isHostMethod(document, "addEventListener")) {
                document.addEventListener("DOMContentLoaded", loadHandler, false);
            }

            // Add a fallback in case the DOMContentLoaded event isn't supported
            addListener(window, "load", loadHandler);
        }
    }

    return api;
}, this);
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9idWlsZGVyLmpzIiwianMvbW9kdWxlcy9idWlsZGVyLmpzIiwianMvbW9kdWxlcy9jYW52YXNFbGVtZW50LmpzIiwianMvbW9kdWxlcy9jb25maWcuanMiLCJqcy9tb2R1bGVzL2NvbnRlbnQuanMiLCJqcy9tb2R1bGVzL2V4cG9ydC5qcyIsImpzL21vZHVsZXMvbWVkaXVtRWRpdG9yRXh0ZW5zaW9ucy5qcyIsImpzL21vZHVsZXMvcHJldmlldy5qcyIsImpzL21vZHVsZXMvc3R5bGVlZGl0b3IuanMiLCJqcy9tb2R1bGVzL3VpLmpzIiwianMvbW9kdWxlcy91dGlscy5qcyIsImpzL3ZlbmRvci9wdWJsaXNoZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaXVtLWVkaXRvci9kaXN0L2pzL21lZGl1bS1lZGl0b3IuanMiLCJub2RlX21vZHVsZXMvcmFuZ3kvbGliL3Jhbmd5LWNsYXNzYXBwbGllci5qcyIsIm5vZGVfbW9kdWxlcy9yYW5neS9saWIvcmFuZ3ktY29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6L05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMva0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XHRcblxuXHRyZXF1aXJlKCcuL21vZHVsZXMvY29uZmlnLmpzJyk7XG5cdHJlcXVpcmUoJy4vbW9kdWxlcy91aS5qcycpO1xuXHRyZXF1aXJlKCcuL21vZHVsZXMvYnVpbGRlci5qcycpO1xuXHRyZXF1aXJlKCcuL21vZHVsZXMvdXRpbHMuanMnKTtcblx0cmVxdWlyZSgnLi9tb2R1bGVzL2NhbnZhc0VsZW1lbnQuanMnKTtcblx0cmVxdWlyZSgnLi9tb2R1bGVzL3N0eWxlZWRpdG9yLmpzJyk7XG5cdHJlcXVpcmUoJy4vbW9kdWxlcy9jb250ZW50LmpzJyk7XG5cdHJlcXVpcmUoJy4vbW9kdWxlcy9leHBvcnQuanMnKTtcblx0cmVxdWlyZSgnLi9tb2R1bGVzL3ByZXZpZXcuanMnKTtcblxufSgpKTsiLCIoZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBzaXRlQnVpbGRlclV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuICAgIHZhciBiQ29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcuanMnKTtcbiAgICB2YXIgYXBwVUkgPSByZXF1aXJlKCcuL3VpLmpzJykuYXBwVUk7XG4gICAgdmFyIHB1Ymxpc2hlciA9IHJlcXVpcmUoJy4uL3ZlbmRvci9wdWJsaXNoZXInKTtcblxuXG5cdCAvKlxuICAgICAgICBCYXNpYyBCdWlsZGVyIFVJIGluaXRpYWxpc2F0aW9uXG4gICAgKi9cbiAgICB2YXIgYnVpbGRlclVJID0ge1xuICAgICAgICBcbiAgICAgICAgYWxsQmxvY2tzOiB7fSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob2xkcyBhbGwgYmxvY2tzIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgbWVudVdyYXBwZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51JyksXG4gICAgICAgIHByaW1hcnlTaWRlTWVudVdyYXBwZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJyksXG4gICAgICAgIGJ1dHRvbkJhY2s6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYWNrQnV0dG9uJyksXG4gICAgICAgIGJ1dHRvbkJhY2tDb25maXJtOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVhdmVQYWdlQnV0dG9uJyksXG4gICAgICAgIFxuICAgICAgICBzaXRlQnVpbGRlck1vZGVzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2l0ZUJ1aWxkZXJNb2RlcycpLFxuICAgICAgICBhY2VFZGl0b3JzOiB7fSxcbiAgICAgICAgZnJhbWVDb250ZW50czogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hvbGRzIGZyYW1lIGNvbnRlbnRzXG4gICAgICAgIHRlbXBsYXRlSUQ6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob2xkcyB0aGUgdGVtcGxhdGUgSUQgZm9yIGEgcGFnZSAoPz8/KVxuICAgICAgICByYWRpb0Jsb2NrTW9kZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGVCbG9jaycpLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICBtb2RhbERlbGV0ZUJsb2NrOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVsZXRlQmxvY2snKSxcbiAgICAgICAgbW9kYWxSZXNldEJsb2NrOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXRCbG9jaycpLFxuICAgICAgICBtb2RhbERlbGV0ZVBhZ2U6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWxldGVQYWdlJyksXG4gICAgICAgIGJ1dHRvbkRlbGV0ZVBhZ2VDb25maXJtOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVsZXRlUGFnZUNvbmZpcm0nKSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgdGVtcEZyYW1lOiB7fSxcblxuICAgICAgICBjdXJyZW50UmVzcG9uc2l2ZU1vZGU6IHt9LFxuICAgICAgICAgICAgICAgIFxuICAgICAgICBpbml0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2xvYWQgYmxvY2tzXG4gICAgICAgICAgICAkLmdldEpTT04oJ2VsZW1lbnRzLmpzb24/dj0xMjM0NTY3OCcsIGZ1bmN0aW9uKGRhdGEpeyBidWlsZGVyVUkuYWxsQmxvY2tzID0gZGF0YTsgYnVpbGRlclVJLmltcGxlbWVudEJsb2NrcygpOyB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zaXRlYmFyIGhvdmVyIGFuaW1hdGlvbiBhY3Rpb25cbiAgICAgICAgICAgICQodGhpcy5tZW51V3JhcHBlcikub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQodGhpcykuc3RvcCgpLmFuaW1hdGUoeydsZWZ0JzogJzBweCd9LCA1MDApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQodGhpcykuc3RvcCgpLmFuaW1hdGUoeydsZWZ0JzogJy0xOTBweCd9LCA1MDApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoJyNtZW51ICNtYWluIGEnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgJCgnLm1lbnUgLnNlY29uZCcpLnN0b3AoKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgICAgICB9LCA1MDAsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICQoJyNtZW51ICNzZWNvbmQnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9wcmV2ZW50IGNsaWNrIGV2ZW50IG9uIGFuY29ycyBpbiB0aGUgYmxvY2sgc2VjdGlvbiBvZiB0aGUgc2lkZWJhclxuICAgICAgICAgICAgJCh0aGlzLnByaW1hcnlTaWRlTWVudVdyYXBwZXIpLm9uKCdjbGljaycsICdhOm5vdCguYWN0aW9uQnV0dG9ucyknLCBmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCk7fSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQodGhpcy5idXR0b25CYWNrKS5vbignY2xpY2snLCB0aGlzLmJhY2tCdXR0b24pO1xuICAgICAgICAgICAgJCh0aGlzLmJ1dHRvbkJhY2tDb25maXJtKS5vbignY2xpY2snLCB0aGlzLmJhY2tCdXR0b25Db25maXJtKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9ub3RpZnkgdGhlIHVzZXIgb2YgcGVuZGluZyBjaG5hZ2VzIHdoZW4gY2xpY2tpbmcgdGhlIGJhY2sgYnV0dG9uXG4gICAgICAgICAgICAkKHdpbmRvdykuYmluZCgnYmVmb3JldW5sb2FkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiggc2l0ZS5wZW5kaW5nQ2hhbmdlcyA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdZb3VyIHNpdGUgY29udGFpbnMgY2hhbmdlZCB3aGljaCBoYXZlblxcJ3QgYmVlbiBzYXZlZCB5ZXQuIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBsZWF2ZT8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGJ1aWxkcyB0aGUgYmxvY2tzIGludG8gdGhlIHNpdGUgYmFyXG4gICAgICAgICovXG4gICAgICAgIGltcGxlbWVudEJsb2NrczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBuZXdJdGVtLCBsb2FkZXJGdW5jdGlvbjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKCB2YXIga2V5IGluIHRoaXMuYWxsQmxvY2tzLmVsZW1lbnRzICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBuaWNlS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZShcIiBcIiwgXCJfXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoJzxsaT48YSBocmVmPVwiXCIgaWQ9XCInK25pY2VLZXkrJ1wiPicra2V5Kyc8L2E+PC9saT4nKS5hcHBlbmRUbygnI21lbnUgI21haW4gdWwjZWxlbWVudENhdHMnKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IoIHZhciB4ID0gMDsgeCA8IHRoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV0ubGVuZ3RoOyB4KysgKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5hbGxCbG9ja3MuZWxlbWVudHNba2V5XVt4XS50aHVtYm5haWwgPT09IG51bGwgKSB7Ly93ZSdsbCBuZWVkIGFuIGlmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2J1aWxkIHVzIHNvbWUgaWZyYW1lcyFcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHRoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV1beF0uc2FuZGJveCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5hbGxCbG9ja3MuZWxlbWVudHNba2V5XVt4XS5sb2FkZXJGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVyRnVuY3Rpb24gPSAnZGF0YS1sb2FkZXJmdW5jdGlvbj1cIicrdGhpcy5hbGxCbG9ja3MuZWxlbWVudHNba2V5XVt4XS5sb2FkZXJGdW5jdGlvbisnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtID0gJCgnPGxpIGNsYXNzPVwiZWxlbWVudCAnK25pY2VLZXkrJ1wiPjxpZnJhbWUgc3JjPVwiJyt0aGlzLmFsbEJsb2Nrcy5lbGVtZW50c1trZXldW3hdLnVybCsnXCIgc2Nyb2xsaW5nPVwibm9cIiBzYW5kYm94PVwiYWxsb3ctc2FtZS1vcmlnaW5cIj48L2lmcmFtZT48L2xpPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSAkKCc8bGkgY2xhc3M9XCJlbGVtZW50ICcrbmljZUtleSsnXCI+PGlmcmFtZSBzcmM9XCJhYm91dDpibGFua1wiIHNjcm9sbGluZz1cIm5vXCI+PC9pZnJhbWU+PC9saT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLmZpbmQoJ2lmcmFtZScpLnVuaXF1ZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLmZpbmQoJ2lmcmFtZScpLmF0dHIoJ3NyYycsIHRoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV1beF0udXJsKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7Ly93ZSd2ZSBnb3QgYSB0aHVtYm5haWxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHRoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV1beF0uc2FuZGJveCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5hbGxCbG9ja3MuZWxlbWVudHNba2V5XVt4XS5sb2FkZXJGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVyRnVuY3Rpb24gPSAnZGF0YS1sb2FkZXJmdW5jdGlvbj1cIicrdGhpcy5hbGxCbG9ja3MuZWxlbWVudHNba2V5XVt4XS5sb2FkZXJGdW5jdGlvbisnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtID0gJCgnPGxpIGNsYXNzPVwiZWxlbWVudCAnK25pY2VLZXkrJ1wiPjxpbWcgc3JjPVwiJyt0aGlzLmFsbEJsb2Nrcy5lbGVtZW50c1trZXldW3hdLnRodW1ibmFpbCsnXCIgZGF0YS1zcmNjPVwiJyt0aGlzLmFsbEJsb2Nrcy5lbGVtZW50c1trZXldW3hdLnVybCsnXCIgZGF0YS1oZWlnaHQ9XCInK3RoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV1beF0uaGVpZ2h0KydcIiBkYXRhLXNhbmRib3g9XCJcIiAnK2xvYWRlckZ1bmN0aW9uKyc+PC9saT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSAkKCc8bGkgY2xhc3M9XCJlbGVtZW50ICcrbmljZUtleSsnXCI+PGltZyBzcmM9XCInK3RoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV1beF0udGh1bWJuYWlsKydcIiBkYXRhLXNyY2M9XCInK3RoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV1beF0udXJsKydcIiBkYXRhLWhlaWdodD1cIicrdGhpcy5hbGxCbG9ja3MuZWxlbWVudHNba2V5XVt4XS5oZWlnaHQrJ1wiPjwvbGk+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLmFwcGVuZFRvKCcjbWVudSAjc2Vjb25kIHVsI2VsZW1lbnRzJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy96b29tZXIgd29ya3NcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoIHRoaXMuYWxsQmxvY2tzLmVsZW1lbnRzW2tleV1beF0uaGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVIZWlnaHQgPSB0aGlzLmFsbEJsb2Nrcy5lbGVtZW50c1trZXldW3hdLmhlaWdodCowLjI1O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlSGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0uZmluZCgnaWZyYW1lJykuem9vbWVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb206IDAuMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjcwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkRyYWcmRHJvcCBNZSFcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9kcmFnZ2FibGVzXG4gICAgICAgICAgICBidWlsZGVyVUkubWFrZURyYWdnYWJsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgYmFjayBsaW5rIGlzIGNsaWNrZWRcbiAgICAgICAgKi9cbiAgICAgICAgYmFja0J1dHRvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBzaXRlLnBlbmRpbmdDaGFuZ2VzID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICQoJyNiYWNrTW9kYWwnKS5tb2RhbCgnc2hvdycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBidXR0b24gZm9yIGNvbmZpcm1pbmcgbGVhdmluZyB0aGUgcGFnZVxuICAgICAgICAqL1xuICAgICAgICBiYWNrQnV0dG9uQ29uZmlybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNpdGUucGVuZGluZ0NoYW5nZXMgPSBmYWxzZTsvL3ByZXZlbnQgdGhlIEpTIGFsZXJ0IGFmdGVyIGNvbmZpcm1pbmcgdXNlciB3YW50cyB0byBsZWF2ZVxuICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGFjdGl2YXRlcyBibG9jayBtb2RlXG4gICAgICAgICovXG4gICAgICAgIGFjdGl2YXRlQmxvY2tNb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy90cmlnZ2VyIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgJCgnYm9keScpLnRyaWdnZXIoJ21vZGVCbG9ja3MnKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIG1ha2VzIHRoZSBibG9ja3MgYW5kIHRlbXBsYXRlcyBpbiB0aGUgc2lkZWJhciBkcmFnZ2FibGUgb250byB0aGUgY2FudmFzXG4gICAgICAgICovXG4gICAgICAgIG1ha2VEcmFnZ2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAkKCcjZWxlbWVudHMgbGksICN0ZW1wbGF0ZXMgbGknKS5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMpLmRyYWdnYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCgnPGRpdiBzdHlsZT1cImhlaWdodDogMTAwcHg7IHdpZHRoOiAzMDBweDsgYmFja2dyb3VuZDogI0Y5RkFGQTsgYm94LXNoYWRvdzogNXB4IDVweCAxcHggcmdiYSgwLDAsMCwwLjEpOyB0ZXh0LWFsaWduOiBjZW50ZXI7IGxpbmUtaGVpZ2h0OiAxMDBweDsgZm9udC1zaXplOiAyOHB4OyBjb2xvcjogIzE2QTA4NVwiPjxzcGFuIGNsYXNzPVwiZnVpLWxpc3RcIj48L3NwYW4+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJldmVydDogJ2ludmFsaWQnLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUbzogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0VG9Tb3J0YWJsZTogJyNwYWdlTGlzdCA+IHVsJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlLm1vdmVNb2RlKCdvbicpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7fVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQoJyNlbGVtZW50cyBsaSBhJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQodGhpcykudW5iaW5kKCdjbGljaycpLmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgSW1wbGVtZW50cyB0aGUgc2l0ZSBvbiB0aGUgY2FudmFzLCBjYWxsZWQgZnJvbSB0aGUgU2l0ZSBvYmplY3Qgd2hlbiB0aGUgc2l0ZURhdGEgaGFzIGNvbXBsZXRlZCBsb2FkaW5nXG4gICAgICAgICovXG4gICAgICAgIHBvcHVsYXRlQ2FudmFzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgY291bnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIHRoZSBwYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IoIGkgaW4gc2l0ZS5wYWdlcyApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGFnZSA9IG5ldyBQYWdlKGksIHNpdGUucGFnZXNbaV0sIGNvdW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FjdGl2YXRlIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAgICBpZihzaXRlLnNpdGVQYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2l0ZS5zaXRlUGFnZXNbMF0uc2VsZWN0UGFnZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaXRlLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIENhbnZhcyBsb2FkaW5nIG9uL29mZlxuICAgICAgICAqL1xuICAgICAgICBjYW52YXNMb2FkaW5nOiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gJ29uJyAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJhbWVXcmFwcGVyJykucXVlcnlTZWxlY3RvckFsbCgnI2NhbnZhc092ZXJsYXknKS5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuXG4gICAgICAgICAgICAgICAgb3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgICAgICAgICAgICAgICQob3ZlcmxheSkuaGlkZSgpO1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuaWQgPSAnY2FudmFzT3ZlcmxheSc7XG5cbiAgICAgICAgICAgICAgICBvdmVybGF5LmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwibG9hZGVyXCI+PHNwYW4+ezwvc3Bhbj48c3Bhbj59PC9zcGFuPjwvZGl2Pic7XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJhbWVXcmFwcGVyJykuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG5cbiAgICAgICAgICAgICAgICAkKCcjY2FudmFzT3ZlcmxheScpLmZhZGVJbig1MDApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gJ29mZicgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZyYW1lV3JhcHBlcicpLnF1ZXJ5U2VsZWN0b3JBbGwoJyNjYW52YXNPdmVybGF5JykubGVuZ3RoID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzaXRlLmxvYWRlZCgpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICQoJyNjYW52YXNPdmVybGF5JykuZmFkZU91dCg1MDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgICAgICBQYWdlIGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBmdW5jdGlvbiBQYWdlIChwYWdlTmFtZSwgcGFnZSwgY291bnRlcikge1xuICAgIFxuICAgICAgICB0aGlzLm5hbWUgPSBwYWdlTmFtZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnBhZ2VJRCA9IHBhZ2UucGFnZXNfaWQgfHwgMDtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnRVTCA9IHt9OyAvL3BhcmVudCBVTCBvbiB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMuc3RhdHVzID0gJyc7Ly8nJywgJ25ldycgb3IgJ2NoYW5nZWQnXG4gICAgICAgIHRoaXMuc2NyaXB0cyA9IFtdOy8vdHJhY2tzIHNjcmlwdCBVUkxzIHVzZWQgb24gdGhpcyBwYWdlXG4gICAgICAgIFxuICAgICAgICB0aGlzLnBhZ2VTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBwYWdlLnBhZ2VzX3RpdGxlIHx8ICcnLFxuICAgICAgICAgICAgbWV0YV9kZXNjcmlwdGlvbjogcGFnZS5tZXRhX2Rlc2NyaXB0aW9uIHx8ICcnLFxuICAgICAgICAgICAgbWV0YV9rZXl3b3JkczogcGFnZS5tZXRhX2tleXdvcmRzIHx8ICcnLFxuICAgICAgICAgICAgaGVhZGVyX2luY2x1ZGVzOiBwYWdlLmhlYWRlcl9pbmNsdWRlcyB8fCAnJyxcbiAgICAgICAgICAgIHBhZ2VfY3NzOiBwYWdlLnBhZ2VfY3NzIHx8ICcnXG4gICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHRoaXMucGFnZU1lbnVUZW1wbGF0ZSA9ICc8YSBocmVmPVwiXCIgY2xhc3M9XCJtZW51SXRlbUxpbmtcIj5wYWdlPC9hPjxzcGFuIGNsYXNzPVwicGFnZUJ1dHRvbnNcIj48YSBocmVmPVwiXCIgY2xhc3M9XCJmaWxlRWRpdCBmdWktbmV3XCI+PC9hPjxhIGhyZWY9XCJcIiBjbGFzcz1cImZpbGVEZWwgZnVpLWNyb3NzXCI+PGEgY2xhc3M9XCJidG4gYnRuLXhzIGJ0bi1wcmltYXJ5IGJ0bi1lbWJvc3NlZCBmaWxlU2F2ZSBmdWktY2hlY2tcIiBocmVmPVwiI1wiPjwvYT48L3NwYW4+PC9hPjwvc3Bhbj4nO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5tZW51SXRlbSA9IHt9Oy8vcmVmZXJlbmNlIHRvIHRoZSBwYWdlcyBtZW51IGl0ZW0gZm9yIHRoaXMgcGFnZSBpbnN0YW5jZVxuICAgICAgICB0aGlzLmxpbmtzRHJvcGRvd25JdGVtID0ge307Ly9yZWZlcmVuY2UgdG8gdGhlIGxpbmtzIGRyb3Bkb3duIGl0ZW0gZm9yIHRoaXMgcGFnZSBpbnN0YW5jZVxuICAgICAgICBcbiAgICAgICAgdGhpcy5wYXJlbnRVTCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1VMJyk7XG4gICAgICAgIHRoaXMucGFyZW50VUwuc2V0QXR0cmlidXRlKCdpZCcsIFwicGFnZVwiK2NvdW50ZXIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgbWFrZXMgdGhlIGNsaWNrZWQgcGFnZSBhY3RpdmVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RQYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NlbGVjdDonKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5wYWdlU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvL21hcmsgdGhlIG1lbnUgaXRlbSBhcyBhY3RpdmVcbiAgICAgICAgICAgIHNpdGUuZGVBY3RpdmF0ZUFsbCgpO1xuICAgICAgICAgICAgJCh0aGlzLm1lbnVJdGVtKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbGV0IFNpdGUga25vdyB3aGljaCBwYWdlIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICAgICAgICAgIHNpdGUuc2V0QWN0aXZlKHRoaXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2Rpc3BsYXkgdGhlIG5hbWUgb2YgdGhlIGFjdGl2ZSBwYWdlIG9uIHRoZSBjYW52YXNcbiAgICAgICAgICAgIHNpdGUucGFnZVRpdGxlLmlubmVySFRNTCA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9sb2FkIHRoZSBwYWdlIHNldHRpbmdzIGludG8gdGhlIHBhZ2Ugc2V0dGluZ3MgbW9kYWxcbiAgICAgICAgICAgIC8qc2l0ZS5pbnB1dFBhZ2VTZXR0aW5nc1RpdGxlLnZhbHVlID0gdGhpcy5wYWdlU2V0dGluZ3MudGl0bGU7XG4gICAgICAgICAgICBzaXRlLmlucHV0UGFnZVNldHRpbmdzTWV0YURlc2NyaXB0aW9uLnZhbHVlID0gdGhpcy5wYWdlU2V0dGluZ3MubWV0YV9kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIHNpdGUuaW5wdXRQYWdlU2V0dGluZ3NNZXRhS2V5d29yZHMudmFsdWUgPSB0aGlzLnBhZ2VTZXR0aW5ncy5tZXRhX2tleXdvcmRzO1xuICAgICAgICAgICAgc2l0ZS5pbnB1dFBhZ2VTZXR0aW5nc0luY2x1ZGVzLnZhbHVlID0gdGhpcy5wYWdlU2V0dGluZ3MuaGVhZGVyX2luY2x1ZGVzO1xuICAgICAgICAgICAgc2l0ZS5pbnB1dFBhZ2VTZXR0aW5nc1BhZ2VDc3MudmFsdWUgPSB0aGlzLnBhZ2VTZXR0aW5ncy5wYWdlX2NzczsqLyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3RyaWdnZXIgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICAkKCdib2R5JykudHJpZ2dlcignY2hhbmdlUGFnZScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3Jlc2V0IHRoZSBoZWlnaHRzIGZvciB0aGUgYmxvY2tzIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIGZvciggdmFyIGkgaW4gdGhpcy5ibG9ja3MgKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIE9iamVjdC5rZXlzKHRoaXMuYmxvY2tzW2ldLmZyYW1lRG9jdW1lbnQpLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ja3NbaV0uaGVpZ2h0QWRqdXN0bWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3Nob3cgdGhlIGVtcHR5IG1lc3NhZ2U/XG4gICAgICAgICAgICB0aGlzLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNoYW5nZWQgdGhlIGxvY2F0aW9uL29yZGVyIG9mIGEgYmxvY2sgd2l0aGluIGEgcGFnZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oZnJhbWVJRCwgbmV3UG9zKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vd2UnbGwgbmVlZCB0aGUgYmxvY2sgb2JqZWN0IGNvbm5lY3RlZCB0byBpZnJhbWUgd2l0aCBmcmFtZUlEXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmJsb2Nrc1tpXS5mcmFtZS5nZXRBdHRyaWJ1dGUoJ2lkJykgPT09IGZyYW1lSUQgKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhpcyBibG9jayBpbiB0aGUgYmxvY2tzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tzLnNwbGljZShuZXdQb3MsIDAsIHRoaXMuYmxvY2tzLnNwbGljZShpLCAxKVswXSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGRlbGV0ZSBibG9jayBmcm9tIGJsb2NrcyBhcnJheVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZUJsb2NrID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9yZW1vdmUgZnJvbSBibG9ja3MgYXJyYXlcbiAgICAgICAgICAgIGZvciggdmFyIGkgaW4gdGhpcy5ibG9ja3MgKSB7XG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuYmxvY2tzW2ldID09PSBibG9jayApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9mb3VuZCBpdCwgcmVtb3ZlIGZyb20gYmxvY2tzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBzZXR1cCBmb3IgZWRpdGluZyBhIHBhZ2UgbmFtZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRQYWdlTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggIXRoaXMubWVudUl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0JykgKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2hpZGUgdGhlIGxpbmtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnVJdGVtLnF1ZXJ5U2VsZWN0b3IoJ2EubWVudUl0ZW1MaW5rJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vaW5zZXJ0IHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgICAgIHZhciBuZXdJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgbmV3SW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgICAgICBuZXdJbnB1dC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAncGFnZScpO1xuICAgICAgICAgICAgICAgIG5ld0lucHV0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVudUl0ZW0uaW5zZXJ0QmVmb3JlKG5ld0lucHV0LCB0aGlzLm1lbnVJdGVtLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXdJbnB1dC5mb2N1cygpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgdG1wU3RyID0gbmV3SW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICAgICAgICAgIG5ld0lucHV0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyk7XG4gICAgICAgICAgICAgICAgbmV3SW5wdXQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRtcFN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51SXRlbS5jbGFzc0xpc3QuYWRkKCdlZGl0Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIFVwZGF0ZXMgdGhpcyBwYWdlJ3MgbmFtZSAoZXZlbnQgaGFuZGxlciBmb3IgdGhlIHNhdmUgYnV0dG9uKVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VOYW1lRXZlbnQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggdGhpcy5tZW51SXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXQnKSApIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vZWwgaXMgdGhlIGNsaWNrZWQgYnV0dG9uLCB3ZSdsbCBuZWVkIGFjY2VzcyB0byB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICB2YXIgdGhlSW5wdXQgPSB0aGlzLm1lbnVJdGVtLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9XCJwYWdlXCJdJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhlIHBhZ2UncyBuYW1lIGlzIE9LXG4gICAgICAgICAgICAgICAgaWYoIHNpdGUuY2hlY2tQYWdlTmFtZSh0aGVJbnB1dC52YWx1ZSkgKSB7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHNpdGUucHJlcFBhZ2VOYW1lKCB0aGVJbnB1dC52YWx1ZSApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudUl0ZW0ucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cInBhZ2VcIl0nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51SXRlbS5xdWVyeVNlbGVjdG9yKCdhLm1lbnVJdGVtTGluaycpLmlubmVySFRNTCA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51SXRlbS5xdWVyeVNlbGVjdG9yKCdhLm1lbnVJdGVtTGluaycpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudUl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnZWRpdCcpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSB0aGUgbGlua3MgZHJvcGRvd24gaXRlbVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtzRHJvcGRvd25JdGVtLnRleHQgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua3NEcm9wZG93bkl0ZW0uc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRoaXMubmFtZStcIi5odG1sXCIpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgdGhlIHBhZ2UgbmFtZSBvbiB0aGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIHNpdGUucGFnZVRpdGxlLmlubmVySFRNTCA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZWQgcGFnZSB0aXRsZSwgd2UndmUgZ290IHBlbmRpbmcgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICBzaXRlLnNldFBlbmRpbmdDaGFuZ2VzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBhbGVydChzaXRlLnBhZ2VOYW1lRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBkZWxldGVzIHRoaXMgZW50aXJlIHBhZ2VcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9kZWxldGUgZnJvbSB0aGUgU2l0ZVxuICAgICAgICAgICAgZm9yKCB2YXIgaSBpbiBzaXRlLnNpdGVQYWdlcyApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggc2l0ZS5zaXRlUGFnZXNbaV0gPT09IHRoaXMgKSB7Ly9nb3QgYSBtYXRjaCFcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vZGVsZXRlIGZyb20gc2l0ZS5zaXRlUGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS5zaXRlUGFnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9kZWxldGUgZnJvbSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRVTC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIHRvIGRlbGV0ZWQgcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS5wYWdlc1RvRGVsZXRlLnB1c2godGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vZGVsZXRlIHRoZSBwYWdlJ3MgbWVudSBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudUl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2RlbGV0IHRoZSBwYWdlcyBsaW5rIGRyb3Bkb3duIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rc0Ryb3Bkb3duSXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vYWN0aXZhdGUgdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS5zaXRlUGFnZXNbMF0uc2VsZWN0UGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9wYWdlIHdhcyBkZWxldGVkLCBzbyB3ZSd2ZSBnb3QgcGVuZGluZyBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIHNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNoZWNrcyBpZiB0aGUgcGFnZSBpcyBlbXB0eSwgaWYgc28gc2hvdyB0aGUgJ2VtcHR5JyBtZXNzYWdlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggdGhpcy5ibG9ja3MubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNpdGUubWVzc2FnZVN0YXJ0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHNpdGUuZGl2RnJhbWVXcmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2VtcHR5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzaXRlLm1lc3NhZ2VTdGFydC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHNpdGUuZGl2RnJhbWVXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2VtcHR5Jyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgcHJlcHMvc3RyaXBzIHRoaXMgcGFnZSBkYXRhIGZvciBhIHBlbmRpbmcgYWpheCByZXF1ZXN0XG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJlcEZvclNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBhZ2UgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBwYWdlLmJsb2NrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcHJvY2VzcyB0aGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKCB2YXIgeCA9IDA7IHggPCB0aGlzLmJsb2Nrcy5sZW5ndGg7IHgrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuYmxvY2tzW3hdLnNhbmRib3ggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmZyYW1lc19jb250ZW50ID0gXCI8aHRtbD5cIiskKCcjc2FuZGJveGVzICMnK3RoaXMuYmxvY2tzW3hdLnNhbmRib3gpLmNvbnRlbnRzKCkuZmluZCgnaHRtbCcpLmh0bWwoKStcIjwvaHRtbD5cIjtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZnJhbWVzX3NhbmRib3ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBibG9jay5mcmFtZXNfbG9hZGVyRnVuY3Rpb24gPSB0aGlzLmJsb2Nrc1t4XS5zYW5kYm94X2xvYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZnJhbWVzX2NvbnRlbnQgPSB0aGlzLmJsb2Nrc1t4XS5mcmFtZURvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCAnI3BhZ2UnICkub3V0ZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICBibG9jay5mcmFtZXNfc2FuZGJveCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBibG9jay5mcmFtZXNfbG9hZGVyRnVuY3Rpb24gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBibG9jay5mcmFtZXNfaGVpZ2h0ID0gdGhpcy5ibG9ja3NbeF0uZnJhbWVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYmxvY2suZnJhbWVzX29yaWdpbmFsX3VybCA9IHRoaXMuYmxvY2tzW3hdLm9yaWdpbmFsVXJsO1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5ibG9ja3NbeF0uZ2xvYmFsICkgYmxvY2suZnJhbWVzX2dsb2JhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGFnZS5ibG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgZ2VuZXJhdGVzIHRoZSBmdWxsIHBhZ2UsIHVzaW5nIHNrZWxldG9uLmh0bWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mdWxsUGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcGFnZSA9IHRoaXM7Ly9yZWZlcmVuY2UgdG8gc2VsZiBmb3IgbGF0ZXJcbiAgICAgICAgICAgIHBhZ2Uuc2NyaXB0cyA9IFtdOy8vbWFrZSBzdXJlIGl0J3MgZW1wdHksIHdlJ2xsIHN0b3JlIHNjcmlwdCBVUkxzIGluIHRoZXJlIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBuZXdEb2NNYWluUGFyZW50ID0gJCgnaWZyYW1lI3NrZWxldG9uJykuY29udGVudHMoKS5maW5kKCBiQ29uZmlnLnBhZ2VDb250YWluZXIgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9lbXB0eSBvdXQgdGhlIHNrZWxldG9uIGZpcnN0XG4gICAgICAgICAgICAkKCdpZnJhbWUjc2tlbGV0b24nKS5jb250ZW50cygpLmZpbmQoIGJDb25maWcucGFnZUNvbnRhaW5lciApLmh0bWwoJycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3JlbW92ZSBvbGQgc2NyaXB0IHRhZ3NcbiAgICAgICAgICAgICQoJ2lmcmFtZSNza2VsZXRvbicpLmNvbnRlbnRzKCkuZmluZCggJ3NjcmlwdCcgKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdGhlQ29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciggdmFyIGkgaW4gdGhpcy5ibG9ja3MgKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9ncmFiIHRoZSBibG9jayBjb250ZW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tzW2ldLnNhbmRib3ggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGVDb250ZW50cyA9ICQoJyNzYW5kYm94ZXMgIycrdGhpcy5ibG9ja3NbaV0uc2FuZGJveCkuY29udGVudHMoKS5maW5kKCBiQ29uZmlnLnBhZ2VDb250YWluZXIgKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGVDb250ZW50cyA9ICQodGhpcy5ibG9ja3NbaV0uZnJhbWVEb2N1bWVudC5ib2R5KS5maW5kKCBiQ29uZmlnLnBhZ2VDb250YWluZXIgKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgdmlkZW8gZnJhbWVDb3ZlcnNcbiAgICAgICAgICAgICAgICB0aGVDb250ZW50cy5maW5kKCcuZnJhbWVDb3ZlcicpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHZpZGVvIGZyYW1lV3JhcHBlcnNcbiAgICAgICAgICAgICAgICB0aGVDb250ZW50cy5maW5kKCcudmlkZW9XcmFwcGVyJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNudCA9ICQodGhpcykuY29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZXBsYWNlV2l0aChjbnQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBzdHlsZSBsZWZ0b3ZlcnMgZnJvbSB0aGUgc3R5bGUgZWRpdG9yXG4gICAgICAgICAgICAgICAgZm9yKCB2YXIga2V5IGluIGJDb25maWcuZWRpdGFibGVJdGVtcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhlQ29udGVudHMuZmluZCgga2V5ICkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUF0dHIoJ2RhdGEtc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ291dGxpbmUnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcygnb3V0bGluZS1vZmZzZXQnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcygnY3Vyc29yJywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggJCh0aGlzKS5hdHRyKCdzdHlsZScpID09PSAnJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBzdHlsZSBsZWZ0b3ZlcnMgZnJvbSB0aGUgY29udGVudCBlZGl0b3JcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCBiQ29uZmlnLmVkaXRhYmxlQ29udGVudC5sZW5ndGg7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhlQ29udGVudHMuZmluZCggYkNvbmZpZy5lZGl0YWJsZUNvbnRlbnRbeF0gKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQXR0cignZGF0YS1zZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYXBwZW5kIHRvIERPTSBpbiB0aGUgc2tlbGV0b25cbiAgICAgICAgICAgICAgICBuZXdEb2NNYWluUGFyZW50LmFwcGVuZCggJCh0aGVDb250ZW50cy5odG1sKCkpICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9kbyB3ZSBuZWVkIHRvIGluamVjdCBhbnkgc2NyaXB0cz9cbiAgICAgICAgICAgICAgICB2YXIgc2NyaXB0cyA9ICQodGhpcy5ibG9ja3NbaV0uZnJhbWVEb2N1bWVudC5ib2R5KS5maW5kKCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhlSWZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJza2VsZXRvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIHNjcmlwdHMuc2l6ZSgpID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdHMuZWFjaChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggJCh0aGlzKS50ZXh0KCkgIT09ICcnICkgey8vc2NyaXB0IHRhZ3Mgd2l0aCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gdGhlSWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5pbm5lckhUTUwgPSAkKHRoaXMpLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVJZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggJCh0aGlzKS5hdHRyKCdzcmMnKSAhPT0gbnVsbCAmJiBwYWdlLnNjcmlwdHMuaW5kZXhPZigkKHRoaXMpLmF0dHIoJ3NyYycpKSA9PT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91c2UgaW5kZXhPZiB0byBtYWtlIHN1cmUgZWFjaCBzY3JpcHQgb25seSBhcHBlYXJzIG9uIHRoZSBwcm9kdWNlZCBwYWdlIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSB0aGVJZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnNyYyA9ICQodGhpcykuYXR0cignc3JjJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlSWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2Uuc2NyaXB0cy5wdXNoKCQodGhpcykuYXR0cignc3JjJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5zY3JpcHRzKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBjbGVhciBvdXQgdGhpcyBwYWdlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5ibG9ja3MucG9wKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHdoaWxlKCBibG9jayAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJsb2NrLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJsb2NrID0gdGhpcy5ibG9ja3MucG9wKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgSGVpZ2h0IGFkanVzdG1lbnQgZm9yIGFsbCBibG9ja3Mgb24gdGhlIHBhZ2VcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHRBZGp1c3RtZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2Nrcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2Nrc1tpXS5oZWlnaHRBZGp1c3RtZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBDaGVja3MgaWYgYWxsIGJsb2NrcyBvbiB0aGlzIHBhZ2UgaGF2ZSBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCB0aGlzLmJsb2Nrcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggIXRoaXMuYmxvY2tzW2ldLmxvYWRlZCApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9O1xuICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvL2xvb3AgdGhyb3VnaCB0aGUgZnJhbWVzL2Jsb2Nrc1xuICAgICAgICBcbiAgICAgICAgaWYoIHBhZ2UuaGFzT3duUHJvcGVydHkoJ2Jsb2NrcycpICkge1xuICAgICAgICBcbiAgICAgICAgICAgIGZvciggdmFyIHggPSAwOyB4IDwgcGFnZS5ibG9ja3MubGVuZ3RoOyB4KysgKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2NyZWF0ZSBuZXcgQmxvY2tcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBuZXdCbG9jayA9IG5ldyBCbG9jaygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGFnZS5ibG9ja3NbeF0uc3JjID0gcGFnZS5ibG9ja3NbeF0uZnJhbWVzX29yaWdpbmFsX3VybDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3NhbmRib3hlZCBibG9jaz9cbiAgICAgICAgICAgICAgICBpZiggcGFnZS5ibG9ja3NbeF0uZnJhbWVzX3NhbmRib3ggPT09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBuZXdCbG9jay5zYW5kYm94ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2suc2FuZGJveF9sb2FkZXIgPSBwYWdlLmJsb2Nrc1t4XS5mcmFtZXNfbG9hZGVyZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV3QmxvY2suZnJhbWVJRCA9IHBhZ2UuYmxvY2tzW3hdLmZyYW1lc19pZDtcbiAgICAgICAgICAgICAgICBpZiAoIHBhZ2UuYmxvY2tzW3hdLmZyYW1lc19nbG9iYWwgKSBuZXdCbG9jay5nbG9iYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5ld0Jsb2NrLmNyZWF0ZVBhcmVudExJKHBhZ2UuYmxvY2tzW3hdLmZyYW1lc19oZWlnaHQpO1xuICAgICAgICAgICAgICAgIG5ld0Jsb2NrLmNyZWF0ZUZyYW1lKHBhZ2UuYmxvY2tzW3hdKTtcbiAgICAgICAgICAgICAgICBuZXdCbG9jay5jcmVhdGVGcmFtZUNvdmVyKCk7XG4gICAgICAgICAgICAgICAgbmV3QmxvY2suaW5zZXJ0QmxvY2tJbnRvRG9tKHRoaXMucGFyZW50VUwpO1xuICAgICAgICAgICAgICAgIG5ld0Jsb2NrLmNvbnRlbnRBZnRlckxvYWQgPSBwYWdlLmJsb2Nrc1t4XS5mcmFtZXNfY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9hZGQgdGhlIGJsb2NrIHRvIHRoZSBuZXcgcGFnZVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tzLnB1c2gobmV3QmxvY2spO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy9hZGQgdGhpcyBwYWdlIHRvIHRoZSBzaXRlIG9iamVjdFxuICAgICAgICBzaXRlLnNpdGVQYWdlcy5wdXNoKCB0aGlzICk7XG4gICAgICAgIFxuICAgICAgICAvL3BsYW50IHRoZSBuZXcgVUwgaW4gdGhlIERPTSAob24gdGhlIGNhbnZhcylcbiAgICAgICAgc2l0ZS5kaXZDYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5wYXJlbnRVTCk7XG4gICAgICAgIFxuICAgICAgICAvL21ha2UgdGhlIGJsb2Nrcy9mcmFtZXMgaW4gZWFjaCBwYWdlIHNvcnRhYmxlXG4gICAgICAgIFxuICAgICAgICB2YXIgdGhlUGFnZSA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICAkKHRoaXMucGFyZW50VUwpLnNvcnRhYmxlKHtcbiAgICAgICAgICAgIHJldmVydDogdHJ1ZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcImRyb3AtaG92ZXJcIixcbiAgICAgICAgICAgIGhhbmRsZTogJy5kcmFnQmxvY2snLFxuICAgICAgICAgICAgY2FuY2VsOiAnJyxcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaXRlLm1vdmVNb2RlKCdvZmYnKTtcbiAgICAgICAgICAgICAgICBzaXRlLnNldFBlbmRpbmdDaGFuZ2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICggIXNpdGUubG9hZGVkKCkgKSBidWlsZGVyVUkuY2FudmFzTG9hZGluZygnb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmVTdG9wOiBmdW5jdGlvbihldmVudCwgdWkpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vdGVtcGxhdGUgb3IgcmVndWxhciBibG9jaz9cbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHVpLml0ZW0uYXR0cignZGF0YS1mcmFtZXMnKTtcblxuICAgICAgICAgICAgICAgIHZhciBuZXdCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyICE9PSB0eXBlb2YgdW5kZWZpbmVkICYmIGF0dHIgIT09IGZhbHNlKSB7Ly90ZW1wbGF0ZSwgYnVpbGQgaXRcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICQoJyNzdGFydCcpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9jbGVhciBvdXQgYWxsIGJsb2NrcyBvbiB0aGlzIHBhZ2UgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoZVBhZ2UuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIHRoZSBuZXcgZnJhbWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUlEcyA9IHVpLml0ZW0uYXR0cignZGF0YS1mcmFtZXMnKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0cyA9IHVpLml0ZW0uYXR0cignZGF0YS1oZWlnaHRzJykuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybHMgPSB1aS5pdGVtLmF0dHIoJ2RhdGEtb3JpZ2luYWx1cmxzJykuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IoIHZhciB4ID0gMDsgeCA8IGZyYW1lSURzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrID0gbmV3IEJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9jay5jcmVhdGVQYXJlbnRMSShoZWlnaHRzW3hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZURhdGEuc3JjID0gJ3NpdGVzL2dldGZyYW1lLycrZnJhbWVJRHNbeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZURhdGEuZnJhbWVzX29yaWdpbmFsX3VybCA9ICdzaXRlcy9nZXRmcmFtZS8nK2ZyYW1lSURzW3hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVEYXRhLmZyYW1lc19oZWlnaHQgPSBoZWlnaHRzW3hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9jay5jcmVhdGVGcmFtZSggZnJhbWVEYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9jay5jcmVhdGVGcmFtZUNvdmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9jay5pbnNlcnRCbG9ja0ludG9Eb20odGhlUGFnZS5wYXJlbnRVTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSBibG9jayB0byB0aGUgbmV3IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZVBhZ2UuYmxvY2tzLnB1c2gobmV3QmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Ryb3BwZWQgZWxlbWVudCwgc28gd2UndmUgZ290IHBlbmRpbmcgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZS5zZXRQZW5kaW5nQ2hhbmdlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3NldCB0aGUgdGVtcGF0ZUlEXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXJVSS50ZW1wbGF0ZUlEID0gdWkuaXRlbS5hdHRyKCdkYXRhLXBhZ2VpZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIG5vdGhpbmcgZ2V0cyBkcm9wcGVkIGluIHRoZSBsc2l0XG4gICAgICAgICAgICAgICAgICAgIHVpLml0ZW0uaHRtbChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2RlbGV0ZSBkcmFnIHBsYWNlIGhvbGRlclxuICAgICAgICAgICAgICAgICAgICAkKCdib2R5IC51aS1zb3J0YWJsZS1oZWxwZXInKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsvL3JlZ3VsYXIgYmxvY2tcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9hcmUgd2UgZGVhbGluZyB3aXRoIGEgbmV3IGJsb2NrIGJlaW5nIGRyb3BwZWQgb250byB0aGUgY2FudmFzLCBvciBhIHJlb3JkZXJpbmcgb2cgYmxvY2tzIGFscmVhZHkgb24gdGhlIGNhbnZhcz9cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoIHVpLml0ZW0uZmluZCgnLmZyYW1lQ292ZXIgPiBidXR0b24nKS5zaXplKCkgPiAwICkgey8vcmUtb3JkZXJpbmcgb2YgYmxvY2tzIG9uIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgYmxvY2sgb2JqZWN0LCB3ZSBzaW1wbHkgbmVlZCB0byBtYWtlIHN1cmUgdGhlIHBvc2l0aW9uIG9mIHRoZSBleGlzdGluZyBibG9jayBpbiB0aGUgU2l0ZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaXMgY2hhbmdlZCB0byByZWZsZWN0IHRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIGJsb2NrIG9uIHRoIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUlEID0gdWkuaXRlbS5maW5kKCdpZnJhbWUnKS5hdHRyKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHVpLml0ZW0uaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXRlLmFjdGl2ZVBhZ2Uuc2V0UG9zaXRpb24oZnJhbWVJRCwgbmV3UG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsvL25ldyBibG9jayBvbiBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXcgYmxvY2sgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2sgPSBuZXcgQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9jay5wbGFjZU9uQ2FudmFzKHVpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuXG4gICAgICAgICAgICAgICAgc2l0ZS5tb3ZlTW9kZSgnb24nKTtcblxuICAgICAgICAgICAgICAgIGlmKCB1aS5pdGVtLmZpbmQoJy5mcmFtZUNvdmVyJykuc2l6ZSgpICE9PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBidWlsZGVyVUkuZnJhbWVDb250ZW50cyA9IHVpLml0ZW0uZmluZCgnaWZyYW1lJykuY29udGVudHMoKS5maW5kKCBiQ29uZmlnLnBhZ2VDb250YWluZXIgKS5odG1sKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3ZlcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJCgnI3N0YXJ0JykuaGlkZSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vYWRkIHRvIHRoZSBwYWdlcyBtZW51XG4gICAgICAgIHRoaXMubWVudUl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMSScpO1xuICAgICAgICB0aGlzLm1lbnVJdGVtLmlubmVySFRNTCA9IHRoaXMucGFnZU1lbnVUZW1wbGF0ZTtcbiAgICAgICAgXG4gICAgICAgICQodGhpcy5tZW51SXRlbSkuZmluZCgnYTpmaXJzdCcpLnRleHQocGFnZU5hbWUpLmF0dHIoJ2hyZWYnLCAnI3BhZ2UnK2NvdW50ZXIpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHRoZUxpbmsgPSAkKHRoaXMubWVudUl0ZW0pLmZpbmQoJ2E6Zmlyc3QnKS5nZXQoMCk7XG4gICAgICAgIFxuICAgICAgICAvL2JpbmQgc29tZSBldmVudHNcbiAgICAgICAgdGhpcy5tZW51SXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubWVudUl0ZW0ucXVlcnlTZWxlY3RvcignYS5maWxlRWRpdCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcywgZmFsc2UpO1xuICAgICAgICB0aGlzLm1lbnVJdGVtLnF1ZXJ5U2VsZWN0b3IoJ2EuZmlsZVNhdmUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tZW51SXRlbS5xdWVyeVNlbGVjdG9yKCdhLmZpbGVEZWwnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMsIGZhbHNlKTtcblxuICAgICAgICAvL25vIGRlbCBidXR0b24gZm9yIHRoZSBpbmRleCBwYWdlXG4gICAgICAgIGlmKCBjb3VudGVyID09PSAxICkgdGhpcy5tZW51SXRlbS5xdWVyeVNlbGVjdG9yKCdhLmZpbGVEZWwnKS5yZW1vdmUoKTtcbiAgICAgICAgXG4gICAgICAgIHNpdGUucGFnZXNNZW51LmFwcGVuZENoaWxkKHRoaXMubWVudUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgUGFnZS5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjbGlja1wiOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpbGVFZGl0JykgKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdFBhZ2VOYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZmlsZVNhdmUnKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdlTmFtZUV2ZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaWxlRGVsJykgKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlUGFnZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICQoYnVpbGRlclVJLm1vZGFsRGVsZXRlUGFnZSkubW9kYWwoJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICQoYnVpbGRlclVJLm1vZGFsRGVsZXRlUGFnZSkub2ZmKCdjbGljaycsICcjZGVsZXRlUGFnZUNvbmZpcm0nKS5vbignY2xpY2snLCAnI2RlbGV0ZVBhZ2VDb25maXJtJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZVBhZ2UuZGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICQoYnVpbGRlclVJLm1vZGFsRGVsZXRlUGFnZSkubW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RQYWdlKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICAgICAgQmxvY2sgY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIEJsb2NrICgpIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZnJhbWVJRCA9IDA7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2FuZGJveCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNhbmRib3hfbG9hZGVyID0gJyc7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJyc7Ly8nJywgJ2NoYW5nZWQnIG9yICduZXcnXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3JpZ2luYWxVcmwgPSAnJztcbiAgICAgICAgXG4gICAgICAgIHRoaXMucGFyZW50TEkgPSB7fTtcbiAgICAgICAgdGhpcy5mcmFtZUNvdmVyID0ge307XG4gICAgICAgIHRoaXMuZnJhbWUgPSB7fTtcbiAgICAgICAgdGhpcy5mcmFtZURvY3VtZW50ID0ge307XG4gICAgICAgIHRoaXMuZnJhbWVIZWlnaHQgPSAwO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5hbm5vdCA9IHt9O1xuICAgICAgICB0aGlzLmFubm90VGltZW91dCA9IHt9O1xuXG4gICAgICAgIHRoaXMuY29udGVudEFmdGVyTG9hZCA9ICcnO1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNyZWF0ZXMgdGhlIHBhcmVudCBjb250YWluZXIgKExJKVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVBhcmVudExJID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGFyZW50TEkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMSScpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRMSS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIC8vdGhpcy5wYXJlbnRMSS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2hlaWdodDogJytoZWlnaHQrJ3B4Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBjcmVhdGVzIHRoZSBpZnJhbWUgb24gdGhlIGNhbnZhc1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lGUkFNRScpO1xuICAgICAgICAgICAgdGhpcy5mcmFtZS5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgMCk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLnNldEF0dHJpYnV0ZSgnc2Nyb2xsaW5nJywgMCk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgZnJhbWUuc3JjKTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsdXJsJywgZnJhbWUuZnJhbWVzX29yaWdpbmFsX3VybCk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsVXJsID0gZnJhbWUuZnJhbWVzX29yaWdpbmFsX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgJCh0aGlzLmZyYW1lKS51bmlxdWVJZCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NhbmRib3g/XG4gICAgICAgICAgICBpZiggdGhpcy5zYW5kYm94ICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lLnNldEF0dHJpYnV0ZSgnZGF0YS1sb2FkZXJmdW5jdGlvbicsIHRoaXMuc2FuZGJveF9sb2FkZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWUuc2V0QXR0cmlidXRlKCdkYXRhLXNhbmRib3gnLCB0aGlzLnNhbmRib3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vcmVjcmVhdGUgdGhlIHNhbmRib3hlZCBpZnJhbWUgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgdmFyIHNhbmRib3hlZEZyYW1lID0gJCgnPGlmcmFtZSBzcmM9XCInK2ZyYW1lLnNyYysnXCIgaWQ9XCInK3RoaXMuc2FuZGJveCsnXCIgc2FuZGJveD1cImFsbG93LXNhbWUtb3JpZ2luXCI+PC9pZnJhbWU+Jyk7XG4gICAgICAgICAgICAgICAgJCgnI3NhbmRib3hlcycpLmFwcGVuZCggc2FuZGJveGVkRnJhbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBpbnNlcnQgdGhlIGlmcmFtZSBpbnRvIHRoZSBET00gb24gdGhlIGNhbnZhc1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLmluc2VydEJsb2NrSW50b0RvbSA9IGZ1bmN0aW9uKHRoZVVMKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGFyZW50TEkuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgICAgICAgICB0aGVVTC5hcHBlbmRDaGlsZCggdGhpcy5wYXJlbnRMSSApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGJ1aWxkZXJVSS5jYW52YXNMb2FkaW5nKCdvbicpO1xuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHNldHMgdGhlIGZyYW1lIGRvY3VtZW50IGZvciB0aGUgYmxvY2sncyBpZnJhbWVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRGcmFtZURvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2V0IHRoZSBmcmFtZSBkb2N1bWVudCBhcyB3ZWxsXG4gICAgICAgICAgICBpZiggdGhpcy5mcmFtZS5jb250ZW50RG9jdW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZURvY3VtZW50ID0gdGhpcy5mcmFtZS5jb250ZW50RG9jdW1lbnQ7ICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVEb2N1bWVudCA9IHRoaXMuZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNyZWF0ZXMgdGhlIGZyYW1lIGNvdmVyIGFuZCBibG9jayBhY3Rpb24gYnV0dG9uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlRnJhbWVDb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2J1aWxkIHRoZSBmcmFtZSBjb3ZlciBhbmQgYmxvY2sgYWN0aW9uIGJ1dHRvbnNcbiAgICAgICAgICAgIHRoaXMuZnJhbWVDb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgICAgdGhpcy5mcmFtZUNvdmVyLmNsYXNzTGlzdC5hZGQoJ2ZyYW1lQ292ZXInKTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVDb3Zlci5jbGFzc0xpc3QuYWRkKCdmcmVzaCcpO1xuICAgICAgICAgICAgLy90aGlzLmZyYW1lQ292ZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5mcmFtZUhlaWdodCtcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGRlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0JVVFRPTicpO1xuICAgICAgICAgICAgZGVsQnV0dG9uLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYnRuIGJ0bi1pbnZlcnNlIGJ0bi1zbSBkZWxldGVCbG9jaycpO1xuICAgICAgICAgICAgZGVsQnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgICAgICAgIGRlbEJ1dHRvbi5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmdWktdHJhc2hcIj48L2k+IDxzcGFuPlJlbW92ZTwvc3Bhbj4nO1xuICAgICAgICAgICAgZGVsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciByZXNldEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0JVVFRPTicpO1xuICAgICAgICAgICAgcmVzZXRCdXR0b24uc2V0QXR0cmlidXRlKCdjbGFzcycsICdidG4gYnRuLWludmVyc2UgYnRuLXNtIHJlc2V0QmxvY2snKTtcbiAgICAgICAgICAgIHJlc2V0QnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgICAgICAgIHJlc2V0QnV0dG9uLmlubmVySFRNTCA9ICc8aSBjbGFzcz1cImZhIGZhLXJlZnJlc2hcIj48L2k+IDxzcGFuPlJlc2V0PC9zcGFuPic7XG4gICAgICAgICAgICByZXNldEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaHRtbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0JVVFRPTicpO1xuICAgICAgICAgICAgaHRtbEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2J0biBidG4taW52ZXJzZSBidG4tc20gaHRtbEJsb2NrJyk7XG4gICAgICAgICAgICBodG1sQnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgICAgICAgIGh0bWxCdXR0b24uaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiZmEgZmEtY29kZVwiPjwvaT4gPHNwYW4+U291cmNlPC9zcGFuPic7XG4gICAgICAgICAgICBodG1sQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcywgZmFsc2UpO1xuXG4gICAgICAgICAgICB2YXIgZHJhZ0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0JVVFRPTicpO1xuICAgICAgICAgICAgZHJhZ0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2J0biBidG4taW52ZXJzZSBidG4tc20gZHJhZ0Jsb2NrJyk7XG4gICAgICAgICAgICBkcmFnQnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgICAgICAgIGRyYWdCdXR0b24uaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiZmEgZmEtYXJyb3dzXCI+PC9pPiA8c3Bhbj5Nb3ZlPC9zcGFuPic7XG4gICAgICAgICAgICBkcmFnQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcywgZmFsc2UpO1xuXG4gICAgICAgICAgICB2YXIgZ2xvYmFsTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMQUJFTCcpO1xuICAgICAgICAgICAgZ2xvYmFsTGFiZWwuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3gnKTtcbiAgICAgICAgICAgIGdsb2JhbExhYmVsLmNsYXNzTGlzdC5hZGQoJ3ByaW1hcnknKTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxDaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lOUFVUJyk7XG4gICAgICAgICAgICBnbG9iYWxDaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgIGdsb2JhbENoZWNrYm94LnNldEF0dHJpYnV0ZSgnZGF0YS10b2dnbGUnLCAnY2hlY2tib3gnKTtcbiAgICAgICAgICAgIGdsb2JhbENoZWNrYm94LmNoZWNrZWQgPSB0aGlzLmdsb2JhbDtcbiAgICAgICAgICAgIGdsb2JhbExhYmVsLmFwcGVuZENoaWxkKGdsb2JhbENoZWNrYm94KTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxUZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0dsb2JhbCcpO1xuICAgICAgICAgICAgZ2xvYmFsTGFiZWwuYXBwZW5kQ2hpbGQoZ2xvYmFsVGV4dCk7XG5cbiAgICAgICAgICAgIHZhciB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKCdmdWktZ2VhcicpO1xuXG4gICAgICAgICAgICB2YXIgdGhlQmxvY2sgPSB0aGlzO1xuXG4gICAgICAgICAgICAkKGdsb2JhbENoZWNrYm94KS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgICAgIHRoZUJsb2NrLnRvZ2dsZUdsb2JhbChlKTtcblxuICAgICAgICAgICAgfSkucmFkaW9jaGVjaygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmZyYW1lQ292ZXIuYXBwZW5kQ2hpbGQoZGVsQnV0dG9uKTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVDb3Zlci5hcHBlbmRDaGlsZChyZXNldEJ1dHRvbik7XG4gICAgICAgICAgICB0aGlzLmZyYW1lQ292ZXIuYXBwZW5kQ2hpbGQoaHRtbEJ1dHRvbik7XG4gICAgICAgICAgICB0aGlzLmZyYW1lQ292ZXIuYXBwZW5kQ2hpbGQoZHJhZ0J1dHRvbik7XG4gICAgICAgICAgICB0aGlzLmZyYW1lQ292ZXIuYXBwZW5kQ2hpbGQoZ2xvYmFsTGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5mcmFtZUNvdmVyLmFwcGVuZENoaWxkKHRyaWdnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wYXJlbnRMSS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lQ292ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2dnbGVHbG9iYWwgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgICAgICBpZiAoIGUuY3VycmVudFRhcmdldC5jaGVja2VkICkgdGhpcy5nbG9iYWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmdsb2JhbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvL3dlJ3ZlIGdvdCBwZW5kaW5nIGNoYW5nZXNcbiAgICAgICAgICAgIHNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGNvcnJlY3RzIHRoZSBoZWlnaHQgb2YgdGhlIGJsb2NrJ3MgaWZyYW1lIGRlcGVuZGluZyBvbiBpdHMgY29udGVudFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodEFkanVzdG1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCBPYmplY3Qua2V5cyh0aGlzLmZyYW1lRG9jdW1lbnQpLmxlbmd0aCAhPT0gMCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBwYWdlQ29udGFpbmVyID0gdGhpcy5mcmFtZURvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhZ2VDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQrXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TEkuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0K1wicHhcIjtcbiAgICAgICAgICAgICAgICAvL3RoaXMuZnJhbWVDb3Zlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQrXCJweFwiO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBkZWxldGVzIGEgYmxvY2tcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9yZW1vdmUgZnJvbSBET00vY2FudmFzIHdpdGggYSBuaWNlIGFuaW1hdGlvblxuICAgICAgICAgICAgJCh0aGlzLmZyYW1lLnBhcmVudE5vZGUpLmZhZGVPdXQoNTAwLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzaXRlLmFjdGl2ZVBhZ2UuaXNFbXB0eSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVtb3ZlIGZyb20gYmxvY2tzIGFycmF5IGluIHRoZSBhY3RpdmUgcGFnZVxuICAgICAgICAgICAgc2l0ZS5hY3RpdmVQYWdlLmRlbGV0ZUJsb2NrKHRoaXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NhbmJveFxuICAgICAgICAgICAgaWYoIHRoaXMuc2FuYmRveCApIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggdGhpcy5zYW5kYm94ICkucmVtb3ZlKCk7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZWxlbWVudCB3YXMgZGVsZXRlZCwgc28gd2UndmUgZ290IHBlbmRpbmcgY2hhbmdlXG4gICAgICAgICAgICBzaXRlLnNldFBlbmRpbmdDaGFuZ2VzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHJlc2V0cyBhIGJsb2NrIHRvIGl0J3Mgb3JpZ25hbCBzdGF0ZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oZmlyZUV2ZW50KSB7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGZpcmVFdmVudCA9PT0gJ3VuZGVmaW5lZCcpIGZpcmVFdmVudCA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVzZXQgZnJhbWUgYnkgcmVsb2FkaW5nIGl0XG4gICAgICAgICAgICB0aGlzLmZyYW1lLmNvbnRlbnRXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2FuZGJveD9cbiAgICAgICAgICAgIGlmKCB0aGlzLnNhbmRib3ggKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhbmRib3hGcmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc2FuZGJveCkuY29udGVudFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VsZW1lbnQgd2FzIGRlbGV0ZWQsIHNvIHdlJ3ZlIGdvdCBwZW5kaW5nIGNoYW5nZXNcbiAgICAgICAgICAgIHNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG5cbiAgICAgICAgICAgIGJ1aWxkZXJVSS5jYW52YXNMb2FkaW5nKCdvbicpO1xuXG4gICAgICAgICAgICBpZiAoIGZpcmVFdmVudCApIHB1Ymxpc2hlci5wdWJsaXNoKCdvbkJsb2NrQ2hhbmdlJywgdGhpcywgJ3JlbG9hZCcpO1xuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGxhdW5jaGVzIHRoZSBzb3VyY2UgY29kZSBlZGl0b3JcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWRlIHRoZSBpZnJhbWVcbiAgICAgICAgICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9kaXNhYmxlIHNvcnRhYmxlIG9uIHRoZSBwYXJlbnRMSVxuICAgICAgICAgICAgJCh0aGlzLnBhcmVudExJLnBhcmVudE5vZGUpLnNvcnRhYmxlKCdkaXNhYmxlJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYnVpbHQgZWRpdG9yIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciB0aGVFZGl0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICAgIHRoZUVkaXRvci5jbGFzc0xpc3QuYWRkKCdhY2VFZGl0b3InKTtcbiAgICAgICAgICAgICQodGhlRWRpdG9yKS51bmlxdWVJZCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhcmVudExJLmFwcGVuZENoaWxkKHRoZUVkaXRvcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYnVpbGQgYW5kIGFwcGVuZCBlcnJvciBkcmF3ZXJcbiAgICAgICAgICAgIHZhciBuZXdMSSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0xJJyk7XG4gICAgICAgICAgICB2YXIgZXJyb3JEcmF3ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICAgIGVycm9yRHJhd2VyLmNsYXNzTGlzdC5hZGQoJ2Vycm9yRHJhd2VyJyk7XG4gICAgICAgICAgICBlcnJvckRyYXdlci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2Rpdl9lcnJvckRyYXdlcicpO1xuICAgICAgICAgICAgZXJyb3JEcmF3ZXIuaW5uZXJIVE1MID0gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi14cyBidG4tZW1ib3NzZWQgYnRuLWRlZmF1bHQgYnV0dG9uX2NsZWFyRXJyb3JEcmF3ZXJcIiBpZD1cImJ1dHRvbl9jbGVhckVycm9yRHJhd2VyXCI+Q0xFQVI8L2J1dHRvbj4nO1xuICAgICAgICAgICAgbmV3TEkuYXBwZW5kQ2hpbGQoZXJyb3JEcmF3ZXIpO1xuICAgICAgICAgICAgZXJyb3JEcmF3ZXIucXVlcnlTZWxlY3RvcignYnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudExJLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0xJLCB0aGlzLnBhcmVudExJLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdGhlSWQgPSB0aGVFZGl0b3IuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IGFjZS5lZGl0KCB0aGVJZCApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcGFnZUNvbnRhaW5lciA9IHRoaXMuZnJhbWVEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBiQ29uZmlnLnBhZ2VDb250YWluZXIgKTtcbiAgICAgICAgICAgIHZhciB0aGVIVE1MID0gcGFnZUNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZSggdGhlSFRNTCApO1xuICAgICAgICAgICAgZWRpdG9yLnNldFRoZW1lKFwiYWNlL3RoZW1lL3R3aWxpZ2h0XCIpO1xuICAgICAgICAgICAgZWRpdG9yLmdldFNlc3Npb24oKS5zZXRNb2RlKFwiYWNlL21vZGUvaHRtbFwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBlZGl0b3IuZ2V0U2Vzc2lvbigpLm9uKFwiY2hhbmdlQW5ub3RhdGlvblwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJsb2NrLmFubm90ID0gZWRpdG9yLmdldFNlc3Npb24oKS5nZXRBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChibG9jay5hbm5vdFRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXRDb3VudDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggJCgnI2Rpdl9lcnJvckRyYXdlciBwJykuc2l6ZSgpID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0Q291bnQgPSBiQ29uZmlnLnNvdXJjZUNvZGVFZGl0U3ludGF4RGVsYXk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dENvdW50ID0gMTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBibG9jay5hbm5vdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGJsb2NrLmFubm90KXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2suYW5ub3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGJsb2NrLmFubm90W2tleV0udGV4dCAhPT0gXCJTdGFydCB0YWcgc2VlbiB3aXRob3V0IHNlZWluZyBhIGRvY3R5cGUgZmlyc3QuIEV4cGVjdGVkIGUuZy4gPCFET0NUWVBFIGh0bWw+LlwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGluZSA9ICQoJzxwPjwvcD4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0tleSA9ICQoJzxiPicrYmxvY2suYW5ub3Rba2V5XS50eXBlKyc6IDwvYj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0luZm8gPSAkKCc8c3Bhbj4gJytibG9jay5hbm5vdFtrZXldLnRleHQgKyBcIm9uIGxpbmUgXCIgKyBcIiA8Yj5cIiArIGJsb2NrLmFubm90W2tleV0ucm93Kyc8L2I+PC9zcGFuPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaW5lLmFwcGVuZCggbmV3S2V5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpbmUuYXBwZW5kKCBuZXdJbmZvICk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjZGl2X2Vycm9yRHJhd2VyJykuYXBwZW5kKCBuZXdMaW5lICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKCAkKCcjZGl2X2Vycm9yRHJhd2VyJykuY3NzKCdkaXNwbGF5JykgPT09ICdub25lJyAmJiAkKCcjZGl2X2Vycm9yRHJhd2VyJykuZmluZCgncCcpLnNpemUoKSA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjZGl2X2Vycm9yRHJhd2VyJykuc2xpZGVEb3duKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXRDb3VudCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2J1dHRvbnNcbiAgICAgICAgICAgIHZhciBjYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdCVVRUT04nKTtcbiAgICAgICAgICAgIGNhbmNlbEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgICAgICAgICBjYW5jZWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnRuJyk7XG4gICAgICAgICAgICBjYW5jZWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnRuLWRhbmdlcicpO1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J0bi1zbScpO1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2VkaXRDYW5jZWxCdXR0b24nKTtcbiAgICAgICAgICAgIGNhbmNlbEJ1dHRvbi5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmdWktY3Jvc3NcIj48L2k+IDxzcGFuPkNhbmNlbDwvc3Bhbj4nO1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc2F2ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0JVVFRPTicpO1xuICAgICAgICAgICAgc2F2ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgICAgICAgICBzYXZlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J0bicpO1xuICAgICAgICAgICAgc2F2ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidG4tcHJpbWFyeScpO1xuICAgICAgICAgICAgc2F2ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidG4tc20nKTtcbiAgICAgICAgICAgIHNhdmVCdXR0b24uY2xhc3NMaXN0LmFkZCgnZWRpdFNhdmVCdXR0b24nKTtcbiAgICAgICAgICAgIHNhdmVCdXR0b24uaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiZnVpLWNoZWNrXCI+PC9pPiA8c3Bhbj5TYXZlPC9zcGFuPic7XG4gICAgICAgICAgICBzYXZlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYnV0dG9uV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgICAgYnV0dG9uV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdlZGl0b3JCdXR0b25zJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJ1dHRvbldyYXBwZXIuYXBwZW5kQ2hpbGQoIGNhbmNlbEJ1dHRvbiApO1xuICAgICAgICAgICAgYnV0dG9uV3JhcHBlci5hcHBlbmRDaGlsZCggc2F2ZUJ1dHRvbiApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhcmVudExJLmFwcGVuZENoaWxkKCBidXR0b25XcmFwcGVyICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJ1aWxkZXJVSS5hY2VFZGl0b3JzWyB0aGVJZCBdID0gZWRpdG9yO1xuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNhbmNlbHMgdGhlIGJsb2NrIHNvdXJjZSBjb2RlIGVkaXRvclxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbFNvdXJjZUJsb2NrID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8vZW5hYmxlIGRyYWdnYWJsZSBvbiB0aGUgTElcbiAgICAgICAgICAgICQodGhpcy5wYXJlbnRMSS5wYXJlbnROb2RlKS5zb3J0YWJsZSgnZW5hYmxlJyk7XG5cdFx0XG4gICAgICAgICAgICAvL2RlbGV0ZSB0aGUgZXJyb3JEcmF3ZXJcbiAgICAgICAgICAgICQodGhpcy5wYXJlbnRMSS5uZXh0U2libGluZykucmVtb3ZlKCk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy9kZWxldGUgdGhlIGVkaXRvclxuICAgICAgICAgICAgdGhpcy5wYXJlbnRMSS5xdWVyeVNlbGVjdG9yKCcuYWNlRWRpdG9yJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAkKHRoaXMuZnJhbWUpLmZhZGVJbig1MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAkKHRoaXMucGFyZW50TEkucXVlcnlTZWxlY3RvcignLmVkaXRvckJ1dHRvbnMnKSkuZmFkZU91dCg1MDAsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHVwZGF0ZXMgdGhlIGJsb2NrcyBzb3VyY2UgY29kZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnNhdmVTb3VyY2VCbG9jayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VuYWJsZSBkcmFnZ2FibGUgb24gdGhlIExJXG4gICAgICAgICAgICAkKHRoaXMucGFyZW50TEkucGFyZW50Tm9kZSkuc29ydGFibGUoJ2VuYWJsZScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdGhlSWQgPSB0aGlzLnBhcmVudExJLnF1ZXJ5U2VsZWN0b3IoJy5hY2VFZGl0b3InKS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICB2YXIgdGhlQ29udGVudCA9IGJ1aWxkZXJVSS5hY2VFZGl0b3JzW3RoZUlkXS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2RlbGV0ZSB0aGUgZXJyb3JEcmF3ZXJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZfZXJyb3JEcmF3ZXInKS5wYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2RlbGV0ZSB0aGUgZWRpdG9yXG4gICAgICAgICAgICB0aGlzLnBhcmVudExJLnF1ZXJ5U2VsZWN0b3IoJy5hY2VFZGl0b3InKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdGhlIGZyYW1lJ3MgY29udGVudFxuICAgICAgICAgICAgdGhpcy5mcmFtZURvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGJDb25maWcucGFnZUNvbnRhaW5lciApLmlubmVySFRNTCA9IHRoZUNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NhbmRib3hlZD9cbiAgICAgICAgICAgIGlmKCB0aGlzLnNhbmRib3ggKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHNhbmRib3hGcmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCB0aGlzLnNhbmRib3ggKTtcbiAgICAgICAgICAgICAgICB2YXIgc2FuZGJveEZyYW1lRG9jdW1lbnQgPSBzYW5kYm94RnJhbWUuY29udGVudERvY3VtZW50IHx8IHNhbmRib3hGcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJ1aWxkZXJVSS50ZW1wRnJhbWUgPSBzYW5kYm94RnJhbWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2FuZGJveEZyYW1lRG9jdW1lbnQucXVlcnlTZWxlY3RvciggYkNvbmZpZy5wYWdlQ29udGFpbmVyICkuaW5uZXJIVE1MID0gdGhlQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9kbyB3ZSBuZWVkIHRvIGV4ZWN1dGUgYSBsb2FkZXIgZnVuY3Rpb24/XG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuc2FuZGJveF9sb2FkZXIgIT09ICcnICkge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVUb0V4ZWN1dGUgPSBcInNhbmRib3hGcmFtZS5jb250ZW50V2luZG93LlwiK3RoaXMuc2FuZGJveF9sb2FkZXIrXCIoKVwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wRnVuYyA9IG5ldyBGdW5jdGlvbihjb2RlVG9FeGVjdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wRnVuYygpO1xuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQodGhpcy5wYXJlbnRMSS5xdWVyeVNlbGVjdG9yKCcuZWRpdG9yQnV0dG9ucycpKS5mYWRlT3V0KDUwMCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYWRqdXN0IGhlaWdodCBvZiB0aGUgZnJhbWVcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0QWRqdXN0bWVudCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL25ldyBwYWdlIGFkZGVkLCB3ZSd2ZSBnb3QgcGVuZGluZyBjaGFuZ2VzXG4gICAgICAgICAgICBzaXRlLnNldFBlbmRpbmdDaGFuZ2VzKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2Jsb2NrIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9ICdjaGFuZ2VkJztcblxuICAgICAgICAgICAgcHVibGlzaGVyLnB1Ymxpc2goJ29uQmxvY2tDaGFuZ2UnLCB0aGlzLCAnY2hhbmdlJyk7XG5cbiAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgY2xlYXJzIG91dCB0aGUgZXJyb3IgZHJhd2VyXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJFcnJvckRyYXdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcHMgPSB0aGlzLnBhcmVudExJLm5leHRTaWJsaW5nLnF1ZXJ5U2VsZWN0b3JBbGwoJ3AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBwc1tpXS5yZW1vdmUoKTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHJldHVybnMgdGhlIGZ1bGwgc291cmNlIGNvZGUgb2YgdGhlIGJsb2NrJ3MgZnJhbWVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRTb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IFwiPGh0bWw+XCI7XG4gICAgICAgICAgICBzb3VyY2UgKz0gdGhpcy5mcmFtZURvY3VtZW50LmhlYWQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgc291cmNlICs9IHRoaXMuZnJhbWVEb2N1bWVudC5ib2R5Lm91dGVySFRNTDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgICAgIFxuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBzZXRzIHRoZSBzb3VyY2UgY29kZSBmb3IgdGhpcyBibG9jaydzIGZyYW1lXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U291cmNlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcblxuICAgICAgICAgICAgJCh0aGlzLmZyYW1lKS5jb250ZW50cygpLmZpbmQoJ2JvZHknKS5odG1sKGNvbnRlbnQpO1xuXG4gICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHBsYWNlcyBhIGRyYWdnZWQvZHJvcHBlZCBibG9jayBmcm9tIHRoZSBsZWZ0IHNpZGViYXIgb250byB0aGUgY2FudmFzXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2VPbkNhbnZhcyA9IGZ1bmN0aW9uKHVpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZnJhbWUgZGF0YSwgd2UnbGwgbmVlZCB0aGlzIGJlZm9yZSBtZXNzaW5nIHdpdGggdGhlIGl0ZW0ncyBjb250ZW50IEhUTUxcbiAgICAgICAgICAgIHZhciBmcmFtZURhdGEgPSB7fSwgYXR0cjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCB1aS5pdGVtLmZpbmQoJ2lmcmFtZScpLnNpemUoKSA+IDAgKSB7Ly9pZnJhbWUgdGh1bWJuYWlsXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZyYW1lRGF0YS5zcmMgPSB1aS5pdGVtLmZpbmQoJ2lmcmFtZScpLmF0dHIoJ3NyYycpO1xuICAgICAgICAgICAgICAgIGZyYW1lRGF0YS5mcmFtZXNfb3JpZ2luYWxfdXJsID0gdWkuaXRlbS5maW5kKCdpZnJhbWUnKS5hdHRyKCdzcmMnKTtcbiAgICAgICAgICAgICAgICBmcmFtZURhdGEuZnJhbWVzX2hlaWdodCA9IHVpLml0ZW0uaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vc2FuZGJveGVkIGJsb2NrP1xuICAgICAgICAgICAgICAgIGF0dHIgPSB1aS5pdGVtLmZpbmQoJ2lmcmFtZScpLmF0dHIoJ3NhbmRib3gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyICE9PSB0eXBlb2YgdW5kZWZpbmVkICYmIGF0dHIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FuZGJveCA9IHNpdGVCdWlsZGVyVXRpbHMuZ2V0UmFuZG9tQXJiaXRyYXJ5KDEwMDAwLCAxMDAwMDAwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYW5kYm94X2xvYWRlciA9IHVpLml0ZW0uZmluZCgnaWZyYW1lJykuYXR0cignZGF0YS1sb2FkZXJmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7Ly9pbWFnZSB0aHVtYm5haWxcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZnJhbWVEYXRhLnNyYyA9IHVpLml0ZW0uZmluZCgnaW1nJykuYXR0cignZGF0YS1zcmNjJyk7XG4gICAgICAgICAgICAgICAgZnJhbWVEYXRhLmZyYW1lc19vcmlnaW5hbF91cmwgPSB1aS5pdGVtLmZpbmQoJ2ltZycpLmF0dHIoJ2RhdGEtc3JjYycpO1xuICAgICAgICAgICAgICAgIGZyYW1lRGF0YS5mcmFtZXNfaGVpZ2h0ID0gdWkuaXRlbS5maW5kKCdpbWcnKS5hdHRyKCdkYXRhLWhlaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9zYW5kYm94ZWQgYmxvY2s/XG4gICAgICAgICAgICAgICAgYXR0ciA9IHVpLml0ZW0uZmluZCgnaW1nJykuYXR0cignZGF0YS1zYW5kYm94Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0ciAhPT0gdHlwZW9mIHVuZGVmaW5lZCAmJiBhdHRyICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbmRib3ggPSBzaXRlQnVpbGRlclV0aWxzLmdldFJhbmRvbUFyYml0cmFyeSgxMDAwMCwgMTAwMDAwMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FuZGJveF9sb2FkZXIgPSB1aS5pdGVtLmZpbmQoJ2ltZycpLmF0dHIoJ2RhdGEtbG9hZGVyZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2NyZWF0ZSB0aGUgbmV3IGJsb2NrIG9iamVjdFxuICAgICAgICAgICAgdGhpcy5mcmFtZUlEID0gMDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50TEkgPSB1aS5pdGVtLmdldCgwKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50TEkuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9ICduZXcnO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmFtZShmcmFtZURhdGEpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRMSS5zdHlsZS5oZWlnaHQgPSB0aGlzLmZyYW1lSGVpZ2h0K1wicHhcIjtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJhbWVDb3ZlcigpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5mcmFtZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luc2VydCB0aGUgY3JlYXRlZCBpZnJhbWVcbiAgICAgICAgICAgIHVpLml0ZW0uYXBwZW5kKCQodGhpcy5mcmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hZGQgdGhlIGJsb2NrIHRvIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIHNpdGUuYWN0aXZlUGFnZS5ibG9ja3Muc3BsaWNlKHVpLml0ZW0uaW5kZXgoKSwgMCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2N1c3RvbSBldmVudFxuICAgICAgICAgICAgdWkuaXRlbS5maW5kKCdpZnJhbWUnKS50cmlnZ2VyKCdjYW52YXN1cGRhdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9kcm9wcGVkIGVsZW1lbnQsIHNvIHdlJ3ZlIGdvdCBwZW5kaW5nIGNoYW5nZXNcbiAgICAgICAgICAgIHNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgaW5qZWN0cyBleHRlcm5hbCBKUyAoZGVmaW5lZCBpbiBjb25maWcuanMpIGludG8gdGhlIGJsb2NrXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZEphdmFzY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIG9sZCxcbiAgICAgICAgICAgICAgICBuZXdTY3JpcHQ7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIG9sZCBvbmVzXG4gICAgICAgICAgICBvbGQgPSB0aGlzLmZyYW1lRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0LmJ1aWxkZXInKTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKysgKSBvbGRbaV0ucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vaW5qZWN0XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGJDb25maWcuZXh0ZXJuYWxKUy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZXdTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdTQ1JJUFQnKTtcbiAgICAgICAgICAgICAgICBuZXdTY3JpcHQuY2xhc3NMaXN0LmFkZCgnYnVpbGRlcicpO1xuICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5zcmMgPSBiQ29uZmlnLmV4dGVybmFsSlNbaV07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lRG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKG5ld1NjcmlwdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgQmxvY2sucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibG9hZFwiOiBcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZyYW1lRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodEFkanVzdG1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRKYXZhc2NyaXB0KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIHRoaXMuY29udGVudEFmdGVyTG9hZCAhPT0gJycgKSB0aGlzLnNldFNvdXJjZSh0aGlzLmNvbnRlbnRBZnRlckxvYWQpO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzLmZyYW1lQ292ZXIpLnJlbW92ZUNsYXNzKCdmcmVzaCcsIDUwMCk7XG5cbiAgICAgICAgICAgICAgICBwdWJsaXNoZXIucHVibGlzaCgnb25CbG9ja0xvYWRlZCcsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgYnVpbGRlclVJLmNhbnZhc0xvYWRpbmcoJ29mZicpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgdGhlQmxvY2sgPSB0aGlzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vZmlndXJlIG91dCB3aGF0IHRvIGRvIG5leHRcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZGVsZXRlQmxvY2snKSB8fCBldmVudC50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2RlbGV0ZUJsb2NrJykgKSB7Ly9kZWxldGUgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJChidWlsZGVyVUkubW9kYWxEZWxldGVCbG9jaykubW9kYWwoJ3Nob3cnKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJChidWlsZGVyVUkubW9kYWxEZWxldGVCbG9jaykub2ZmKCdjbGljaycsICcjZGVsZXRlQmxvY2tDb25maXJtJykub24oJ2NsaWNrJywgJyNkZWxldGVCbG9ja0NvbmZpcm0nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlQmxvY2suZGVsZXRlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoYnVpbGRlclVJLm1vZGFsRGVsZXRlQmxvY2spLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Jlc2V0QmxvY2snKSB8fCBldmVudC50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3Jlc2V0QmxvY2snKSApIHsvL3Jlc2V0IHRoZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJChidWlsZGVyVUkubW9kYWxSZXNldEJsb2NrKS5tb2RhbCgnc2hvdycpOyBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICQoYnVpbGRlclVJLm1vZGFsUmVzZXRCbG9jaykub2ZmKCdjbGljaycsICcjcmVzZXRCbG9ja0NvbmZpcm0nKS5vbignY2xpY2snLCAnI3Jlc2V0QmxvY2tDb25maXJtJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUJsb2NrLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGJ1aWxkZXJVSS5tb2RhbFJlc2V0QmxvY2spLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2h0bWxCbG9jaycpIHx8IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnaHRtbEJsb2NrJykgKSB7Ly9zb3VyY2UgY29kZSBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoZUJsb2NrLnNvdXJjZSgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRDYW5jZWxCdXR0b24nKSB8fCBldmVudC50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRDYW5jZWxCdXR0b24nKSApIHsvL2NhbmNlbCBzb3VyY2UgY29kZSBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoZUJsb2NrLmNhbmNlbFNvdXJjZUJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZWRpdFNhdmVCdXR0b24nKSB8fCBldmVudC50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRTYXZlQnV0dG9uJykgKSB7Ly9zYXZlIHNvdXJjZSBjb2RlXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGVCbG9jay5zYXZlU291cmNlQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdidXR0b25fY2xlYXJFcnJvckRyYXdlcicpICkgey8vY2xlYXIgZXJyb3IgZHJhd2VyXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGVCbG9jay5jbGVhckVycm9yRHJhd2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLypcbiAgICAgICAgU2l0ZSBvYmplY3QgbGl0ZXJhbFxuICAgICovXG4gICAgLypqc2hpbnQgLVcwMDMgKi9cbiAgICB2YXIgc2l0ZSA9IHtcbiAgICAgICAgXG4gICAgICAgIHBlbmRpbmdDaGFuZ2VzOiBmYWxzZSwgICAgICAvL3BlbmRpbmcgY2hhbmdlcyBvciBubz9cbiAgICAgICAgcGFnZXM6IHt9LCAgICAgICAgICAgICAgICAgIC8vYXJyYXkgY29udGFpbmluZyBhbGwgcGFnZXMsIGluY2x1ZGluZyB0aGUgY2hpbGQgZnJhbWVzLCBsb2FkZWQgZnJvbSB0aGUgc2VydmVyIG9uIHBhZ2UgbG9hZFxuICAgICAgICBpc19hZG1pbjogMCwgICAgICAgICAgICAgICAgLy8wIGZvciBub24tYWRtaW4sIDEgZm9yIGFkbWluXG4gICAgICAgIGRhdGE6IHt9LCAgICAgICAgICAgICAgICAgICAvL2NvbnRhaW5lciBmb3IgYWpheCBsb2FkZWQgc2l0ZSBkYXRhXG4gICAgICAgIHBhZ2VzVG9EZWxldGU6IFtdLCAgICAgICAgICAvL2NvbnRhaW5zIHBhZ2VzIHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgc2l0ZVBhZ2VzOiBbXSwgICAgICAgICAgICAgIC8vdGhpcyBpcyB0aGUgb25seSB2YXIgY29udGFpbmluZyB0aGUgcmVjZW50IGNhbnZhcyBjb250ZW50c1xuICAgICAgICBcbiAgICAgICAgc2l0ZVBhZ2VzUmVhZHlGb3JTZXJ2ZXI6IHt9LCAgICAgLy9jb250YWlucyB0aGUgc2l0ZSBkYXRhIHJlYWR5IHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAgICBcbiAgICAgICAgYWN0aXZlUGFnZToge30sICAgICAgICAgICAgIC8vaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIHBhZ2UgY3VycmVudGx5IG9wZW4gb24gdGhlIGNhbnZhc1xuICAgICAgICBcbiAgICAgICAgcGFnZVRpdGxlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFnZVRpdGxlJyksLy9ob2xkcyB0aGUgcGFnZSB0aXRsZSBvZiB0aGUgY3VycmVudCBwYWdlIG9uIHRoZSBjYW52YXNcbiAgICAgICAgXG4gICAgICAgIGRpdkNhbnZhczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhZ2VMaXN0JyksLy9ESVYgY29udGFpbmluZyBhbGwgcGFnZXMgb24gdGhlIGNhbnZhc1xuICAgICAgICBcbiAgICAgICAgcGFnZXNNZW51OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFnZXMnKSwgLy9VTCBjb250YWluaW5nIHRoZSBwYWdlcyBtZW51IGluIHRoZSBzaWRlYmFyXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIGJ1dHRvbk5ld1BhZ2U6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGRQYWdlJyksXG4gICAgICAgIGxpTmV3UGFnZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25ld1BhZ2VMSScpLFxuICAgICAgICBcbiAgICAgICAgaW5wdXRQYWdlU2V0dGluZ3NUaXRsZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhZ2VEYXRhX3RpdGxlJyksXG4gICAgICAgIGlucHV0UGFnZVNldHRpbmdzTWV0YURlc2NyaXB0aW9uOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFnZURhdGFfbWV0YURlc2NyaXB0aW9uJyksXG4gICAgICAgIGlucHV0UGFnZVNldHRpbmdzTWV0YUtleXdvcmRzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFnZURhdGFfbWV0YUtleXdvcmRzJyksXG4gICAgICAgIGlucHV0UGFnZVNldHRpbmdzSW5jbHVkZXM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWdlRGF0YV9oZWFkZXJJbmNsdWRlcycpLFxuICAgICAgICBpbnB1dFBhZ2VTZXR0aW5nc1BhZ2VDc3M6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWdlRGF0YV9oZWFkZXJDc3MnKSxcbiAgICAgICAgXG4gICAgICAgIGJ1dHRvblN1Ym1pdFBhZ2VTZXR0aW5nczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhZ2VTZXR0aW5nc1N1Ym1pdHRCdXR0b24nKSxcbiAgICAgICAgXG4gICAgICAgIG1vZGFsUGFnZVNldHRpbmdzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFnZVNldHRpbmdzTW9kYWwnKSxcbiAgICAgICAgXG4gICAgICAgIGJ1dHRvblNhdmU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYXZlUGFnZScpLFxuICAgICAgICBcbiAgICAgICAgbWVzc2FnZVN0YXJ0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnQnKSxcbiAgICAgICAgZGl2RnJhbWVXcmFwcGVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJhbWVXcmFwcGVyJyksXG4gICAgICAgIFxuICAgICAgICBza2VsZXRvbjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NrZWxldG9uJyksXG5cbiAgICAgICAgYnV0dG9uRW1wdHlQYWdlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xlYXJTY3JlZW4nKSxcblxuICAgICAgICBhY3Rpb25CdXR0b25zOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWN0aW9uQnV0dG9ucycpLFxuXHRcdFxuXHRcdGF1dG9TYXZlVGltZXI6IHt9LFxuICAgICAgICBcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICQuZ2V0SlNPTihcInNpdGUuanNvblwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCBkYXRhLnBhZ2VzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGUucGFnZXMgPSBkYXRhLnBhZ2VzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGUucGFnZXMgPSB7aW5kZXg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlX2lkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZXNfdGl0bGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YV9kZXNjcmlwdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhX2tleXdvcmRzOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcl9pbmNsdWRlczogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlX2NzczogJydcbiAgICAgICAgICAgICAgICAgICAgfX07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGRhdGEucmVzcG9uc2l2ZU1vZGUgKSBwdWJsaXNoZXIucHVibGlzaCgnb25TZXRNb2RlJywgZGF0YS5yZXNwb25zaXZlTW9kZSk7XG5cbiAgICAgICAgICAgICAgICBwdWJsaXNoZXIuc3Vic2NyaWJlKCdvbkJsb2NrQ2hhbmdlJywgZnVuY3Rpb24gKGJsb2NrLCB0eXBlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBibG9jay5nbG9iYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNpdGUuc2l0ZVBhZ2VzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIHkgPSAwOyB5IDwgc2l0ZS5zaXRlUGFnZXNbaV0uYmxvY2tzLmxlbmd0aDsgeSArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNpdGUuc2l0ZVBhZ2VzW2ldLmJsb2Nrc1t5XSAhPT0gYmxvY2sgJiYgc2l0ZS5zaXRlUGFnZXNbaV0uYmxvY2tzW3ldLm9yaWdpbmFsVXJsID09PSBibG9jay5vcmlnaW5hbFVybCAmJiBzaXRlLnNpdGVQYWdlc1tpXS5ibG9ja3NbeV0uZ2xvYmFsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09ICdjaGFuZ2UnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZS5zaXRlUGFnZXNbaV0uYmxvY2tzW3ldLmZyYW1lRG9jdW1lbnQuYm9keSA9IGJsb2NrLmZyYW1lRG9jdW1lbnQuYm9keS5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXIucHVibGlzaCgnb25CbG9ja0xvYWRlZCcsIHNpdGUuc2l0ZVBhZ2VzW2ldLmJsb2Nrc1t5XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09ICdyZWxvYWQnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZS5zaXRlUGFnZXNbaV0uYmxvY2tzW3ldLnJlc2V0KGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9maXJlIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgICAgICQoJ2JvZHknKS50cmlnZ2VyKCdzaXRlRGF0YUxvYWRlZCcpO1xuXG4gICAgICAgICAgICAgICAgYnVpbGRlclVJLnBvcHVsYXRlQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAkKHRoaXMuYnV0dG9uTmV3UGFnZSkub24oJ2NsaWNrJywgc2l0ZS5uZXdQYWdlKTtcbiAgICAgICAgICAgICQodGhpcy5tb2RhbFBhZ2VTZXR0aW5ncykub24oJ3Nob3cuYnMubW9kYWwnLCBzaXRlLmxvYWRQYWdlU2V0dGluZ3MpO1xuICAgICAgICAgICAgJCh0aGlzLmJ1dHRvblN1Ym1pdFBhZ2VTZXR0aW5ncykub24oJ2NsaWNrJywgc2l0ZS51cGRhdGVQYWdlU2V0dGluZ3MpO1xuICAgICAgICAgICAgJCh0aGlzLmJ1dHRvblNhdmUpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7c2l0ZS5zYXZlKHRydWUpO30pO1xuICAgICAgICAgICAgJCh0aGlzLmJ1dHRvbkVtcHR5UGFnZSkub24oJ2NsaWNrJywgc2l0ZS5lbXB0eVBhZ2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2F1dG8gc2F2ZSB0aW1lIFxuICAgICAgICAgICAgdGhpcy5hdXRvU2F2ZVRpbWVyID0gc2V0VGltZW91dChzaXRlLmF1dG9TYXZlLCBiQ29uZmlnLmF1dG9TYXZlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBhdXRvU2F2ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoc2l0ZS5wZW5kaW5nQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHNpdGUuc2F2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG5cdFx0XHRcblx0XHRcdHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuYXV0b1NhdmVUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmF1dG9TYXZlVGltZXIgPSBzZXRUaW1lb3V0KHNpdGUuYXV0b1NhdmUsIGJDb25maWcuYXV0b1NhdmVUaW1lb3V0KTtcbiAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHNldFBlbmRpbmdDaGFuZ2VzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGFuZ2VzID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMuaXNFbXB0eSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggdmFsdWUgPT09IHRydWUgKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL3Jlc2V0IHRpbWVyXG5cdFx0XHRcdHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuYXV0b1NhdmVUaW1lcik7XG4gICAgICAgICAgICBcdHRoaXMuYXV0b1NhdmVUaW1lciA9IHNldFRpbWVvdXQoc2l0ZS5hdXRvU2F2ZSwgYkNvbmZpZy5hdXRvU2F2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoJyNzYXZlUGFnZSAuYkxhYmVsJykudGV4dChcIlNhdmUgbm93ICghKVwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggc2l0ZS5hY3RpdmVQYWdlLnN0YXR1cyAhPT0gJ25ldycgKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHNpdGUuYWN0aXZlUGFnZS5zdGF0dXMgPSAnY2hhbmdlZCc7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblx0XHRcdFxuICAgICAgICAgICAgfSBlbHNlIHtcblx0XG4gICAgICAgICAgICAgICAgJCgnI3NhdmVQYWdlIC5iTGFiZWwnKS50ZXh0KFwiTm90aGluZyB0byBzYXZlXCIpO1xuXHRcdFx0XHRcbiAgICAgICAgICAgICAgICBzaXRlLnVwZGF0ZVBhZ2VTdGF0dXMoJycpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oc2hvd0NvbmZpcm1Nb2RhbCkge1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIucHVibGlzaCgnb25CZWZvcmVTYXZlJyk7XG5cbiAgICAgICAgICAgIC8vZGlzYWJsZSBidXR0b25cbiAgICAgICAgICAgICQoXCJhI3NhdmVQYWdlXCIpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxUZXh0ID0gJCgnYSNzYXZlUGFnZScpLmZpbmQoJy5iTGFiZWwnKS50ZXh0KCk7XG4gICAgICAgICAgICB2YXIgYWx0VGV4dCA9ICQoJ2Ejc2F2ZVBhZ2UnKS5maW5kKCcuYkxhYmVsJykuYXR0cignZGF0YS1hbHQtdGV4dCcpO1xuXG4gICAgICAgICAgICAkKCdhI3NhdmVQYWdlJykuZmluZCgnLmJMYWJlbCcpLnRleHQoYWx0VGV4dCk7XG4gICAgICAgICAgICAkKCdhI3NhdmVQYWdlJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBwYWdlcyA9IHt9LCB0aGVTaXRlO1xuXG4gICAgICAgICAgICBpZiggc2l0ZS5zaXRlUGFnZXNbMF0uYmxvY2tzLmxlbmd0aCAhPT0gMCApIHtcblxuICAgICAgICAgICAgICAgIGZvciggdmFyIHggPSAwOyB4IDwgc2l0ZS5zaXRlUGFnZXMubGVuZ3RoOyB4KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIHNpdGUuc2l0ZVBhZ2VzW3hdLmJsb2Nrcy5sZW5ndGggIT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VzW3NpdGUuc2l0ZVBhZ2VzW3hdLm5hbWVdID0gc2l0ZS5zaXRlUGFnZXNbeF0ucHJlcEZvclNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlc1tzaXRlLnNpdGVQYWdlc1t4XS5uYW1lXSA9ICdlbXB0eSc7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhlU2l0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZXM6IHBhZ2VzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoZVNpdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zdG9yZSBjdXJyZW50IHJlc3BvbnNpdmUgbW9kZSBhcyB3ZWxsXG4gICAgICAgICAgICB0aGVTaXRlLnJlc3BvbnNpdmVNb2RlID0gYnVpbGRlclVJLmN1cnJlbnRSZXNwb25zaXZlTW9kZTtcblxuICAgICAgICAgICAgLy9yZW1vdmUgb2xkIGFsZXJ0c1xuICAgICAgICAgICAgJCgnI2Vycm9yTW9kYWwgLm1vZGFsLWJvZHkgPiAqLCAjc3VjY2Vzc01vZGFsIC5tb2RhbC1ib2R5ID4gKicpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiAnX3NhdmUucGhwJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7ZGF0YTogdGhlU2l0ZX0sXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiXG4gICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChyZXMpIHtcblxuICAgICAgICAgICAgICAgIC8vZW5hYmxlIGJ1dHRvblxuICAgICAgICAgICAgICAgICQoXCJhI3NhdmVQYWdlXCIpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgICAgICAgICAgICAgaWYoIHJlcy5yZXNwb25zZUNvZGUgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiggc2hvd0NvbmZpcm1Nb2RhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNlcnJvck1vZGFsIC5tb2RhbC1ib2R5JykuaHRtbCggcmVzLnJlc3BvbnNlSFRNTCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2Vycm9yTW9kYWwnKS5tb2RhbCgnc2hvdycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggcmVzLnJlc3BvbnNlQ29kZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vbm8gbW9yZSBwZW5kaW5nIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgc2l0ZS5zZXRQZW5kaW5nQ2hhbmdlcyhmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLnRyaWdnZXIoJ2NoYW5nZVBhZ2UnKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgcHJlcHMgdGhlIHNpdGUgZGF0YSBiZWZvcmUgc2VuZGluZyBpdCB0byB0aGUgc2VydmVyXG4gICAgICAgICovXG4gICAgICAgIHByZXBGb3JTYXZlOiBmdW5jdGlvbih0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNpdGVQYWdlc1JlYWR5Rm9yU2VydmVyID0ge307XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCB0ZW1wbGF0ZSApIHsvL3NhdmluZyB0ZW1wbGF0ZSwgb25seSB0aGUgYWN0aXZlUGFnZSBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnNpdGVQYWdlc1JlYWR5Rm9yU2VydmVyW3RoaXMuYWN0aXZlUGFnZS5uYW1lXSA9IHRoaXMuYWN0aXZlUGFnZS5wcmVwRm9yU2F2ZSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUGFnZS5mdWxsUGFnZSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHsvL3JlZ3VsYXIgc2F2ZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBwYWdlcyB3aGljaCBuZWVkIHRvIGJlIHNlbmQgdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5zaXRlUGFnZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5zaXRlUGFnZXNbaV0uc3RhdHVzICE9PSAnJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXRlUGFnZXNSZWFkeUZvclNlcnZlclt0aGlzLnNpdGVQYWdlc1tpXS5uYW1lXSA9IHRoaXMuc2l0ZVBhZ2VzW2ldLnByZXBGb3JTYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHNldHMgYSBwYWdlIGFzIHRoZSBhY3RpdmUgb25lXG4gICAgICAgICovXG4gICAgICAgIHNldEFjdGl2ZTogZnVuY3Rpb24ocGFnZSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3JlZmVyZW5jZSB0byB0aGUgYWN0aXZlIHBhZ2VcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaGlkZSBvdGhlciBwYWdlc1xuICAgICAgICAgICAgZm9yKHZhciBpIGluIHRoaXMuc2l0ZVBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXRlUGFnZXNbaV0ucGFyZW50VUwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9kaXNwbGF5IGFjdGl2ZSBvbmVcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUGFnZS5wYXJlbnRVTC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBkZS1hY3RpdmUgYWxsIHBhZ2UgbWVudSBpdGVtc1xuICAgICAgICAqL1xuICAgICAgICBkZUFjdGl2YXRlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBhZ2VzID0gdGhpcy5wYWdlc01lbnUucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBwYWdlc1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBhZGRzIGEgbmV3IHBhZ2UgdG8gdGhlIHNpdGVcbiAgICAgICAgKi9cbiAgICAgICAgbmV3UGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNpdGUuZGVBY3RpdmF0ZUFsbCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2NyZWF0ZSB0aGUgbmV3IHBhZ2UgaW5zdGFuY2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBhZ2VEYXRhID0gW107XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHtcbiAgICAgICAgICAgICAgICBwYWdlc19pZDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhZ2VEYXRhWzBdID0gdGVtcDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG5ld1BhZ2VOYW1lID0gJ3BhZ2UnKyhzaXRlLnNpdGVQYWdlcy5sZW5ndGgrMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBuZXdQYWdlID0gbmV3IFBhZ2UobmV3UGFnZU5hbWUsIHBhZ2VEYXRhLCBzaXRlLnNpdGVQYWdlcy5sZW5ndGgrMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5ld1BhZ2Uuc3RhdHVzID0gJ25ldyc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5ld1BhZ2Uuc2VsZWN0UGFnZSgpO1xuICAgICAgICAgICAgbmV3UGFnZS5lZGl0UGFnZU5hbWUoKTtcbiAgICAgICAgXG4gICAgICAgICAgICBuZXdQYWdlLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgc2l0ZS5zZXRQZW5kaW5nQ2hhbmdlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBjaGVja3MgaWYgdGhlIG5hbWUgb2YgYSBwYWdlIGlzIGFsbG93ZWRcbiAgICAgICAgKi9cbiAgICAgICAgY2hlY2tQYWdlTmFtZTogZnVuY3Rpb24ocGFnZU5hbWUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhlIG5hbWUgaXMgdW5pcXVlXG4gICAgICAgICAgICBmb3IoIHZhciBpIGluIHRoaXMuc2l0ZVBhZ2VzICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLnNpdGVQYWdlc1tpXS5uYW1lID09PSBwYWdlTmFtZSAmJiB0aGlzLmFjdGl2ZVBhZ2UgIT09IHRoaXMuc2l0ZVBhZ2VzW2ldICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VOYW1lRXJyb3IgPSBcIlRoZSBwYWdlIG5hbWUgbXVzdCBiZSB1bmlxdWUuXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHJlbW92ZXMgdW5hbGxvd2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgcGFnZSBuYW1lXG4gICAgICAgICovXG4gICAgICAgIHByZXBQYWdlTmFtZTogZnVuY3Rpb24ocGFnZU5hbWUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFnZU5hbWUgPSBwYWdlTmFtZS5yZXBsYWNlKCcgJywgJycpO1xuICAgICAgICAgICAgcGFnZU5hbWUgPSBwYWdlTmFtZS5yZXBsYWNlKC9bPyohLnwmIzskJUBcIjw+KCkrLF0vZywgXCJcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBwYWdlTmFtZTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBzYXZlIHBhZ2Ugc2V0dGluZ3MgZm9yIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlUGFnZVNldHRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2l0ZS5hY3RpdmVQYWdlLnBhZ2VTZXR0aW5ncy50aXRsZSA9IHNpdGUuaW5wdXRQYWdlU2V0dGluZ3NUaXRsZS52YWx1ZTtcbiAgICAgICAgICAgIHNpdGUuYWN0aXZlUGFnZS5wYWdlU2V0dGluZ3MubWV0YV9kZXNjcmlwdGlvbiA9IHNpdGUuaW5wdXRQYWdlU2V0dGluZ3NNZXRhRGVzY3JpcHRpb24udmFsdWU7XG4gICAgICAgICAgICBzaXRlLmFjdGl2ZVBhZ2UucGFnZVNldHRpbmdzLm1ldGFfa2V5d29yZHMgPSBzaXRlLmlucHV0UGFnZVNldHRpbmdzTWV0YUtleXdvcmRzLnZhbHVlO1xuICAgICAgICAgICAgc2l0ZS5hY3RpdmVQYWdlLnBhZ2VTZXR0aW5ncy5oZWFkZXJfaW5jbHVkZXMgPSBzaXRlLmlucHV0UGFnZVNldHRpbmdzSW5jbHVkZXMudmFsdWU7XG4gICAgICAgICAgICBzaXRlLmFjdGl2ZVBhZ2UucGFnZVNldHRpbmdzLnBhZ2VfY3NzID0gc2l0ZS5pbnB1dFBhZ2VTZXR0aW5nc1BhZ2VDc3MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQoc2l0ZS5tb2RhbFBhZ2VTZXR0aW5ncykubW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICB1cGRhdGUgcGFnZSBzdGF0dXNlc1xuICAgICAgICAqL1xuICAgICAgICB1cGRhdGVQYWdlU3RhdHVzOiBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKCB2YXIgaSBpbiB0aGlzLnNpdGVQYWdlcyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpdGVQYWdlc1tpXS5zdGF0dXMgPSBzdGF0dXM7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBDbGVhcnMgYWxsIHRoZSBibG9ja3Mgb24gdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAqL1xuICAgICAgICBlbXB0eVBhZ2U6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgc2l0ZS5hY3RpdmVQYWdlLmNsZWFyKCk7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBDaGVja3MgaWYgdGhlIGVudGlyZSBwYWdlIGlzIGVtcHR5LCBpZiBzbywgZGlzYWJsZSBhY3Rpb24gYnV0dG9uc1xuICAgICAgICAqL1xuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gMDtcblxuICAgICAgICAgICAgaWYodGhpcy5zaXRlUGFnZXMubGVuZ3RoID09PSAxICYmIHRoaXMuYWN0aXZlUGFnZS5ibG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yKCB4ID0gMDsgeCA8IHRoaXMuYWN0aW9uQnV0dG9ucy5sZW5ndGg7IHgrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25CdXR0b25zW3hdLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IoIHggPSAwOyB4IDwgdGhpcy5hY3Rpb25CdXR0b25zLmxlbmd0aDsgeCsrICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbkJ1dHRvbnNbeF0uY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBDaGVja3MgYWxsIHRoZSBibG9ja3MgaW4gdGhpcyBzaXRlIGhhdmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgICAqL1xuICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdGhpcy5zaXRlUGFnZXMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICF0aGlzLnNpdGVQYWdlc1tpXS5sb2FkZWQoKSApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIE1ha2UgZXZlcnkgYmxvY2sgaGF2ZSBhbiBvdmVybGF5IGR1cmluZyBkcmFnZ2luZyB0byBwcmV2ZW50IG1vdXNlIGV2ZW50IGlzc3Vlc1xuICAgICAgICAqL1xuICAgICAgICBtb3ZlTW9kZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHRoaXMuYWN0aXZlUGFnZS5ibG9ja3MubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSAnb24nICkgdGhpcy5hY3RpdmVQYWdlLmJsb2Nrc1tpXS5mcmFtZUNvdmVyLmNsYXNzTGlzdC5hZGQoJ21vdmUnKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICggdmFsdWUgPT09ICdvZmYnICkgdGhpcy5hY3RpdmVQYWdlLmJsb2Nrc1tpXS5mcmFtZUNvdmVyLmNsYXNzTGlzdC5yZW1vdmUoJ21vdmUnKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICBcbiAgICB9O1xuXG4gICAgYnVpbGRlclVJLmluaXQoKTsgc2l0ZS5pbml0KCk7XG5cbiAgICBcbiAgICAvLyoqKiogRVhQT1JUU1xuICAgIG1vZHVsZS5leHBvcnRzLnNpdGUgPSBzaXRlO1xuICAgIG1vZHVsZS5leHBvcnRzLmJ1aWxkZXJVSSA9IGJ1aWxkZXJVSTtcblxufSgpKTsiLCIoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHNpdGVCdWlsZGVyID0gcmVxdWlyZSgnLi9idWlsZGVyLmpzJyk7XG5cbiAgICAvKlxuICAgICAgICBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgRWxlbWVudFxuICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMuRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbDtcbiAgICAgICAgdGhpcy5zYW5kYm94ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50RnJhbWUgPSB7fTtcbiAgICAgICAgdGhpcy5wYXJlbnRCbG9jayA9IHt9Oy8vcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgYmxvY2sgZWxlbWVudFxuICAgICAgICB0aGlzLmVkaXRhYmxlQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgLy9tYWtlIGN1cnJlbnQgZWxlbWVudCBhY3RpdmUvb3BlbiAoYmVpbmcgd29ya2VkIG9uKVxuICAgICAgICB0aGlzLnNldE9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJCh0aGlzLmVsZW1lbnQpLm9mZignbW91c2VlbnRlciBtb3VzZWxlYXZlIGNsaWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgJCh0aGlzLmVsZW1lbnQpLmNzcyh7J291dGxpbmUnOiAnMnB4IHNvbGlkIHJnYmEoMjMzLDk0LDk0LDAuNSknLCAnb3V0bGluZS1vZmZzZXQnOictMnB4JywgJ2N1cnNvcic6ICdwb2ludGVyJ30pO1xuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvL3NldHMgdXAgaG92ZXIgYW5kIGNsaWNrIGV2ZW50cywgbWFraW5nIHRoZSBlbGVtZW50IGFjdGl2ZSBvbiB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvL2RhdGEgYXR0cmlidXRlcyBmb3IgY29sb3JcbiAgICAgICAgICAgIGlmICggdGhpcy5lbGVtZW50LnRhZ05hbWUgPT09ICdBJyApICQodGhpcy5lbGVtZW50KS5kYXRhKCdjb2xvcicsIGdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KS5jb2xvcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQodGhpcy5lbGVtZW50KS5jc3MoeydvdXRsaW5lJzogJ25vbmUnLCAnY3Vyc29yJzogJ2luaGVyaXQnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICQodGhpcy5lbGVtZW50KS5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcyh7J291dGxpbmUnOiAnMnB4IHNvbGlkIHJnYmEoMjMzLDk0LDk0LDAuNSknLCAnb3V0bGluZS1vZmZzZXQnOiAnLTJweCcsICdjdXJzb3InOiAncG9pbnRlcid9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcyh7J291dGxpbmUnOiAnJywgJ2N1cnNvcic6ICcnLCAnb3V0bGluZS1vZmZzZXQnOiAnJ30pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB9KS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGlja0hhbmRsZXIodGhpcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJCh0aGlzLmVsZW1lbnQpLm9mZignbW91c2VlbnRlciBtb3VzZWxlYXZlIGNsaWNrJyk7XG4gICAgICAgICAgICAkKHRoaXMuZWxlbWVudCkuY3NzKHsnb3V0bGluZSc6ICdub25lJywgJ2N1cnNvcic6ICdpbmhlcml0J30pO1xuXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvL3JlbW92ZXMgdGhlIGVsZW1lbnRzIG91dGxpbmVcbiAgICAgICAgdGhpcy5yZW1vdmVPdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQodGhpcy5lbGVtZW50KS5jc3MoeydvdXRsaW5lJzogJ25vbmUnLCAnY3Vyc29yJzogJ2luaGVyaXQnfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vc2V0cyB0aGUgcGFyZW50IGlmcmFtZVxuICAgICAgICB0aGlzLnNldFBhcmVudEZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIHZhciB3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICAgICAgICB2YXIgZnJhbWVzID0gdy5wYXJlbnQuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lmcmFtZScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpPSBmcmFtZXMubGVuZ3RoOyBpLS0+MDspIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWU9IGZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZD0gZnJhbWUuY29udGVudERvY3VtZW50IHx8IGZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkPT09ZG9jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy9zZXRzIHRoaXMgZWxlbWVudCdzIHBhcmVudCBibG9jayByZWZlcmVuY2VcbiAgICAgICAgdGhpcy5zZXRQYXJlbnRCbG9jayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCBhbGwgdGhlIGJsb2NrcyBvbiB0aGUgY2FudmFzXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNpdGVCdWlsZGVyLnNpdGUuc2l0ZVBhZ2VzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IoIHZhciB4ID0gMDsgeCA8IHNpdGVCdWlsZGVyLnNpdGUuc2l0ZVBhZ2VzW2ldLmJsb2Nrcy5sZW5ndGg7IHgrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgYmxvY2sncyBmcmFtZSBtYXRjaGVzIHRoaXMgZWxlbWVudCdzIHBhcmVudCBmcmFtZVxuICAgICAgICAgICAgICAgICAgICBpZiggc2l0ZUJ1aWxkZXIuc2l0ZS5zaXRlUGFnZXNbaV0uYmxvY2tzW3hdLmZyYW1lID09PSB0aGlzLnBhcmVudEZyYW1lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhhdCBibG9jayBhbmQgc3RvcmUgaXQgaW4gdGhpcy5wYXJlbnRCbG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRCbG9jayA9IHNpdGVCdWlsZGVyLnNpdGUuc2l0ZVBhZ2VzW2ldLmJsb2Nrc1t4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0UGFyZW50RnJhbWUoKTtcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICAgICBpcyB0aGlzIGJsb2NrIHNhbmRib3hlZD9cbiAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIGlmKCB0aGlzLnBhcmVudEZyYW1lLmdldEF0dHJpYnV0ZSgnZGF0YS1zYW5kYm94JykgKSB7XG4gICAgICAgICAgICB0aGlzLnNhbmRib3ggPSB0aGlzLnBhcmVudEZyYW1lLmdldEF0dHJpYnV0ZSgnZGF0YS1zYW5kYm94Jyk7ICAgXG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICB9O1xuXG59KCkpOyIsIihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuICAgICAgICBcbiAgICBtb2R1bGUuZXhwb3J0cy5wYWdlQ29udGFpbmVyID0gXCIjcGFnZVwiO1xuICAgIFxuICAgIG1vZHVsZS5leHBvcnRzLmVkaXRhYmxlSXRlbXMgPSB7XG4gICAgICAgICdzcGFuLmZhJzogWydjb2xvcicsICdmb250LXNpemUnXSxcbiAgICAgICAgJy5iZy5iZzEnOiBbJ2JhY2tncm91bmQtY29sb3InXSxcbiAgICAgICAgJ25hdiBhJzogWydjb2xvcicsICdmb250LXdlaWdodCcsICd0ZXh0LXRyYW5zZm9ybSddLFxuICAgICAgICAnaW1nJzogWydib3JkZXItdG9wLWxlZnQtcmFkaXVzJywgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJywgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnLCAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnLCAnYm9yZGVyLWNvbG9yJywgJ2JvcmRlci1zdHlsZScsICdib3JkZXItd2lkdGgnXSxcbiAgICAgICAgJ2hyLmRhc2hlZCc6IFsnYm9yZGVyLWNvbG9yJywgJ2JvcmRlci13aWR0aCddLFxuICAgICAgICAnLmRpdmlkZXIgPiBzcGFuJzogWydjb2xvcicsICdmb250LXNpemUnXSxcbiAgICAgICAgJ2hyLnNoYWRvd0Rvd24nOiBbJ21hcmdpbi10b3AnLCAnbWFyZ2luLWJvdHRvbSddLFxuICAgICAgICAnLmZvb3RlciBhJzogWydjb2xvciddLFxuICAgICAgICAnLnNvY2lhbCBhJzogWydjb2xvciddLFxuICAgICAgICAnLmJnLmJnMSwgLmJnLmJnMiwgLmhlYWRlcjEwLCAuaGVhZGVyMTEnOiBbJ2JhY2tncm91bmQtaW1hZ2UnLCAnYmFja2dyb3VuZC1jb2xvciddLFxuICAgICAgICAnLmZyYW1lQ292ZXInOiBbXSxcbiAgICAgICAgJy5lZGl0Q29udGVudCc6IFsnY29udGVudCcsICdjb2xvcicsICdmb250LXNpemUnLCAnYmFja2dyb3VuZC1jb2xvcicsICdmb250LWZhbWlseSddLFxuICAgICAgICAnYS5idG4sIGJ1dHRvbi5idG4nOiBbJ2JvcmRlci1yYWRpdXMnLCAnZm9udC1zaXplJywgJ2JhY2tncm91bmQtY29sb3InXSxcbiAgICAgICAgJyNwcmljaW5nX3RhYmxlMiAucHJpY2luZzIgLmJvdHRvbSBsaSc6IFsnY29udGVudCddXG4gICAgfTtcbiAgICBcbiAgICBtb2R1bGUuZXhwb3J0cy5lZGl0YWJsZUl0ZW1PcHRpb25zID0ge1xuICAgICAgICAnbmF2IGEgOiBmb250LXdlaWdodCc6IFsnNDAwJywgJzcwMCddLFxuICAgICAgICAnYS5idG4sIGJ1dHRvbi5idG4gOiBib3JkZXItcmFkaXVzJzogWycwcHgnLCAnNHB4JywgJzEwcHgnXSxcbiAgICAgICAgJ2ltZyA6IGJvcmRlci1zdHlsZSc6IFsnbm9uZScsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ3NvbGlkJ10sXG4gICAgICAgICdpbWcgOiBib3JkZXItd2lkdGgnOiBbJzFweCcsICcycHgnLCAnM3B4JywgJzRweCddLFxuICAgICAgICAnaDEsIGgyLCBoMywgaDQsIGg1LCBwIDogZm9udC1mYW1pbHknOiBbJ2RlZmF1bHQnLCAnTGF0bycsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCAnVGltZXMgTmV3IFJvbWFuJ10sXG4gICAgICAgICdoMiA6IGZvbnQtZmFtaWx5JzogWydkZWZhdWx0JywgJ0xhdG8nLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgJ1RpbWVzIE5ldyBSb21hbiddLFxuICAgICAgICAnaDMgOiBmb250LWZhbWlseSc6IFsnZGVmYXVsdCcsICdMYXRvJywgJ0hlbHZldGljYScsICdBcmlhbCcsICdUaW1lcyBOZXcgUm9tYW4nXSxcbiAgICAgICAgJ3AgOiBmb250LWZhbWlseSc6IFsnZGVmYXVsdCcsICdMYXRvJywgJ0hlbHZldGljYScsICdBcmlhbCcsICdUaW1lcyBOZXcgUm9tYW4nXSxcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMucmVzcG9uc2l2ZU1vZGVzID0ge1xuICAgICAgICBkZXNrdG9wOiAnOTclJyxcbiAgICAgICAgbW9iaWxlOiAnNDgwcHgnLFxuICAgICAgICB0YWJsZXQ6ICcxMDI0cHgnXG4gICAgfTtcblxuICAgIC8vbW9kdWxlLmV4cG9ydHMuZWRpdGFibGVDb250ZW50ID0gWycuZWRpdENvbnRlbnQnLCAnLm5hdmJhciBhJywgJ2J1dHRvbicsICdhLmJ0bicsICcuZm9vdGVyIGE6bm90KC5mYSknLCAnLnRhYmxlV3JhcHBlcicsICdoMSddO1xuICAgIG1vZHVsZS5leHBvcnRzLmVkaXRhYmxlQ29udGVudCA9IFtdO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuYXV0b1NhdmVUaW1lb3V0ID0gMzAwMDAwO1xuICAgIFxuICAgIG1vZHVsZS5leHBvcnRzLnNvdXJjZUNvZGVFZGl0U3ludGF4RGVsYXkgPSAxMDAwMDtcblxuICAgIG1vZHVsZS5leHBvcnRzLm1lZGl1bUNzc1VybHMgPSBbXG4gICAgICAgICcvL2Nkbi5qc2RlbGl2ci5uZXQvbWVkaXVtLWVkaXRvci9sYXRlc3QvY3NzL21lZGl1bS1lZGl0b3IubWluLmNzcycsXG4gICAgICAgICcuLi9jc3MvbWVkaXVtLWJvb3RzdHJhcC5jc3MnXG4gICAgXTtcbiAgICBtb2R1bGUuZXhwb3J0cy5tZWRpdW1CdXR0b25zID0gWydib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnYW5jaG9yJywgJ29yZGVyZWRsaXN0JywgJ3Vub3JkZXJlZGxpc3QnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAncmVtb3ZlRm9ybWF0J107XG4gICAgICBcbiAgICBtb2R1bGUuZXhwb3J0cy5leHRlcm5hbEpTID0gW1xuICAgICAgICAnanMvYnVpbGRlcl9pbl9ibG9jay5qcydcbiAgICBdOyAgICAgICAgICAgICAgXG59KCkpOyIsIihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBjYW52YXNFbGVtZW50ID0gcmVxdWlyZSgnLi9jYW52YXNFbGVtZW50LmpzJykuRWxlbWVudDtcblx0dmFyIGJDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXHR2YXIgc2l0ZUJ1aWxkZXIgPSByZXF1aXJlKCcuL2J1aWxkZXIuanMnKTtcbiAgICB2YXIgcHVibGlzaGVyID0gcmVxdWlyZSgnLi4vdmVuZG9yL3B1Ymxpc2hlcicpO1xuICAgIHZhciBNZWRpdW1FZGl0b3IgPSByZXF1aXJlKCdtZWRpdW0tZWRpdG9yJyk7XG4gICAgdmFyIG1lZGl1bUV4dGVuc2lvbnMgPSByZXF1aXJlKCcuL21lZGl1bUVkaXRvckV4dGVuc2lvbnMnKTtcblxuXHR2YXIgY29udGVudGVkaXRvciA9IHtcbiAgICAgICAgXG4gICAgICAgIGxhYmVsQ29udGVudE1vZGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2RlQ29udGVudExhYmVsJyksXG4gICAgICAgIHJhZGlvQ29udGVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGVDb250ZW50JyksXG4gICAgICAgIGJ1dHRvblVwZGF0ZUNvbnRlbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cGRhdGVDb250ZW50SW5GcmFtZVN1Ym1pdCcpLFxuICAgICAgICBhY3RpdmVFbGVtZW50OiB7fSxcbiAgICAgICAgYWxsQ29udGVudEl0ZW1zT25DYW52YXM6IFtdLFxuICAgICAgICBtb2RhbEVkaXRDb250ZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdENvbnRlbnRNb2RhbCcpLFxuICAgICAgICBtZWRpdW1FZGl0b3JzOiBbXSxcbiAgICBcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5zdWJzY3JpYmUoJ29uQmxvY2tMb2FkZWQnLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ZWRpdG9yLmluamVjdE1lZGl1bUNTUyhibG9jayk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHVibGlzaGVyLnN1YnNjcmliZSgnb25CZWZvcmVTYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0b3IuZGVzdHJveUFsbEVkaXRvcnMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIuc3Vic2NyaWJlKCdvbkJlZm9yZVByZXZpZXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGVudGVkaXRvci5kZXN0cm95QWxsRWRpdG9ycygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5zdWJzY3JpYmUoJ29uQmVmb3JlQ2xvbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGVudGVkaXRvci5kZXN0cm95QWxsRWRpdG9ycygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5zdWJzY3JpYmUoJ29uQmVmb3JlRGVsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0b3IuZGVzdHJveUFsbEVkaXRvcnMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIuc3Vic2NyaWJlKCdvbkNsaWNrQ29udGVudCcsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0b3IuY29udGVudENsaWNrKGVsKTtcbiAgICAgICAgICAgIH0pO1xuXHRcdFx0XG5cdFx0XHQvL2xpc3RlbiBmb3IgdGhlIGJlZm9yZVNhdmUgZXZlbnQsIHJlbW92ZXMgb3V0bGluZXMgYmVmb3JlIHNhdmluZ1xuICAgICAgICAgICAgJCgnYm9keScpLm9uKCdiZWZvcmVTYXZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcblx0XHRcdFx0aWYoIE9iamVjdC5rZXlzKCBjb250ZW50ZWRpdG9yLmFjdGl2ZUVsZW1lbnQgKS5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIFx0Y29udGVudGVkaXRvci5hY3RpdmVFbGVtZW50LnJlbW92ZU91dGxpbmUoKTtcbiAgICAgICAgICAgIFx0fVxuXHRcdFx0XHRcblx0XHRcdH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgT3BlbnMgdXAgdGhlIGNvbnRlbnQgZWRpdG9yXG4gICAgICAgICovXG4gICAgICAgIGNvbnRlbnRDbGljazogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiB3ZSBoYXZlIGFuIGFjdGl2ZSBlbGVtZW50LCBtYWtlIGl0IHVuYWN0aXZlXG4gICAgICAgICAgICBpZiggT2JqZWN0LmtleXModGhpcy5hY3RpdmVFbGVtZW50KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUVsZW1lbnQuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kZXN0cm95IGFsbCBmaXJzdFxuICAgICAgICAgICAgY29udGVudGVkaXRvci5kZXN0cm95QWxsRWRpdG9ycygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NldCB0aGUgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gbmV3IGNhbnZhc0VsZW1lbnQoZWwpO1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5zZXRQYXJlbnRCbG9jaygpO1xuICAgICAgICAgICAgY29udGVudGVkaXRvci5hY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91bmJpbmQgaG92ZXIgYW5kIGNsaWNrIGV2ZW50cyBhbmQgbWFrZSB0aGlzIGl0ZW0gYWN0aXZlXG4gICAgICAgICAgICBjb250ZW50ZWRpdG9yLmFjdGl2ZUVsZW1lbnQuc2V0T3BlbigpO1xuXG4gICAgICAgICAgICBpZiggIWVsLmhhc0F0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci1pbmRleCcpICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRoZVdpbmRvdyA9IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICAgICAgdmFyIHRoZURvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gbmV3IE1lZGl1bUVkaXRvcihlbCwge1xuICAgICAgICAgICAgICAgICAgICBvd25lckRvY3VtZW50OiB0aGVEb2MsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRXaW5kb3c6IHRoZVdpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uTGFiZWxzOiAnZm9udGF3ZXNvbWUnLFxuICAgICAgICAgICAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBiQ29uZmlnLm1lZGl1bUJ1dHRvbnNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpZ2hsaWdodGVyJzogbmV3IG1lZGl1bUV4dGVuc2lvbnMuSGlnaGxpZ2h0ZXJCdXR0b24oKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBlZGl0b3Iuc3Vic2NyaWJlKCdibHVyJywgZnVuY3Rpb24gKGRhdGEsIGVkaXRhYmxlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIE9iamVjdC5rZXlzKCR0aGlzLmFjdGl2ZUVsZW1lbnQpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYWN0aXZlRWxlbWVudC5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9oZWlnaHQgYWRqdXN0bWVudCBvbiB0aGUgY29udGFpbmluZyBibG9ja1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hY3RpdmVFbGVtZW50LnBhcmVudEJsb2NrLmhlaWdodEFkanVzdG1lbnQoKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLnN1YnNjcmliZSgnZm9jdXMnLCBmdW5jdGlvbiAoZGF0YSwgZWRpdGFibGUpIHtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLnN1YnNjcmliZSgnZWRpdGFibGVJbnB1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZUJ1aWxkZXIuc2l0ZS5zZXRQZW5kaW5nQ2hhbmdlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVyLnB1Ymxpc2goJ29uQmxvY2tDaGFuZ2UnLCBjb250ZW50ZWRpdG9yLmFjdGl2ZUVsZW1lbnQucGFyZW50QmxvY2ssICdjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3RFbGVtZW50KGVsLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgY29udGVudGVkaXRvci5tZWRpdW1FZGl0b3JzLnB1c2goZWRpdG9yKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIERlc3Ryb3lzIGFsbCBhY3RpdmUgTWVkaXVtIGVkaXRvclxuICAgICAgICAqL1xuICAgICAgICBkZXN0cm95QWxsRWRpdG9yczogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBmb3IoIHZhciB4ID0gMDsgeCA8IGNvbnRlbnRlZGl0b3IubWVkaXVtRWRpdG9ycy5sZW5ndGg7IHgrKyApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ZWRpdG9yLm1lZGl1bUVkaXRvcnNbeF0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIGluamVjdHMgdGhlIE1lZGl1bSBFZGl0b3Igc3R5bGluZyBpbnRvIHRoZSBpZnJhbWUncyBoZWFkXG4gICAgICAgICovXG4gICAgICAgIGluamVjdE1lZGl1bUNTUzogZnVuY3Rpb24gKGJsb2NrKSB7XG5cbiAgICAgICAgICAgIGZvciggdmFyIHggPSAwOyB4IDwgYkNvbmZpZy5tZWRpdW1Dc3NVcmxzLmxlbmd0aDsgeCsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNzc0xpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMSU5LJyk7XG4gICAgICAgICAgICAgICAgY3NzTGluay5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICAgICAgY3NzTGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBiQ29uZmlnLm1lZGl1bUNzc1VybHNbeF0pO1xuICAgICAgICAgICAgICAgIGNzc0xpbmsuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgICAgICAgICAgY3NzTGluay5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3NjcmVlbicpO1xuICAgICAgICAgICAgICAgIGNzc0xpbmsuc2V0QXR0cmlidXRlKCdjaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgICAgICAgICAgICAgY3NzTGluay5zZXRBdHRyaWJ1dGUoJ2lkJywgJ21lZGl1bUNzcycgKyB4KTtcblxuICAgICAgICAgICAgICAgIGJsb2NrLmZyYW1lRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjc3NMaW5rKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICBjb250ZW50ZWRpdG9yLmluaXQoKTtcblxufSgpKTsiLCIoZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgYkNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnLmpzJyk7XG4gICAgdmFyIHB1Ymxpc2hlciA9IHJlcXVpcmUoJy4uL3ZlbmRvci9wdWJsaXNoZXInKTtcblxuXHR2YXIgYmV4cG9ydCA9IHtcbiAgICAgICAgXG4gICAgICAgIG1vZGFsRXhwb3J0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhwb3J0TW9kYWwnKSxcbiAgICAgICAgYnV0dG9uRXhwb3J0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhwb3J0UGFnZScpLFxuICAgICAgICBcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQodGhpcy5tb2RhbEV4cG9ydCkub24oJ3Nob3cuYnMubW9kYWwnLCB0aGlzLmRvRXhwb3J0TW9kYWwpO1xuICAgICAgICAgICAgJCh0aGlzLm1vZGFsRXhwb3J0KS5vbignc2hvd24uYnMubW9kYWwnLCB0aGlzLnByZXBFeHBvcnQpO1xuICAgICAgICAgICAgJCh0aGlzLm1vZGFsRXhwb3J0KS5maW5kKCdmb3JtJykub24oJ3N1Ym1pdCcsIHRoaXMuZXhwb3J0Rm9ybVN1Ym1pdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmV2ZWFsIGV4cG9ydCBidXR0b25cbiAgICAgICAgICAgICQodGhpcy5idXR0b25FeHBvcnQpLnNob3coKTtcbiAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkb0V4cG9ydE1vZGFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgJCgnI2V4cG9ydE1vZGFsID4gZm9ybSAjZXhwb3J0U3VibWl0Jykuc2hvdygnJyk7XG4gICAgICAgICAgICAkKCcjZXhwb3J0TW9kYWwgPiBmb3JtICNleHBvcnRDYW5jZWwnKS50ZXh0KCdDYW5jZWwgJiBDbG9zZScpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIHByZXBhcmVzIHRoZSBleHBvcnQgZGF0YVxuICAgICAgICAqL1xuICAgICAgICBwcmVwRXhwb3J0OiBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5wdWJsaXNoKCdjbG9zZVN0eWxlRWRpdG9yJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZGVsZXRlIG9sZGVyIGhpZGRlbiBmaWVsZHNcbiAgICAgICAgICAgICQoJyNleHBvcnRNb2RhbCBmb3JtIGlucHV0W3R5cGU9XCJoaWRkZW5cIl0ucGFnZXMnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggYWxsIHBhZ2VzXG4gICAgICAgICAgICAkKCcjcGFnZUxpc3QgPiB1bCcpLmVhY2goZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIHZhciB0aGVDb250ZW50cztcblx0XHRcdFx0XG4gICAgICAgICAgICAgICAgLy9ncmFiIHRoZSBza2VsZXRvbiBtYXJrdXBcbiAgICAgICAgICAgICAgICB2YXIgbmV3RG9jTWFpblBhcmVudCA9ICQoJ2lmcmFtZSNza2VsZXRvbicpLmNvbnRlbnRzKCkuZmluZCggYkNvbmZpZy5wYWdlQ29udGFpbmVyICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9lbXB0eSBvdXQgdGhlIHNrZWxldG9cbiAgICAgICAgICAgICAgICBuZXdEb2NNYWluUGFyZW50LmZpbmQoJyonKS5yZW1vdmUoKTtcblx0XHRcdFxuICAgICAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIHBhZ2UgaWZyYW1lcyBhbmQgZ3JhYiB0aGUgYm9keSBzdHVmZlxuICAgICAgICAgICAgICAgICQodGhpcykuZmluZCgnaWZyYW1lJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9ICQodGhpcykuYXR0cignZGF0YS1zYW5kYm94Jyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHIgIT09IHR5cGVvZiB1bmRlZmluZWQgJiYgYXR0ciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUNvbnRlbnRzID0gJCgnI3NhbmRib3hlcyAjJythdHRyKS5jb250ZW50cygpLmZpbmQoIGJDb25maWcucGFnZUNvbnRhaW5lciApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlQ29udGVudHMgPSAkKHRoaXMpLmNvbnRlbnRzKCkuZmluZCggYkNvbmZpZy5wYWdlQ29udGFpbmVyICkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhlQ29udGVudHMuZmluZCgnLmZyYW1lQ292ZXInKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHRcdFx0XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBpbmxpbmUgc3R5bGluZyBsZWZ0b3ZlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIga2V5IGluIGJDb25maWcuZWRpdGFibGVJdGVtcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlQ29udGVudHMuZmluZCgga2V5ICkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQXR0cignZGF0YS1zZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCAkKHRoaXMpLmF0dHIoJ3N0eWxlJykgPT09ICcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGJDb25maWcuZWRpdGFibGVDb250ZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUNvbnRlbnRzLmZpbmQoIGJDb25maWcuZWRpdGFibGVDb250ZW50W2ldICkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQXR0cignZGF0YS1zZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b0FkZCA9IHRoZUNvbnRlbnRzLmh0bWwoKTtcblx0XHRcdFx0XG4gICAgICAgICAgICAgICAgICAgIC8vZ3JhYiBzY3JpcHRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHRzID0gJCh0aGlzKS5jb250ZW50cygpLmZpbmQoIGJDb25maWcucGFnZUNvbnRhaW5lciApLmZpbmQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoIHNjcmlwdHMuc2l6ZSgpID4gMCApIHtcblx0XHRcdFx0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlSWZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJza2VsZXRvblwiKSwgc2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRzLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggJCh0aGlzKS50ZXh0KCkgIT09ICcnICkgey8vc2NyaXB0IHRhZ3Mgd2l0aCBjb250ZW50XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gdGhlSWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LmlubmVySFRNTCA9ICQodGhpcykudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVJZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCggYkNvbmZpZy5wYWdlQ29udGFpbmVyLnN1YnN0cmluZygxKSApLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCAkKHRoaXMpLmF0dHIoJ3NyYycpICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gdGhlSWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnNyYyA9ICQodGhpcykuYXR0cignc3JjJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZUlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBiQ29uZmlnLnBhZ2VDb250YWluZXIuc3Vic3RyaW5nKDEpICkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbmV3RG9jTWFpblBhcmVudC5hcHBlbmQoICQodG9BZGQpICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIG5ld0lucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwicGFnZXNbJyskKCcjcGFnZXMgbGk6ZXEoJysoJCh0aGlzKS5pbmRleCgpKzEpKycpIGE6Zmlyc3QnKS50ZXh0KCkrJ11cIiBjbGFzcz1cInBhZ2VzXCIgdmFsdWU9XCJcIj4nKTtcbiAgICAgICAgICAgICAgICAkKCcjZXhwb3J0TW9kYWwgZm9ybScpLnByZXBlbmQoIG5ld0lucHV0ICk7XG4gICAgICAgICAgICAgICAgbmV3SW5wdXQudmFsKCBcIjxodG1sPlwiKyQoJ2lmcmFtZSNza2VsZXRvbicpLmNvbnRlbnRzKCkuZmluZCgnaHRtbCcpLmh0bWwoKStcIjwvaHRtbD5cIiApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgICAgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGV4cG9ydCBmcm9tIHN1Ym1pdFxuICAgICAgICAqL1xuICAgICAgICBleHBvcnRGb3JtU3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgJCgnI2V4cG9ydE1vZGFsID4gZm9ybSAjZXhwb3J0U3VibWl0JykuaGlkZSgnJyk7XG4gICAgICAgICAgICAkKCcjZXhwb3J0TW9kYWwgPiBmb3JtICNleHBvcnRDYW5jZWwnKS50ZXh0KCdDbG9zZSBXaW5kb3cnKTtcbiAgICAgICAgXG4gICAgICAgIH1cbiAgICBcbiAgICB9O1xuICAgICAgICBcbiAgICBiZXhwb3J0LmluaXQoKTtcblxufSgpKTsiLCIoZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgTWVkaXVtRWRpdG9yID0gcmVxdWlyZSgnbWVkaXVtLWVkaXRvcicpO1xuXHR2YXIgcmFuZ3kgPSByZXF1aXJlKCdyYW5neScpO1xuICAgIHJlcXVpcmUoJ3Jhbmd5L2xpYi9yYW5neS1jbGFzc2FwcGxpZXInKTtcblxuICAgIHJhbmd5LmluaXQoKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLkhpZ2hsaWdodGVyQnV0dG9uID0gTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuYnV0dG9uLmV4dGVuZCh7XG5cbiAgICAgICAgbmFtZTogJ2hpZ2hsaWdodGVyJyxcbiAgICAgICAgdGFnTmFtZXM6IFsnbWFyayddLCAvLyBub2RlTmFtZSB3aGljaCBpbmRpY2F0ZXMgdGhlIGJ1dHRvbiBzaG91bGQgYmUgJ2FjdGl2ZScgd2hlbiBpc0FscmVhZHlBcHBsaWVkKCkgaXMgY2FsbGVkXG5cdFx0Y29udGVudERlZmF1bHQ6ICc8Yj5IPC9iPicsIC8vIGRlZmF1bHQgaW5uZXJIVE1MIG9mIHRoZSBidXR0b25cblx0XHRjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLXBhaW50LWJydXNoXCI+PC9pPicsIC8vIGlubmVySFRNTCBvZiBidXR0b24gd2hlbiAnZm9udGF3ZXNvbWUnIGlzIGJlaW5nIHVzZWRcblx0XHRhcmlhOiAnSGlnaHRsaWdodCcsIC8vIHVzZWQgYXMgYm90aCBhcmlhLWxhYmVsIGFuZCB0aXRsZSBhdHRyaWJ1dGVzXG5cdFx0YWN0aW9uOiAnaGlnaGxpZ2h0JywgLy8gdXNlZCBhcyB0aGUgZGF0YS1hY3Rpb24gYXR0cmlidXRlIG9mIHRoZSBidXR0b25cbiAgICAgICAgaWZyYW1lV2luOiB7fSxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgXHRNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuXHRcdCAgICB0aGlzLmNsYXNzQXBwbGllciA9IHJhbmd5LmNyZWF0ZUNsYXNzQXBwbGllcignaGlnaGxpZ2h0Jywge1xuXHRcdCAgICAgICAgZWxlbWVudFRhZ05hbWU6ICdtYXJrJyxcblx0XHQgICAgICAgIG5vcm1hbGl6ZTogdHJ1ZVxuXHRcdCAgICB9KTtcblxuXHRcdCAgICB0aGlzLmlmcmFtZVdpbiA9IHJhbmd5LmRvbS5nZXRJZnJhbWVXaW5kb3codGhpcy53aW5kb3cuZnJhbWVFbGVtZW50KTtcblxuXHRcdH0sXG5cblx0XHRoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG5cblx0XHQgICAgdGhpcy5jbGFzc0FwcGxpZXIudG9nZ2xlU2VsZWN0aW9uKHRoaXMuaWZyYW1lV2luKTtcblx0XHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXHRcdFxuICAgIH0pO1xuXG59KCkpOyIsIihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBiQ29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcuanMnKTtcblx0dmFyIHNpdGVCdWlsZGVyID0gcmVxdWlyZSgnLi9idWlsZGVyLmpzJyk7XG4gICAgdmFyIHB1Ymxpc2hlciA9IHJlcXVpcmUoJy4uL3ZlbmRvci9wdWJsaXNoZXInKTtcblxuXHR2YXIgcHJldmlldyA9IHtcblxuICAgICAgICBtb2RhbFByZXZpZXc6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmV2aWV3TW9kYWwnKSxcbiAgICAgICAgYnV0dG9uUHJldmlldzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvblByZXZpZXcnKSxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLy9ldmVudHNcbiAgICAgICAgICAgICQodGhpcy5tb2RhbFByZXZpZXcpLm9uKCdzaG93bi5icy5tb2RhbCcsIHRoaXMucHJlcFByZXZpZXcpO1xuICAgICAgICAgICAgJCh0aGlzLm1vZGFsUHJldmlldykub24oJ3Nob3cuYnMubW9kYWwnLCB0aGlzLnByZXBQcmV2aWV3TGluayk7XG5cbiAgICAgICAgICAgIC8vcmV2ZWFsIHByZXZpZXcgYnV0dG9uXG4gICAgICAgICAgICAkKHRoaXMuYnV0dG9uUHJldmlldykuc2hvdygpO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKlxuICAgICAgICAgICAgcHJlcGFyZXMgdGhlIHByZXZpZXcgZGF0YVxuICAgICAgICAqL1xuICAgICAgICBwcmVwUHJldmlldzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5wdWJsaXNoKCdvbkJlZm9yZVByZXZpZXcnKTtcblxuICAgICAgICAgICAgJCgnI3ByZXZpZXdNb2RhbCBmb3JtIGlucHV0W3R5cGU9XCJoaWRkZW5cIl0nKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy9idWlsZCB0aGUgcGFnZVxuICAgICAgICAgICAgc2l0ZUJ1aWxkZXIuc2l0ZS5hY3RpdmVQYWdlLmZ1bGxQYWdlKCk7XG5cbiAgICAgICAgICAgIHZhciBuZXdJbnB1dDtcblxuICAgICAgICAgICAgLy9tYXJrdXBcbiAgICAgICAgICAgIG5ld0lucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwicGFnZVwiIHZhbHVlPVwiXCI+Jyk7XG4gICAgICAgICAgICAkKCcjcHJldmlld01vZGFsIGZvcm0nKS5wcmVwZW5kKCBuZXdJbnB1dCApO1xuICAgICAgICAgICAgbmV3SW5wdXQudmFsKCBcIjxodG1sPlwiKyQoJ2lmcmFtZSNza2VsZXRvbicpLmNvbnRlbnRzKCkuZmluZCgnaHRtbCcpLmh0bWwoKStcIjwvaHRtbD5cIiApO1xuXG4gICAgICAgICAgICAvL3BhZ2UgdGl0bGVcbiAgICAgICAgICAgIG5ld0lucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwibWV0YV90aXRsZVwiIHZhbHVlPVwiXCI+Jyk7XG4gICAgICAgICAgICAkKCcjcHJldmlld01vZGFsIGZvcm0nKS5wcmVwZW5kKCBuZXdJbnB1dCApO1xuICAgICAgICAgICAgbmV3SW5wdXQudmFsKCBzaXRlQnVpbGRlci5zaXRlLmFjdGl2ZVBhZ2UucGFnZVNldHRpbmdzLnRpdGxlICk7XG4gICAgICAgICAgICAvL2FsZXJ0KEpTT04uc3RyaW5naWZ5KHNpdGVCdWlsZGVyLnNpdGUuYWN0aXZlUGFnZS5wYWdlU2V0dGluZ3MpKTtcblxuICAgICAgICAgICAgLy9wYWdlIG1ldGEgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIG5ld0lucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwibWV0YV9kZXNjcmlwdGlvblwiIHZhbHVlPVwiXCI+Jyk7XG4gICAgICAgICAgICAkKCcjcHJldmlld01vZGFsIGZvcm0nKS5wcmVwZW5kKCBuZXdJbnB1dCApO1xuICAgICAgICAgICAgbmV3SW5wdXQudmFsKCBzaXRlQnVpbGRlci5zaXRlLmFjdGl2ZVBhZ2UucGFnZVNldHRpbmdzLm1ldGFfZGVzY3JpcHRpb24gKTtcblxuICAgICAgICAgICAgLy9wYWdlIG1ldGEga2V5d29yZHNcbiAgICAgICAgICAgIG5ld0lucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwibWV0YV9rZXl3b3Jkc1wiIHZhbHVlPVwiXCI+Jyk7XG4gICAgICAgICAgICAkKCcjcHJldmlld01vZGFsIGZvcm0nKS5wcmVwZW5kKCBuZXdJbnB1dCApO1xuICAgICAgICAgICAgbmV3SW5wdXQudmFsKCBzaXRlQnVpbGRlci5zaXRlLmFjdGl2ZVBhZ2UucGFnZVNldHRpbmdzLm1ldGFfa2V5d29yZHMgKTtcblxuICAgICAgICAgICAgLy9wYWdlIGhlYWRlciBpbmNsdWRlc1xuICAgICAgICAgICAgbmV3SW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJoZWFkZXJfaW5jbHVkZXNcIiB2YWx1ZT1cIlwiPicpO1xuICAgICAgICAgICAgJCgnI3ByZXZpZXdNb2RhbCBmb3JtJykucHJlcGVuZCggbmV3SW5wdXQgKTtcbiAgICAgICAgICAgIG5ld0lucHV0LnZhbCggc2l0ZUJ1aWxkZXIuc2l0ZS5hY3RpdmVQYWdlLnBhZ2VTZXR0aW5ncy5oZWFkZXJfaW5jbHVkZXMgKTtcblxuICAgICAgICAgICAgLy9wYWdlIGNzc1xuICAgICAgICAgICAgbmV3SW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJwYWdlX2Nzc1wiIHZhbHVlPVwiXCI+Jyk7XG4gICAgICAgICAgICAkKCcjcHJldmlld01vZGFsIGZvcm0nKS5wcmVwZW5kKCBuZXdJbnB1dCApO1xuICAgICAgICAgICAgbmV3SW5wdXQudmFsKCBzaXRlQnVpbGRlci5zaXRlLmFjdGl2ZVBhZ2UucGFnZVNldHRpbmdzLnBhZ2VfY3NzICk7XG5cbiAgICAgICAgICAgIC8vc2l0ZSBJRFxuICAgICAgICAgICAgbmV3SW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJzaXRlSURcIiB2YWx1ZT1cIlwiPicpO1xuICAgICAgICAgICAgJCgnI3ByZXZpZXdNb2RhbCBmb3JtJykucHJlcGVuZCggbmV3SW5wdXQgKTtcbiAgICAgICAgICAgIG5ld0lucHV0LnZhbCggc2l0ZUJ1aWxkZXIuc2l0ZS5kYXRhLnNpdGVzX2lkICk7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBwcmVwYXJlcyB0aGUgYWN0dWFsIHByZXZpZXcgbGlua1xuICAgICAgICAqL1xuICAgICAgICBwcmVwUHJldmlld0xpbms6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAkKCcjcGFnZVByZXZpZXdMaW5rJykuYXR0ciggJ2hyZWYnLCAkKCcjcGFnZVByZXZpZXdMaW5rJykuYXR0cignZGF0YS1kZWZ1cmwnKSskKCcjcGFnZXMgbGkuYWN0aXZlIGEnKS50ZXh0KCkgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgcHJldmlldy5pbml0KCk7XG5cbn0oKSk7IiwiKGZ1bmN0aW9uICgpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgY2FudmFzRWxlbWVudCA9IHJlcXVpcmUoJy4vY2FudmFzRWxlbWVudC5qcycpLkVsZW1lbnQ7XG5cdHZhciBiQ29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcuanMnKTtcblx0dmFyIHNpdGVCdWlsZGVyID0gcmVxdWlyZSgnLi9idWlsZGVyLmpzJyk7XG4gICAgdmFyIHB1Ymxpc2hlciA9IHJlcXVpcmUoJy4uL3ZlbmRvci9wdWJsaXNoZXInKTtcblxuICAgIHZhciBzdHlsZWVkaXRvciA9IHtcblxuICAgICAgICByYWRpb1N0eWxlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZVN0eWxlJyksXG4gICAgICAgIGxhYmVsU3R5bGVNb2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZVN0eWxlTGFiZWwnKSxcbiAgICAgICAgYnV0dG9uU2F2ZUNoYW5nZXM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYXZlU3R5bGluZycpLFxuICAgICAgICBhY3RpdmVFbGVtZW50OiB7fSwgLy9ob2xkcyB0aGUgZWxlbWVudCBjdXJyZW50eSBiZWluZyBlZGl0ZWRcbiAgICAgICAgYWxsU3R5bGVJdGVtc09uQ2FudmFzOiBbXSxcbiAgICAgICAgX29sZEljb246IFtdLFxuICAgICAgICBzdHlsZUVkaXRvcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0eWxlRWRpdG9yJyksXG4gICAgICAgIGZvcm1TdHlsZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0eWxpbmdGb3JtJyksXG4gICAgICAgIGJ1dHRvblJlbW92ZUVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWxldGVFbGVtZW50Q29uZmlybScpLFxuICAgICAgICBidXR0b25DbG9uZUVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbG9uZUVsZW1lbnRCdXR0b24nKSxcbiAgICAgICAgYnV0dG9uUmVzZXRFbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXRTdHlsZUJ1dHRvbicpLFxuICAgICAgICBzZWxlY3RMaW5rc0luZXJuYWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRlcm5hbExpbmtzRHJvcGRvd24nKSxcbiAgICAgICAgc2VsZWN0TGlua3NQYWdlczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhZ2VMaW5rc0Ryb3Bkb3duJyksXG4gICAgICAgIHZpZGVvSW5wdXRZb3V0dWJlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgneW91dHViZUlEJyksXG4gICAgICAgIHZpZGVvSW5wdXRWaW1lbzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpbWVvSUQnKSxcbiAgICAgICAgaW5wdXRDdXN0b21MaW5rOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50ZXJuYWxMaW5rc0N1c3RvbScpLFxuICAgICAgICBsaW5rSW1hZ2U6IG51bGwsXG4gICAgICAgIGxpbmtJY29uOiBudWxsLFxuICAgICAgICBpbnB1dExpbmtUZXh0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGlua1RleHQnKSxcbiAgICAgICAgc2VsZWN0SWNvbnM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpY29ucycpLFxuICAgICAgICBidXR0b25EZXRhaWxzQXBwbGllZEhpZGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXRhaWxzQXBwbGllZE1lc3NhZ2VIaWRlJyksXG4gICAgICAgIGJ1dHRvbkNsb3NlU3R5bGVFZGl0b3I6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdHlsZUVkaXRvciA+IGEuY2xvc2UnKSxcbiAgICAgICAgdWxQYWdlTGlzdDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhZ2VMaXN0JyksXG4gICAgICAgIHJlc3BvbnNpdmVUb2dnbGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXNwb25zaXZlVG9nZ2xlJyksXG4gICAgICAgIHRoZVNjcmVlbjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcmVlbicpLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIuc3Vic2NyaWJlKCdjbG9zZVN0eWxlRWRpdG9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLmNsb3NlU3R5bGVFZGl0b3IoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIuc3Vic2NyaWJlKCdvbkJsb2NrTG9hZGVkJywgZnVuY3Rpb24gKGJsb2NrKSB7XG5cbiAgICAgICAgICAgICAgICBzdHlsZWVkaXRvci5zZXR1cENhbnZhc0VsZW1lbnRzKGJsb2NrKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5zdWJzY3JpYmUoJ29uU2V0TW9kZScsIGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVlZGl0b3IucmVzcG9uc2l2ZU1vZGVDaGFuZ2UobW9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHVibGlzaGVyLnN1YnNjcmliZSgnb25CZWZvcmVTYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLmNsb3NlU3R5bGVFZGl0b3IoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIuc3Vic2NyaWJlKCdvbkJlZm9yZVByZXZpZXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVlZGl0b3IuY2xvc2VTdHlsZUVkaXRvcigpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vZXZlbnRzXG4gICAgICAgICAgICAkKHRoaXMucmFkaW9TdHlsZSkub24oJ2NsaWNrJywgdGhpcy5hY3RpdmF0ZVN0eWxlTW9kZSk7XG4gICAgICAgICAgICAkKHRoaXMuYnV0dG9uU2F2ZUNoYW5nZXMpLm9uKCdjbGljaycsIHRoaXMudXBkYXRlU3R5bGluZyk7XG4gICAgICAgICAgICAkKHRoaXMuZm9ybVN0eWxlKS5vbignZm9jdXMnLCAnaW5wdXQnLCB0aGlzLmFuaW1hdGVTdHlsZUlucHV0SW4pLm9uKCdibHVyJywgJ2lucHV0JywgdGhpcy5hbmltYXRlU3R5bGVJbnB1dE91dCk7XG4gICAgICAgICAgICAkKHRoaXMuYnV0dG9uUmVtb3ZlRWxlbWVudCkub24oJ2NsaWNrJywgdGhpcy5kZWxldGVFbGVtZW50KTtcbiAgICAgICAgICAgICQodGhpcy5idXR0b25DbG9uZUVsZW1lbnQpLm9uKCdjbGljaycsIHRoaXMuY2xvbmVFbGVtZW50KTtcbiAgICAgICAgICAgICQodGhpcy5idXR0b25SZXNldEVsZW1lbnQpLm9uKCdjbGljaycsIHRoaXMucmVzZXRFbGVtZW50KTtcbiAgICAgICAgICAgICQodGhpcy52aWRlb0lucHV0WW91dHViZSkub24oJ2ZvY3VzJywgZnVuY3Rpb24oKXsgJChzdHlsZWVkaXRvci52aWRlb0lucHV0VmltZW8pLnZhbCgnJyk7IH0pO1xuICAgICAgICAgICAgJCh0aGlzLnZpZGVvSW5wdXRWaW1lbykub24oJ2ZvY3VzJywgZnVuY3Rpb24oKXsgJChzdHlsZWVkaXRvci52aWRlb0lucHV0WW91dHViZSkudmFsKCcnKTsgfSk7XG4gICAgICAgICAgICAkKHRoaXMuYnV0dG9uRGV0YWlsc0FwcGxpZWRIaWRlKS5vbignY2xpY2snLCBmdW5jdGlvbigpeyQodGhpcykucGFyZW50KCkuZmFkZU91dCg1MDApO30pO1xuICAgICAgICAgICAgJCh0aGlzLmJ1dHRvbkNsb3NlU3R5bGVFZGl0b3IpLm9uKCdjbGljaycsIHRoaXMuY2xvc2VTdHlsZUVkaXRvcik7XG4gICAgICAgICAgICAkKHRoaXMuaW5wdXRDdXN0b21MaW5rKS5vbignZm9jdXMnLCB0aGlzLmlucHV0Q3VzdG9tTGlua0ZvY3VzKS5vbignYmx1cicsIHRoaXMuaW5wdXRDdXN0b21MaW5rQmx1cik7XG5cbiAgICAgICAgICAgIC8vY2hvc2VuIGZvbnQtYXdlc29tZSBkcm9wZG93blxuICAgICAgICAgICAgJCh0aGlzLnNlbGVjdEljb25zKS5jaG9zZW4oeydzZWFyY2hfY29udGFpbnMnOiB0cnVlfSk7XG5cbiAgICAgICAgICAgIC8vY2hlY2sgaWYgZm9ybURhdGEgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5Gb3JtRGF0YSl7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlRmlsZVVwbG9hZHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zaG93IHRoZSBzdHlsZSBtb2RlIHJhZGlvIGJ1dHRvblxuICAgICAgICAgICAgJCh0aGlzLmxhYmVsU3R5bGVNb2RlKS5zaG93KCk7XG5cbiAgICAgICAgICAgIC8vbGlzdGVuIGZvciB0aGUgYmVmb3JlU2F2ZSBldmVudFxuICAgICAgICAgICAgJCgnYm9keScpLm9uKCdiZWZvcmVTYXZlJywgdGhpcy5jbG9zZVN0eWxlRWRpdG9yKTtcblxuICAgICAgICAgICAgLy9yZXNwb25zaXZlIHRvZ2dsZVxuICAgICAgICAgICAgJCh0aGlzLnJlc3BvbnNpdmVUb2dnbGUpLm9uKCdjbGljaycsICdhJywgdGhpcy50b2dnbGVSZXNwb25zaXZlQ2xpY2spO1xuXG4gICAgICAgICAgICAvL3NldCB0aGUgZGVmYXVsdCByZXNwb25zaXZlIG1vZGVcbiAgICAgICAgICAgIHNpdGVCdWlsZGVyLmJ1aWxkZXJVSS5jdXJyZW50UmVzcG9uc2l2ZU1vZGUgPSBPYmplY3Qua2V5cyhiQ29uZmlnLnJlc3BvbnNpdmVNb2RlcylbMF07XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgICAgRXZlbnQgaGFuZGxlciBmb3IgcmVzcG9uc2l2ZSBtb2RlIGxpbmtzXG4gICAgICAgICovXG4gICAgICAgIHRvZ2dsZVJlc3BvbnNpdmVDbGljazogZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdHlsZWVkaXRvci5yZXNwb25zaXZlTW9kZUNoYW5nZSh0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1yZXNwb25zaXZlJykpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFRvZ2dsZXMgdGhlIHJlc3BvbnNpdmUgbW9kZVxuICAgICAgICAqL1xuICAgICAgICByZXNwb25zaXZlTW9kZUNoYW5nZTogZnVuY3Rpb24gKG1vZGUpIHtcblxuICAgICAgICAgICAgdmFyIGxpbmtzLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIC8vVUkgc3R1ZmZcbiAgICAgICAgICAgIGxpbmtzID0gc3R5bGVlZGl0b3IucmVzcG9uc2l2ZVRvZ2dsZS5xdWVyeVNlbGVjdG9yQWxsKCdsaScpO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrICkgbGlua3NbaV0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2FbZGF0YS1yZXNwb25zaXZlPVwiJyArIG1vZGUgKyAnXCJdJykucGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblxuXG4gICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIGJDb25maWcucmVzcG9uc2l2ZU1vZGVzICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBiQ29uZmlnLnJlc3BvbnNpdmVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShrZXkpICkgdGhpcy50aGVTY3JlZW4uY2xhc3NMaXN0LnJlbW92ZShrZXkpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYkNvbmZpZy5yZXNwb25zaXZlTW9kZXNbbW9kZV0gKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRoZVNjcmVlbi5jbGFzc0xpc3QuYWRkKG1vZGUpO1xuICAgICAgICAgICAgICAgICQodGhpcy50aGVTY3JlZW4pLmFuaW1hdGUoe3dpZHRoOiBiQ29uZmlnLnJlc3BvbnNpdmVNb2Rlc1ttb2RlXX0sIDY1MCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvL2hlaWdodCBhZGp1c3RtZW50XG4gICAgICAgICAgICAgICAgICAgIHNpdGVCdWlsZGVyLnNpdGUuYWN0aXZlUGFnZS5oZWlnaHRBZGp1c3RtZW50KCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2l0ZUJ1aWxkZXIuYnVpbGRlclVJLmN1cnJlbnRSZXNwb25zaXZlTW9kZSA9IG1vZGU7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBBY3RpdmF0ZXMgc3R5bGUgZWRpdG9yIG1vZGVcbiAgICAgICAgKi9cbiAgICAgICAgc2V0dXBDYW52YXNFbGVtZW50czogZnVuY3Rpb24oYmxvY2spIHtcblxuICAgICAgICAgICAgaWYgKCBibG9jayA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgLy9jcmVhdGUgYW4gb2JqZWN0IGZvciBldmVyeSBlZGl0YWJsZSBlbGVtZW50IG9uIHRoZSBjYW52YXMgYW5kIHNldHVwIGl0J3MgZXZlbnRzXG5cbiAgICAgICAgICAgIGZvciggdmFyIGtleSBpbiBiQ29uZmlnLmVkaXRhYmxlSXRlbXMgKSB7XG5cbiAgICAgICAgICAgICAgICAkKGJsb2NrLmZyYW1lKS5jb250ZW50cygpLmZpbmQoIGJDb25maWcucGFnZUNvbnRhaW5lciArICcgJysga2V5ICkuZWFjaChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVlZGl0b3Iuc2V0dXBDYW52YXNFbGVtZW50c09uRWxlbWVudCh0aGlzLCBrZXkpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFNldHMgdXAgY2FudmFzIGVsZW1lbnRzIG9uIGVsZW1lbnRcbiAgICAgICAgKi9cbiAgICAgICAgc2V0dXBDYW52YXNFbGVtZW50c09uRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuXG4gICAgICAgICAgICAvL0VsZW1lbnQgb2JqZWN0IGV4dGVudGlvblxuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5wcm90b3R5cGUuY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVlZGl0b3Iuc3R5bGVDbGljayh0aGlzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBuZXdFbGVtZW50ID0gbmV3IGNhbnZhc0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIG5ld0VsZW1lbnQuZWRpdGFibGVBdHRyaWJ1dGVzID0gYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW2tleV07XG4gICAgICAgICAgICBuZXdFbGVtZW50LnNldFBhcmVudEJsb2NrKCk7XG4gICAgICAgICAgICBuZXdFbGVtZW50LmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgIHN0eWxlZWRpdG9yLmFsbFN0eWxlSXRlbXNPbkNhbnZhcy5wdXNoKCBuZXdFbGVtZW50ICk7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSAhPT0gdW5kZWZpbmVkICkgJChlbGVtZW50KS5hdHRyKCdkYXRhLXNlbGVjdG9yJywga2V5KTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIEV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIHN0eWxlIGVkaXRvciBpcyBlbnZva2VkIG9uIGFuIGl0ZW1cbiAgICAgICAgKi9cbiAgICAgICAgc3R5bGVDbGljazogZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgICAgICAgICAvL2lmIHdlIGhhdmUgYW4gYWN0aXZlIGVsZW1lbnQsIG1ha2UgaXQgdW5hY3RpdmVcbiAgICAgICAgICAgIGlmKCBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZUVsZW1lbnQpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRWxlbWVudC5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NldCB0aGUgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vdW5iaW5kIGhvdmVyIGFuZCBjbGljayBldmVudHMgYW5kIG1ha2UgdGhpcyBpdGVtIGFjdGl2ZVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50LnNldE9wZW4oKTtcblxuICAgICAgICAgICAgdmFyIHRoZVNlbGVjdG9yID0gJCh0aGlzLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuYXR0cignZGF0YS1zZWxlY3RvcicpO1xuXG4gICAgICAgICAgICAkKCcjZWRpdGluZ0VsZW1lbnQnKS50ZXh0KCB0aGVTZWxlY3RvciApO1xuXG4gICAgICAgICAgICAvL2FjdGl2YXRlIGZpcnN0IHRhYlxuICAgICAgICAgICAgJCgnI2RldGFpbFRhYnMgYTpmaXJzdCcpLmNsaWNrKCk7XG5cbiAgICAgICAgICAgIC8vaGlkZSBhbGwgYnkgZGVmYXVsdFxuICAgICAgICAgICAgJCgndWwjZGV0YWlsVGFicyBsaTpndCgwKScpLmhpZGUoKTtcblxuICAgICAgICAgICAgLy9jb250ZW50IGVkaXRvcj9cbiAgICAgICAgICAgIGZvciggdmFyIGl0ZW0gaW4gYkNvbmZpZy5lZGl0YWJsZUl0ZW1zICkge1xuXG4gICAgICAgICAgICAgICAgaWYoIGJDb25maWcuZWRpdGFibGVJdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtKSAmJiBpdGVtID09PSB0aGVTZWxlY3RvciApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGJDb25maWcuZWRpdGFibGVJdGVtc1tpdGVtXS5pbmRleE9mKCdjb250ZW50JykgIT09IC0xICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2VkaXQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVyLnB1Ymxpc2goJ29uQ2xpY2tDb250ZW50JywgZWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy93aGF0IGFyZSB3ZSBkZWFsaW5nIHdpdGg/XG4gICAgICAgICAgICBpZiggJCh0aGlzLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucHJvcCgndGFnTmFtZScpID09PSAnQScgfHwgJCh0aGlzLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucGFyZW50KCkucHJvcCgndGFnTmFtZScpID09PSAnQScgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRMaW5rKHRoaXMuYWN0aXZlRWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgfVxuXG5cdFx0XHRpZiggJCh0aGlzLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucHJvcCgndGFnTmFtZScpID09PSAnSU1HJyApe1xuXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0SW1hZ2UodGhpcy5hY3RpdmVFbGVtZW50LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICB9XG5cblx0XHRcdGlmKCAkKHRoaXMuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5hdHRyKCdkYXRhLXR5cGUnKSA9PT0gJ3ZpZGVvJyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdFZpZGVvKHRoaXMuYWN0aXZlRWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgfVxuXG5cdFx0XHRpZiggJCh0aGlzLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuaGFzQ2xhc3MoJ2ZhJykgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRJY29uKHRoaXMuYWN0aXZlRWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2xvYWQgdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlU3R5bGVFbGVtZW50cyh0aGVTZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIC8vb3BlbiBzaWRlIHBhbmVsXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNpZGVQYW5lbCgnb3BlbicpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBkeW5hbWljYWxseSBnZW5lcmF0ZXMgdGhlIGZvcm0gZmllbGRzIGZvciBlZGl0aW5nIGFuIGVsZW1lbnRzIHN0eWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgKi9cbiAgICAgICAgYnVpbGRlU3R5bGVFbGVtZW50czogZnVuY3Rpb24odGhlU2VsZWN0b3IpIHtcblxuICAgICAgICAgICAgLy9kZWxldGUgdGhlIG9sZCBvbmVzIGZpcnN0XG4gICAgICAgICAgICAkKCcjc3R5bGVFbGVtZW50cyA+ICo6bm90KCNzdHlsZUVsVGVtcGxhdGUpJykuZWFjaChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICggYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXS5sZW5ndGggPT09IDEgJiYgYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXVswXSA9PT0gJ2NvbnRlbnQnICkge1xuICAgICAgICAgICAgICAgIC8vdGV4dCBlbGVtZW50IG9ubHksIG5vIHN0eWxpbmcgYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbFRhYnMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLmJ1dHRvblNhdmVDaGFuZ2VzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlsVGFicycpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLmJ1dHRvblNhdmVDaGFuZ2VzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciggdmFyIHggPSAwOyB4IDwgYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXS5sZW5ndGg7IHgrKyApIHtcblxuICAgICAgICAgICAgICAgIC8vY3JlYXRlIHN0eWxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgdmFyIG5ld1N0eWxlRWwgPSAkKCcjc3R5bGVFbFRlbXBsYXRlJykuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZUVsLmF0dHIoJ2lkJywgJycpO1xuICAgICAgICAgICAgICAgIG5ld1N0eWxlRWwuZmluZCgnLmNvbnRyb2wtbGFiZWwnKS50ZXh0KCBiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdK1wiOlwiICk7XG5cbiAgICAgICAgICAgICAgICBpZiggdGhlU2VsZWN0b3IgKyBcIiA6IFwiICsgYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXVt4XSBpbiBiQ29uZmlnLmVkaXRhYmxlSXRlbU9wdGlvbnMpIHsvL3dlJ3ZlIGdvdCBhIGRyb3Bkb3duIGluc3RlYWQgb2Ygb3BlbiB0ZXh0IGlucHV0XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGVFbC5maW5kKCdpbnB1dCcpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdEcm9wRG93biA9ICQoJzxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2wgc2VsZWN0IHNlbGVjdC1wcmltYXJ5IGJ0bi1ibG9jayBzZWxlY3Qtc21cIj48L3NlbGVjdD4nKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHJvcERvd24uYXR0cignbmFtZScsIGJDb25maWcuZWRpdGFibGVJdGVtc1t0aGVTZWxlY3Rvcl1beF0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgej0wOyB6PGJDb25maWcuZWRpdGFibGVJdGVtT3B0aW9uc1sgdGhlU2VsZWN0b3IrXCIgOiBcIitiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdIF0ubGVuZ3RoOyB6KysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdPcHRpb24gPSAkKCc8b3B0aW9uIHZhbHVlPVwiJytiQ29uZmlnLmVkaXRhYmxlSXRlbU9wdGlvbnNbdGhlU2VsZWN0b3IrXCIgOiBcIitiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdXVt6XSsnXCI+JytiQ29uZmlnLmVkaXRhYmxlSXRlbU9wdGlvbnNbdGhlU2VsZWN0b3IrXCIgOiBcIitiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdXVt6XSsnPC9vcHRpb24+Jyk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGJDb25maWcuZWRpdGFibGVJdGVtT3B0aW9uc1t0aGVTZWxlY3RvcitcIiA6IFwiK2JDb25maWcuZWRpdGFibGVJdGVtc1t0aGVTZWxlY3Rvcl1beF1dW3pdID09PSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuY3NzKCBiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jdXJyZW50IHZhbHVlLCBtYXJrZWQgYXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb24uYXR0cignc2VsZWN0ZWQnLCAndHJ1ZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Ryb3BEb3duLmFwcGVuZCggbmV3T3B0aW9uICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlRWwuYXBwZW5kKCBuZXdEcm9wRG93biApO1xuICAgICAgICAgICAgICAgICAgICBuZXdEcm9wRG93bi5zZWxlY3QyKCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXVt4XSA9PT0gJ2NvbnRlbnQnICkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGVFbC5maW5kKCdpbnB1dCcpLmF0dHIoJ25hbWUnLCBiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiggYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXVt4XSA9PT0gJ2JhY2tncm91bmQtaW1hZ2UnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZUVsLmZpbmQoJ2lucHV0JykuYmluZCgnZm9jdXMnLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZUlucHV0ID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNpbWFnZU1vZGFsJykubW9kYWwoJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjaW1hZ2VNb2RhbCAuaW1hZ2UgYnV0dG9uLnVzZUltYWdlJykudW5iaW5kKCdjbGljaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNpbWFnZU1vZGFsJykub24oJ2NsaWNrJywgJy5pbWFnZSBidXR0b24udXNlSW1hZ2UnLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCAgJ3VybChcIicrJCh0aGlzKS5hdHRyKCdkYXRhLXVybCcpKydcIiknKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSBsaXZlIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZUlucHV0LnZhbCggJ3VybChcIicrJCh0aGlzKS5hdHRyKCdkYXRhLXVybCcpKydcIiknICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9oaWRlIG1vZGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNpbWFnZU1vZGFsJykubW9kYWwoJ2hpZGUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlJ3ZlIGdvdCBwZW5kaW5nIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZUJ1aWxkZXIuc2l0ZS5zZXRQZW5kaW5nQ2hhbmdlcyh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIGJDb25maWcuZWRpdGFibGVJdGVtc1t0aGVTZWxlY3Rvcl1beF0uaW5kZXhPZihcImNvbG9yXCIpID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuY3NzKCBiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdICkgIT09ICd0cmFuc3BhcmVudCcgJiYgJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmNzcyggYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXVt4XSApICE9PSAnbm9uZScgJiYgJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmNzcyggYkNvbmZpZy5lZGl0YWJsZUl0ZW1zW3RoZVNlbGVjdG9yXVt4XSApICE9PSAnJyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZG8gd2UgaGF2ZSBhIGRhdGEgYXR0cmlidXRlIHZhbHVlIGZvciB0aGlzIHN0eWxlIGF0dHJpYnV0ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5kYXRhKCBiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGVFbC5maW5kKCdpbnB1dCcpLnZhbCggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmRhdGEoIGJDb25maWcuZWRpdGFibGVJdGVtc1t0aGVTZWxlY3Rvcl1beF0gKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZUVsLmZpbmQoJ2lucHV0JykudmFsKCAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuY3NzKCBiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZUVsLmZpbmQoJ2lucHV0Jykuc3BlY3RydW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZEZvcm1hdDogXCJoZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93UGFsZXR0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0VtcHR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dJbnB1dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWxldHRlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiMwMDBcIixcIiM0NDRcIixcIiM2NjZcIixcIiM5OTlcIixcIiNjY2NcIixcIiNlZWVcIixcIiNmM2YzZjNcIixcIiNmZmZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiNmMDBcIixcIiNmOTBcIixcIiNmZjBcIixcIiMwZjBcIixcIiMwZmZcIixcIiMwMGZcIixcIiM5MGZcIixcIiNmMGZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiNmNGNjY2NcIixcIiNmY2U1Y2RcIixcIiNmZmYyY2NcIixcIiNkOWVhZDNcIixcIiNkMGUwZTNcIixcIiNjZmUyZjNcIixcIiNkOWQyZTlcIixcIiNlYWQxZGNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiNlYTk5OTlcIixcIiNmOWNiOWNcIixcIiNmZmU1OTlcIixcIiNiNmQ3YThcIixcIiNhMmM0YzlcIixcIiM5ZmM1ZThcIixcIiNiNGE3ZDZcIixcIiNkNWE2YmRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiNlMDY2NjZcIixcIiNmNmIyNmJcIixcIiNmZmQ5NjZcIixcIiM5M2M0N2RcIixcIiM3NmE1YWZcIixcIiM2ZmE4ZGNcIixcIiM4ZTdjYzNcIixcIiNjMjdiYTBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiNjMDBcIixcIiNlNjkxMzhcIixcIiNmMWMyMzJcIixcIiM2YWE4NGZcIixcIiM0NTgxOGVcIixcIiMzZDg1YzZcIixcIiM2NzRlYTdcIixcIiNhNjRkNzlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiM5MDBcIixcIiNiNDVmMDZcIixcIiNiZjkwMDBcIixcIiMzODc2MWRcIixcIiMxMzRmNWNcIixcIiMwYjUzOTRcIixcIiMzNTFjNzVcIixcIiM3NDFiNDdcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiM2MDBcIixcIiM3ODNmMDRcIixcIiM3ZjYwMDBcIixcIiMyNzRlMTNcIixcIiMwYzM0M2RcIixcIiMwNzM3NjNcIixcIiMyMDEyNGRcIixcIiM0YzExMzBcIl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZUVsLmZpbmQoJ2lucHV0JykudmFsKCAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuY3NzKCBiQ29uZmlnLmVkaXRhYmxlSXRlbXNbdGhlU2VsZWN0b3JdW3hdICkgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdTdHlsZUVsLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgICAgICAgICAgICAgJCgnI3N0eWxlRWxlbWVudHMnKS5hcHBlbmQoIG5ld1N0eWxlRWwgKTtcblxuICAgICAgICAgICAgICAgICQoJyNzdHlsZUVkaXRvciBmb3JtI3N0eWxpbmdGb3JtJykuaGVpZ2h0KCdhdXRvJyk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIEFwcGxpZXMgdXBkYXRlZCBzdHlsaW5nIHRvIHRoZSBjYW52YXNcbiAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlU3R5bGluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50SUQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgICAgICAkKCcjc3R5bGVFZGl0b3IgI3RhYjEgLmZvcm0tZ3JvdXA6bm90KCNzdHlsZUVsVGVtcGxhdGUpIGlucHV0LCAjc3R5bGVFZGl0b3IgI3RhYjEgLmZvcm0tZ3JvdXA6bm90KCNzdHlsZUVsVGVtcGxhdGUpIHNlbGVjdCcpLmVhY2goZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRpZiggJCh0aGlzKS5hdHRyKCduYW1lJykgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIFx0JChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmNzcyggJCh0aGlzKS5hdHRyKCduYW1lJyksICAkKHRoaXMpLnZhbCgpKTtcblxuXHRcdFx0XHR9XG5cbiAgICAgICAgICAgICAgICAvKiBTQU5EQk9YICovXG5cbiAgICAgICAgICAgICAgICBpZiggc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5zYW5kYm94ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJRCA9ICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5hdHRyKCdpZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoJyMnK3N0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuc2FuZGJveCkuY29udGVudHMoKS5maW5kKCcjJytlbGVtZW50SUQpLmNzcyggJCh0aGlzKS5hdHRyKCduYW1lJyksICAkKHRoaXMpLnZhbCgpICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBFTkQgU0FOREJPWCAqL1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9saW5rc1xuICAgICAgICAgICAgaWYoICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5wcm9wKCd0YWdOYW1lJykgPT09ICdBJyApIHtcblxuICAgICAgICAgICAgICAgIC8vY2hhbmdlIHRoZSBocmVmIHByb3A/XG4gICAgICAgICAgICAgICAgc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50LmhyZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50ZXJuYWxMaW5rc0N1c3RvbScpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vZG9lcyB0aGUgbGluayBjb250YWluIGFuIGltYWdlP1xuICAgICAgICAgICAgICAgIGlmKCBzdHlsZWVkaXRvci5saW5rSW1hZ2UgKSBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQuY2hpbGROb2Rlc1tsZW5ndGgtMV0ubm9kZVZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbmtUZXh0JykudmFsdWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIHN0eWxlZWRpdG9yLmxpbmtJY29uICkgc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50LmNoaWxkTm9kZXNbbGVuZ3RoLTFdLm5vZGVWYWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5rVGV4dCcpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGVsc2Ugc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50LmlubmVyVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5rVGV4dCcpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLyogU0FOREJPWCAqL1xuXG4gICAgICAgICAgICAgICAgaWYoIHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuc2FuZGJveCApIHtcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50SUQgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuYXR0cignaWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAkKCcjJytzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3gpLmNvbnRlbnRzKCkuZmluZCgnIycrZWxlbWVudElEKS5hdHRyKCdocmVmJywgJCgnaW5wdXQjaW50ZXJuYWxMaW5rc0N1c3RvbScpLnZhbCgpKTtcblxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogRU5EIFNBTkRCT1ggKi9cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnBhcmVudCgpLnByb3AoJ3RhZ05hbWUnKSA9PT0gJ0EnICYmICFzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYScpICkge1xuXG4gICAgICAgICAgICAgICAgLy9jaGFuZ2UgdGhlIGhyZWYgcHJvcD9cbiAgICAgICAgICAgICAgICBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQucGFyZW50Tm9kZS5ocmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ludGVybmFsTGlua3NDdXN0b20nKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIC8qIFNBTkRCT1ggKi9cblxuICAgICAgICAgICAgICAgIGlmKCBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3ggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudElEID0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgnIycrc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5zYW5kYm94KS5jb250ZW50cygpLmZpbmQoJyMnK2VsZW1lbnRJRCkucGFyZW50KCkuYXR0cignaHJlZicsICQoJ2lucHV0I2ludGVybmFsTGlua3NDdXN0b20nKS52YWwoKSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBFTkQgU0FOREJPWCAqL1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZG8gd2UgbmVlZCB0byB1cGxvYWQgYW4gaW1hZ2U/XG4gICAgICAgICAgICBpZiggJCgnYSNpbWdfTGluaycpLmNzcygnZGlzcGxheScpID09PSAnYmxvY2snICYmICQoJ2lucHV0I2ltYWdlRmlsZUZpZWxkJykudmFsKCkgIT09ICcnICkge1xuICAgICAgICAgICAgLy9pZiggJCgnYSNpbWdfTGluaycpLmNzcygnZGlzcGxheScpID09PSAnYmxvY2snICkge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZm9ybSA9ICQoJ2Zvcm0jaW1hZ2VVcGxvYWRGb3JtJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1kYXRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5Gb3JtRGF0YSl7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1kYXRhID0gbmV3IEZvcm1EYXRhKGZvcm1bMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZm9ybUFjdGlvbiA9IGZvcm0uYXR0cignYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsIDogZm9ybUFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA6IGZvcm1kYXRhID8gZm9ybWRhdGEgOiBmb3JtLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRGF0YSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgfSkuZG9uZShmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiggcmVzcG9uc2UuY29kZSA9PT0gMSApIHsvL3N1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCdpbnB1dCNpbWFnZVVSTCcpLnZhbCggcmVzcG9uc2UucmVzcG9uc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuYXR0cignc3JjJywgcmVzcG9uc2UucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IHRoZSBmaWxlIHVwbG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmltYWdlRmlsZVRhYicpLmZpbmQoJ2EuZmlsZWlucHV0LWV4aXN0cycpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNBTkRCT1ggKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5zYW5kYm94ICkge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudElEID0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjJytzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3gpLmNvbnRlbnRzKCkuZmluZCgnIycrZWxlbWVudElEKS5hdHRyKCdzcmMnLCByZXNwb25zZS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogRU5EIFNBTkRCT1ggKi9cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggcmVzcG9uc2UuY29kZSA9PT0gMCApIHsvL2Vycm9yXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ1NvbWV0aGluZyB3ZW50IHdyb25nOiAnK3Jlc3BvbnNlLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmKCAkKCdhI2ltZ19MaW5rJykuY3NzKCdkaXNwbGF5JykgPT09ICdibG9jaycgKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL25vIGltYWdlIHRvIHVwbG9hZCwganVzdCBhIFNSQyBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiggJCgnaW5wdXQjaW1hZ2VVUkwnKS52YWwoKSAhPT0gJycgJiYgJCgnaW5wdXQjaW1hZ2VVUkwnKS52YWwoKSAhPT0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ3NyYycpICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuYXR0cignc3JjJywgJCgnaW5wdXQjaW1hZ2VVUkwnKS52YWwoKSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvKiBTQU5EQk9YICovXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoIHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuc2FuZGJveCApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJRCA9ICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5hdHRyKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyMnK3N0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuc2FuZGJveCkuY29udGVudHMoKS5maW5kKCcjJytlbGVtZW50SUQpLmF0dHIoJ3NyYycsICQoJ2lucHV0I2ltYWdlVVJMJykudmFsKCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLyogRU5EIFNBTkRCT1ggKi9cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pY29uc1xuICAgICAgICAgICAgaWYoICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5oYXNDbGFzcygnZmEnKSApIHtcblxuICAgICAgICAgICAgICAgIC8vb3V0IHdpdGggdGhlIG9sZCwgaW4gd2l0aCB0aGUgbmV3IDopXG4gICAgICAgICAgICAgICAgLy9nZXQgaWNvbiBjbGFzcyBuYW1lLCBzdGFydGluZyB3aXRoIGZhLVxuICAgICAgICAgICAgICAgIHZhciBnZXQgPSAkLmdyZXAoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKHYsIGkpe1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmluZGV4T2YoJ2ZhLScpID09PSAwO1xuXG4gICAgICAgICAgICAgICAgfSkuam9pbigpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgaWNvbnMgaXMgYmVpbmcgY2hhbmdlZCwgc2F2ZSB0aGUgb2xkIG9uZSBzbyB3ZSBjYW4gcmVzZXQgaXQgaWYgbmVlZGVkXG5cbiAgICAgICAgICAgICAgICBpZiggZ2V0ICE9PSAkKCdzZWxlY3QjaWNvbnMnKS52YWwoKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkudW5pcXVlSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVlZGl0b3IuX29sZEljb25bJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ2lkJyldID0gZ2V0O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnJlbW92ZUNsYXNzKCBnZXQgKS5hZGRDbGFzcyggJCgnc2VsZWN0I2ljb25zJykudmFsKCkgKTtcblxuXG4gICAgICAgICAgICAgICAgLyogU0FOREJPWCAqL1xuXG4gICAgICAgICAgICAgICAgaWYoIHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuc2FuZGJveCApIHtcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50SUQgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuYXR0cignaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnIycrc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5zYW5kYm94KS5jb250ZW50cygpLmZpbmQoJyMnK2VsZW1lbnRJRCkucmVtb3ZlQ2xhc3MoIGdldCApLmFkZENsYXNzKCAkKCdzZWxlY3QjaWNvbnMnKS52YWwoKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogRU5EIFNBTkRCT1ggKi9cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3ZpZGVvIFVSTFxuICAgICAgICAgICAgaWYoICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5hdHRyKCdkYXRhLXR5cGUnKSA9PT0gJ3ZpZGVvJyApIHtcblxuICAgICAgICAgICAgICAgIGlmKCAkKCdpbnB1dCN5b3V0dWJlSUQnKS52YWwoKSAhPT0gJycgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnByZXYoKS5hdHRyKCdzcmMnLCBcIi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL1wiKyQoJyN2aWRlb19UYWIgaW5wdXQjeW91dHViZUlEJykudmFsKCkpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCAkKCdpbnB1dCN2aW1lb0lEJykudmFsKCkgIT09ICcnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5wcmV2KCkuYXR0cignc3JjJywgXCIvL3BsYXllci52aW1lby5jb20vdmlkZW8vXCIrJCgnI3ZpZGVvX1RhYiBpbnB1dCN2aW1lb0lEJykudmFsKCkrXCI/dGl0bGU9MCZhbXA7YnlsaW5lPTAmYW1wO3BvcnRyYWl0PTBcIik7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBTQU5EQk9YICovXG5cbiAgICAgICAgICAgICAgICBpZiggc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5zYW5kYm94ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJRCA9ICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5hdHRyKCdpZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCAkKCdpbnB1dCN5b3V0dWJlSUQnKS52YWwoKSAhPT0gJycgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyMnK3N0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuc2FuZGJveCkuY29udGVudHMoKS5maW5kKCcjJytlbGVtZW50SUQpLnByZXYoKS5hdHRyKCdzcmMnLCBcIi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL1wiKyQoJyN2aWRlb19UYWIgaW5wdXQjeW91dHViZUlEJykudmFsKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggJCgnaW5wdXQjdmltZW9JRCcpLnZhbCgpICE9PSAnJyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnIycrc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5zYW5kYm94KS5jb250ZW50cygpLmZpbmQoJyMnK2VsZW1lbnRJRCkucHJldigpLmF0dHIoJ3NyYycsIFwiLy9wbGF5ZXIudmltZW8uY29tL3ZpZGVvL1wiKyQoJyN2aWRlb19UYWIgaW5wdXQjdmltZW9JRCcpLnZhbCgpK1wiP3RpdGxlPTAmYW1wO2J5bGluZT0wJmFtcDtwb3J0cmFpdD0wXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIEVORCBTQU5EQk9YICovXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCgnI2RldGFpbHNBcHBsaWVkTWVzc2FnZScpLmZhZGVJbig2MDAsIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJyNkZXRhaWxzQXBwbGllZE1lc3NhZ2UnKS5mYWRlT3V0KDEwMDApOyB9LCAzMDAwKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vYWRqdXN0IGZyYW1lIGhlaWdodFxuICAgICAgICAgICAgc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5wYXJlbnRCbG9jay5oZWlnaHRBZGp1c3RtZW50KCk7XG5cblxuICAgICAgICAgICAgLy93ZSd2ZSBnb3QgcGVuZGluZyBjaGFuZ2VzXG4gICAgICAgICAgICBzaXRlQnVpbGRlci5zaXRlLnNldFBlbmRpbmdDaGFuZ2VzKHRydWUpO1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIucHVibGlzaCgnb25CbG9ja0NoYW5nZScsIHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQucGFyZW50QmxvY2ssICdjaGFuZ2UnKTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIG9uIGZvY3VzLCB3ZSdsbCBtYWtlIHRoZSBpbnB1dCBmaWVsZHMgd2lkZXJcbiAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVN0eWxlSW5wdXRJbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICQodGhpcykuY3NzKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ3JpZ2h0JywgJzBweCcpO1xuICAgICAgICAgICAgJCh0aGlzKS5hbmltYXRlKHsnd2lkdGgnOiAnMTAwJSd9LCA1MDApO1xuICAgICAgICAgICAgJCh0aGlzKS5mb2N1cyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIG9uIGJsdXIsIHdlJ2xsIHJldmVydCB0aGUgaW5wdXQgZmllbGRzIHRvIHRoZWlyIG9yaWdpbmFsIHNpemVcbiAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVN0eWxlSW5wdXRPdXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAkKHRoaXMpLmFuaW1hdGUoeyd3aWR0aCc6ICc0MiUnfSwgNTAwLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQodGhpcykuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICAgICAgICAgICQodGhpcykuY3NzKCdyaWdodCcsICdhdXRvJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBidWlsZHMgdGhlIGRyb3Bkb3duIHdpdGggcGFnZXMgdG8gbGluayB0b1xuICAgICAgICAqL1xuICAgICAgICBidWlsZFBhZ2VzRHJvcGRvd246IGZ1bmN0aW9uIChjdXJyZW50VmFsKSB7XG5cbiAgICAgICAgICAgICQoc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NQYWdlcykub2ZmKCdjaGFuZ2UnKS5zZWxlY3QyKCdkZXN0cm95Jyk7XG5cbiAgICAgICAgICAgIGlmKCB0eXBlb2YgY3VycmVudFZhbCA9PT0gJ3VuZGVmaW5lZCcgKSBjdXJyZW50VmFsID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIHgsXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uO1xuXG4gICAgICAgICAgICBzdHlsZWVkaXRvci5zZWxlY3RMaW5rc1BhZ2VzLmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICBuZXdPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdPUFRJT04nKTtcbiAgICAgICAgICAgIG5ld09wdGlvbi5pbm5lclRleHQgPSBcIkNob29zZSBhIHBhZ2VcIjtcbiAgICAgICAgICAgIG5ld09wdGlvbi5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJyMnKTtcbiAgICAgICAgICAgIHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzUGFnZXMuYXBwZW5kQ2hpbGQobmV3T3B0aW9uKTtcblxuICAgICAgICAgICAgZm9yKCB4ID0gMDsgeCA8IHNpdGVCdWlsZGVyLnNpdGUuc2l0ZVBhZ2VzLmxlbmd0aDsgeCsrICkge1xuXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnT1BUSU9OJyk7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uLmlubmVyVGV4dCA9IHNpdGVCdWlsZGVyLnNpdGUuc2l0ZVBhZ2VzW3hdLm5hbWU7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBzaXRlQnVpbGRlci5zaXRlLnNpdGVQYWdlc1t4XS5uYW1lICsgJy5odG1sJyk7XG4gICAgICAgICAgICAgICAgaWYoIGN1cnJlbnRWYWwgPT09IHNpdGVCdWlsZGVyLnNpdGUuc2l0ZVBhZ2VzW3hdLm5hbWUgKyAnLmh0bWwnKSBuZXdPcHRpb24uc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NQYWdlcy5hcHBlbmRDaGlsZChuZXdPcHRpb24pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQoc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NQYWdlcykuc2VsZWN0MigpO1xuICAgICAgICAgICAgJChzdHlsZWVkaXRvci5zZWxlY3RMaW5rc1BhZ2VzKS50cmlnZ2VyKCdjaGFuZ2UnKTtcblxuICAgICAgICAgICAgJChzdHlsZWVkaXRvci5zZWxlY3RMaW5rc1BhZ2VzKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLmlucHV0Q3VzdG9tTGluay52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgc3R5bGVlZGl0b3IucmVzZXRCbG9ja0Ryb3Bkb3duKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIGJ1aWxkcyB0aGUgZHJvcGRvd24gd2l0aCAjYmxvY2tzIG9uIHRoaXMgcGFnZVxuICAgICAgICAqL1xuICAgICAgICBidWlsZEJsb2Nrc0Ryb3Bkb3duOiBmdW5jdGlvbiAoY3VycmVudFZhbCkge1xuXG4gICAgICAgICAgICAkKHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzSW5lcm5hbCkub2ZmKCdjaGFuZ2UnKS5zZWxlY3QyKCdkZXN0cm95Jyk7XG5cbiAgICAgICAgICAgIGlmKCB0eXBlb2YgY3VycmVudFZhbCA9PT0gJ3VuZGVmaW5lZCcgKSBjdXJyZW50VmFsID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIHgsXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uO1xuXG4gICAgICAgICAgICBzdHlsZWVkaXRvci5zZWxlY3RMaW5rc0luZXJuYWwuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIG5ld09wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ09QVElPTicpO1xuICAgICAgICAgICAgbmV3T3B0aW9uLmlubmVyVGV4dCA9IFwiQ2hvb3NlIGEgYmxvY2tcIjtcbiAgICAgICAgICAgIG5ld09wdGlvbi5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJyMnKTtcbiAgICAgICAgICAgIHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzSW5lcm5hbC5hcHBlbmRDaGlsZChuZXdPcHRpb24pO1xuXG4gICAgICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHNpdGVCdWlsZGVyLnNpdGUuYWN0aXZlUGFnZS5ibG9ja3MubGVuZ3RoOyB4KysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVEb2MgPSBzaXRlQnVpbGRlci5zaXRlLmFjdGl2ZVBhZ2UuYmxvY2tzW3hdLmZyYW1lRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VDb250YWluZXIgID0gZnJhbWVEb2MucXVlcnlTZWxlY3RvcihiQ29uZmlnLnBhZ2VDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHZhciB0aGVJRCA9IHBhZ2VDb250YWluZXIuY2hpbGRyZW5bMF0uaWQ7XG5cbiAgICAgICAgICAgICAgICBuZXdPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdPUFRJT04nKTtcbiAgICAgICAgICAgICAgICBuZXdPcHRpb24uaW5uZXJUZXh0ID0gJyMnICsgdGhlSUQ7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnIycgKyB0aGVJRCk7XG4gICAgICAgICAgICAgICAgaWYoIGN1cnJlbnRWYWwgPT09ICcjJyArIHRoZUlEICkgbmV3T3B0aW9uLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzSW5lcm5hbC5hcHBlbmRDaGlsZChuZXdPcHRpb24pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQoc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NJbmVybmFsKS5zZWxlY3QyKCk7XG4gICAgICAgICAgICAkKHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzSW5lcm5hbCkudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICAgICAgICAgICQoc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NJbmVybmFsKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLmlucHV0Q3VzdG9tTGluay52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgc3R5bGVlZGl0b3IucmVzZXRQYWdlRHJvcGRvd24oKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKlxuICAgICAgICAgICAgYmx1ciBldmVudCBoYW5kbGVyIGZvciB0aGUgY3VzdG9tIGxpbmsgaW5wdXRcbiAgICAgICAgKi9cbiAgICAgICAgaW5wdXRDdXN0b21MaW5rQmx1cjogZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZS50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgICAgeDtcblxuICAgICAgICAgICAgLy9wYWdlcyBtYXRjaD9cbiAgICAgICAgICAgIGZvciAoIHggPSAwOyB4IDwgc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NQYWdlcy5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb24nKS5sZW5ndGg7IHgrKyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzUGFnZXMucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uJylbeF0udmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NQYWdlcy5zZWxlY3RlZEluZGV4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgJChzdHlsZWVkaXRvci5zZWxlY3RMaW5rc1BhZ2VzKS50cmlnZ2VyKCdjaGFuZ2UnKS5zZWxlY3QyKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9ibG9ja3MgbWF0Y2g/XG4gICAgICAgICAgICBmb3IgKCB4ID0gMDsgc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NJbmVybmFsLnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbicpLmxlbmd0aDsgeCsrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NJbmVybmFsLnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbicpW3hdLnZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzSW5lcm5hbC5zZWxlY3RlZEluZGV4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgJChzdHlsZWVkaXRvci5zZWxlY3RMaW5rc0luZXJuYWwpLnRyaWdnZXIoJ2NoYW5nZScpLnNlbGVjdDIoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKlxuICAgICAgICAgICAgZm9jdXMgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGN1c3RvbSBsaW5rIGlucHV0XG4gICAgICAgICovXG4gICAgICAgIGlucHV0Q3VzdG9tTGlua0ZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHN0eWxlZWRpdG9yLnJlc2V0UGFnZURyb3Bkb3duKCk7XG4gICAgICAgICAgICBzdHlsZWVkaXRvci5yZXNldEJsb2NrRHJvcGRvd24oKTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHJlc2V0IHRoZSBibG9jayBsaW5rIGRyb3Bkb3duXG4gICAgICAgICovXG4gICAgICAgIHJlc2V0QmxvY2tEcm9wZG93bjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBzdHlsZWVkaXRvci5zZWxlY3RMaW5rc0luZXJuYWwuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgICAgICAkKHN0eWxlZWRpdG9yLnNlbGVjdExpbmtzSW5lcm5hbCkuc2VsZWN0MignZGVzdHJveScpLnNlbGVjdDIoKTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHJlc2V0IHRoZSBwYWdlIGxpbmsgZHJvcGRvd25cbiAgICAgICAgKi9cbiAgICAgICAgcmVzZXRQYWdlRHJvcGRvd246IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NQYWdlcy5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgICAgICQoc3R5bGVlZGl0b3Iuc2VsZWN0TGlua3NQYWdlcykuc2VsZWN0MignZGVzdHJveScpLnNlbGVjdDIoKTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHdoZW4gdGhlIGNsaWNrZWQgZWxlbWVudCBpcyBhbiBhbmNob3IgdGFnIChvciBoYXMgYSBwYXJlbnQgYW5jaG9yIHRhZylcbiAgICAgICAgKi9cbiAgICAgICAgZWRpdExpbms6IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgICAgICAgIHZhciB0aGVIcmVmO1xuXG4gICAgICAgICAgICAkKCdhI2xpbmtfTGluaycpLnBhcmVudCgpLnNob3coKTtcblxuICAgICAgICAgICAgLy9zZXQgdGhlSHJlZlxuICAgICAgICAgICAgaWYoICQoZWwpLnByb3AoJ3RhZ05hbWUnKSA9PT0gJ0EnICkge1xuXG4gICAgICAgICAgICAgICAgdGhlSHJlZiA9ICQoZWwpLmF0dHIoJ2hyZWYnKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmKCAkKGVsKS5wYXJlbnQoKS5wcm9wKCd0YWdOYW1lJykgPT09ICdBJyApIHtcblxuICAgICAgICAgICAgICAgIHRoZUhyZWYgPSAkKGVsKS5wYXJlbnQoKS5hdHRyKCdocmVmJyk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGVlZGl0b3IuYnVpbGRQYWdlc0Ryb3Bkb3duKHRoZUhyZWYpO1xuICAgICAgICAgICAgc3R5bGVlZGl0b3IuYnVpbGRCbG9ja3NEcm9wZG93bih0aGVIcmVmKTtcbiAgICAgICAgICAgIHN0eWxlZWRpdG9yLmlucHV0Q3VzdG9tTGluay52YWx1ZSA9IHRoZUhyZWY7XG5cbiAgICAgICAgICAgIC8vZ3JhYiBhbiBpbWFnZT9cbiAgICAgICAgICAgIGlmICggZWwucXVlcnlTZWxlY3RvcignaW1nJykgKSBzdHlsZWVkaXRvci5saW5rSW1hZ2UgPSBlbC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICAgICAgICAgIGVsc2Ugc3R5bGVlZGl0b3IubGlua0ltYWdlID0gbnVsbDtcblxuICAgICAgICAgICAgLy9ncmFiIGFuIGljb24/XG4gICAgICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3IoJy5mYScpICkgc3R5bGVlZGl0b3IubGlua0ljb24gPSBlbC5xdWVyeVNlbGVjdG9yKCcuZmEnKS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIHN0eWxlZWRpdG9yLmxpbmtJY29uID0gbnVsbDtcblxuICAgICAgICAgICAgc3R5bGVlZGl0b3IuaW5wdXRMaW5rVGV4dC52YWx1ZSA9IGVsLmlubmVyVGV4dDtcbiAgICBcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB3aGVuIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgYW4gaW1hZ2VcbiAgICAgICAgKi9cbiAgICAgICAgZWRpdEltYWdlOiBmdW5jdGlvbihlbCkge1xuXG4gICAgICAgICAgICAkKCdhI2ltZ19MaW5rJykucGFyZW50KCkuc2hvdygpO1xuXG4gICAgICAgICAgICAvL3NldCB0aGUgY3VycmVudCBTUkNcbiAgICAgICAgICAgICQoJy5pbWFnZUZpbGVUYWInKS5maW5kKCdpbnB1dCNpbWFnZVVSTCcpLnZhbCggJChlbCkuYXR0cignc3JjJykgKTtcblxuICAgICAgICAgICAgLy9yZXNldCB0aGUgZmlsZSB1cGxvYWRcbiAgICAgICAgICAgICQoJy5pbWFnZUZpbGVUYWInKS5maW5kKCdhLmZpbGVpbnB1dC1leGlzdHMnKS5jbGljaygpO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKlxuICAgICAgICAgICAgd2hlbiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIGEgdmlkZW8gZWxlbWVudFxuICAgICAgICAqL1xuICAgICAgICBlZGl0VmlkZW86IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgICAgICAgIHZhciBtYXRjaFJlc3VsdHM7XG5cbiAgICAgICAgICAgICQoJ2EjdmlkZW9fTGluaycpLnBhcmVudCgpLnNob3coKTtcbiAgICAgICAgICAgICQoJ2EjdmlkZW9fTGluaycpLmNsaWNrKCk7XG5cbiAgICAgICAgICAgIC8vaW5qZWN0IGN1cnJlbnQgdmlkZW8gSUQsY2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIFlvdXR1YmUgb3IgVmltZW9cblxuICAgICAgICAgICAgaWYoICQoZWwpLnByZXYoKS5hdHRyKCdzcmMnKS5pbmRleE9mKFwidmltZW8uY29tXCIpID4gLTEgKSB7Ly92aW1lb1xuXG4gICAgICAgICAgICAgICAgbWF0Y2hSZXN1bHRzID0gJChlbCkucHJldigpLmF0dHIoJ3NyYycpLm1hdGNoKC9wbGF5ZXJcXC52aW1lb1xcLmNvbVxcL3ZpZGVvXFwvKFswLTldKikvKTtcblxuICAgICAgICAgICAgICAgICQoJyN2aWRlb19UYWIgaW5wdXQjdmltZW9JRCcpLnZhbCggbWF0Y2hSZXN1bHRzW21hdGNoUmVzdWx0cy5sZW5ndGgtMV0gKTtcbiAgICAgICAgICAgICAgICAkKCcjdmlkZW9fVGFiIGlucHV0I3lvdXR1YmVJRCcpLnZhbCgnJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7Ly95b3V0dWJlXG5cbiAgICAgICAgICAgICAgICAvL3RlbXAgPSAkKGVsKS5wcmV2KCkuYXR0cignc3JjJykuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVnRXhwID0gLy4qKD86eW91dHUuYmVcXC98dlxcL3x1XFwvXFx3XFwvfGVtYmVkXFwvfHdhdGNoXFw/dj0pKFteI1xcJlxcP10qKS4qLztcbiAgICAgICAgICAgICAgICBtYXRjaFJlc3VsdHMgPSAkKGVsKS5wcmV2KCkuYXR0cignc3JjJykubWF0Y2gocmVnRXhwKTtcblxuICAgICAgICAgICAgICAgICQoJyN2aWRlb19UYWIgaW5wdXQjeW91dHViZUlEJykudmFsKCBtYXRjaFJlc3VsdHNbMV0gKTtcbiAgICAgICAgICAgICAgICAkKCcjdmlkZW9fVGFiIGlucHV0I3ZpbWVvSUQnKS52YWwoJycpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB3aGVuIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgYW4gZmEgaWNvblxuICAgICAgICAqL1xuICAgICAgICBlZGl0SWNvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICQoJ2EjaWNvbl9MaW5rJykucGFyZW50KCkuc2hvdygpO1xuXG4gICAgICAgICAgICAvL2dldCBpY29uIGNsYXNzIG5hbWUsIHN0YXJ0aW5nIHdpdGggZmEtXG4gICAgICAgICAgICB2YXIgZ2V0ID0gJC5ncmVwKHRoaXMuYWN0aXZlRWxlbWVudC5lbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKHYsIGkpe1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuaW5kZXhPZignZmEtJykgPT09IDA7XG5cbiAgICAgICAgICAgIH0pLmpvaW4oKTtcblxuICAgICAgICAgICAgJCgnc2VsZWN0I2ljb25zIG9wdGlvbicpLmVhY2goZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIGlmKCAkKHRoaXMpLnZhbCgpID09PSBnZXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKCdzZWxlY3RlZCcsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoJyNpY29ucycpLnRyaWdnZXIoJ2Nob3Nlbjp1cGRhdGVkJyk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKlxuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkIGVsZW1lbnRcbiAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5wdWJsaXNoKCdvbkJlZm9yZURlbGV0ZScpO1xuXG4gICAgICAgICAgICB2YXIgdG9EZWw7XG5cbiAgICAgICAgICAgIC8vZGV0ZXJtaW5lIHdoYXQgdG8gZGVsZXRlXG4gICAgICAgICAgICBpZiggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnByb3AoJ3RhZ05hbWUnKSA9PT0gJ0EnICkgey8vYW5jb3JcblxuICAgICAgICAgICAgICAgIGlmKCAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucGFyZW50KCkucHJvcCgndGFnTmFtZScpID09PSdMSScgKSB7Ly9jbG9uZSB0aGUgTElcblxuICAgICAgICAgICAgICAgICAgICB0b0RlbCA9ICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5wYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdG9EZWwgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnByb3AoJ3RhZ05hbWUnKSA9PT0gJ0lNRycgKSB7Ly9pbWFnZVxuXG4gICAgICAgICAgICAgICAgaWYoICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5wYXJlbnQoKS5wcm9wKCd0YWdOYW1lJykgPT09ICdBJyApIHsvL2Nsb25lIHRoZSBBXG5cbiAgICAgICAgICAgICAgICAgICAgdG9EZWwgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucGFyZW50KCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHRvRGVsID0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Ugey8vZXZlcnl0aGluZyBlbHNlXG5cbiAgICAgICAgICAgICAgICB0b0RlbCA9ICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRvRGVsLmZhZGVPdXQoNTAwLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgdmFyIHJhbmRvbUVsID0gJCh0aGlzKS5jbG9zZXN0KCdib2R5JykuZmluZCgnKjpmaXJzdCcpO1xuXG4gICAgICAgICAgICAgICAgdG9EZWwucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAvKiBTQU5EQk9YICovXG5cbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudElEID0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgICAgICAgICAkKCcjJytzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3gpLmNvbnRlbnRzKCkuZmluZCgnIycrZWxlbWVudElEKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIC8qIEVORCBTQU5EQk9YICovXG5cbiAgICAgICAgICAgICAgICBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnBhcmVudEJsb2NrLmhlaWdodEFkanVzdG1lbnQoKTtcblxuICAgICAgICAgICAgICAgIC8vd2UndmUgZ290IHBlbmRpbmcgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHNpdGVCdWlsZGVyLnNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKCcjZGVsZXRlRWxlbWVudCcpLm1vZGFsKCdoaWRlJyk7XG5cbiAgICAgICAgICAgIHN0eWxlZWRpdG9yLmNsb3NlU3R5bGVFZGl0b3IoKTtcblxuICAgICAgICAgICAgcHVibGlzaGVyLnB1Ymxpc2goJ29uQmxvY2tDaGFuZ2UnLCBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnBhcmVudEJsb2NrLCAnY2hhbmdlJyk7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBjbG9uZXMgdGhlIHNlbGVjdGVkIGVsZW1lbnRcbiAgICAgICAgKi9cbiAgICAgICAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgcHVibGlzaGVyLnB1Ymxpc2goJ29uQmVmb3JlQ2xvbmUnKTtcblxuICAgICAgICAgICAgdmFyIHRoZUNsb25lLCB0aGVDbG9uZTIsIHRoZU9uZSwgY2xvbmVkLCBjbG9uZVBhcmVudCwgZWxlbWVudElEO1xuXG4gICAgICAgICAgICBpZiggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnBhcmVudCgpLmhhc0NsYXNzKCdwcm9wQ2xvbmUnKSApIHsvL2Nsb25lIHRoZSBwYXJlbnQgZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgdGhlQ2xvbmUgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucGFyZW50KCkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0aGVDbG9uZS5maW5kKCAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucHJvcCgndGFnTmFtZScpICkuYXR0cignc3R5bGUnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICB0aGVDbG9uZTIgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucGFyZW50KCkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0aGVDbG9uZTIuZmluZCggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnByb3AoJ3RhZ05hbWUnKSApLmF0dHIoJ3N0eWxlJywgJycpO1xuXG4gICAgICAgICAgICAgICAgdGhlT25lID0gdGhlQ2xvbmUuZmluZCggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnByb3AoJ3RhZ05hbWUnKSApO1xuICAgICAgICAgICAgICAgIGNsb25lZCA9ICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5wYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIGNsb25lUGFyZW50ID0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLnBhcmVudCgpLnBhcmVudCgpO1xuXG4gICAgICAgICAgICB9IGVsc2Ugey8vY2xvbmUgdGhlIGVsZW1lbnQgaXRzZWxmXG5cbiAgICAgICAgICAgICAgICB0aGVDbG9uZSA9ICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhlQ2xvbmUuYXR0cignc3R5bGUnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvKmlmKCBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3ggKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUNsb25lLmF0dHIoJ2lkJywgJycpLnVuaXF1ZUlkKCk7XG4gICAgICAgICAgICAgICAgfSovXG5cbiAgICAgICAgICAgICAgICB0aGVDbG9uZTIgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0aGVDbG9uZTIuYXR0cignc3R5bGUnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmKCBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3ggKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUNsb25lMi5hdHRyKCdpZCcsIHRoZUNsb25lLmF0dHIoJ2lkJykpO1xuICAgICAgICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgICAgICAgdGhlT25lID0gdGhlQ2xvbmU7XG4gICAgICAgICAgICAgICAgY2xvbmVkID0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgY2xvbmVQYXJlbnQgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkucGFyZW50KCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xvbmVkLmFmdGVyKCB0aGVDbG9uZSApO1xuXG4gICAgICAgICAgICAvKiBTQU5EQk9YICovXG5cbiAgICAgICAgICAgIGlmKCBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3ggKSB7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50SUQgPSAkKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuYXR0cignaWQnKTtcbiAgICAgICAgICAgICAgICAkKCcjJytzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3gpLmNvbnRlbnRzKCkuZmluZCgnIycrZWxlbWVudElEKS5hZnRlciggdGhlQ2xvbmUyICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogRU5EIFNBTkRCT1ggKi9cblxuICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhlIG5ldyBlbGVtZW50IGdldHMgdGhlIHByb3BlciBldmVudHMgc2V0IG9uIGl0XG4gICAgICAgICAgICBpZiAoICF0aGVDbG9uZS5nZXQoMCkuY2xhc3NMaXN0LmNvbnRhaW5zKCdwcm9wQ2xvbmUnKSApIHN0eWxlZWRpdG9yLnNldHVwQ2FudmFzRWxlbWVudHNPbkVsZW1lbnQodGhlQ2xvbmUuZ2V0KDApKTtcblxuICAgICAgICAgICAgLy9jcmVhdGUgYW4gb2JqZWN0IGZvciBldmVyeSBlZGl0YWJsZSBlbGVtZW50IGluIHRoZSBjbG9uZWQgZWxlbWVudCBhcyB3ZWxsXG4gICAgICAgICAgICBmb3IoIHZhciBrZXkgaW4gYkNvbmZpZy5lZGl0YWJsZUl0ZW1zICkge1xuXG4gICAgICAgICAgICAgICAgdGhlQ2xvbmUuZmluZCggJypbZGF0YS1zZWxlY3Rvcj1cIicgKyBrZXkgKyAnXCJdJyApLmVhY2goZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlZWRpdG9yLnNldHVwQ2FudmFzRWxlbWVudHNPbkVsZW1lbnQodGhpcywga2V5KTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcG9zc2libGUgaGVpZ2h0IGFkanVzdG1lbnRzXG4gICAgICAgICAgICBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnBhcmVudEJsb2NrLmhlaWdodEFkanVzdG1lbnQoKTtcblxuICAgICAgICAgICAgLy93ZSd2ZSBnb3QgcGVuZGluZyBjaGFuZ2VzXG4gICAgICAgICAgICBzaXRlQnVpbGRlci5zaXRlLnNldFBlbmRpbmdDaGFuZ2VzKHRydWUpO1xuXG4gICAgICAgICAgICBwdWJsaXNoZXIucHVibGlzaCgnb25CbG9ja0NoYW5nZScsIHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQucGFyZW50QmxvY2ssICdjaGFuZ2UnKTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHJlc2V0cyB0aGUgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAgKi9cbiAgICAgICAgcmVzZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ3N0eWxlJywgJycpLmNzcyh7J291dGxpbmUnOiAnM3B4IGRhc2hlZCByZWQnLCAnb3V0bGluZS1vZmZzZXQnOictM3B4JywgJ2N1cnNvcic6ICdwb2ludGVyJ30pO1xuXG4gICAgICAgICAgICAvKiBTQU5EQk9YICovXG5cbiAgICAgICAgICAgIGlmKCBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnNhbmRib3ggKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudElEID0gJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ2lkJyk7XG4gICAgICAgICAgICAgICAgJCgnIycrc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5zYW5kYm94KS5jb250ZW50cygpLmZpbmQoJyMnK2VsZW1lbnRJRCkuYXR0cignc3R5bGUnLCAnJyk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogRU5EIFNBTkRCT1ggKi9cblxuICAgICAgICAgICAgJCgnI3N0eWxlRWRpdG9yIGZvcm0jc3R5bGluZ0Zvcm0nKS5oZWlnaHQoICQoJyNzdHlsZUVkaXRvciBmb3JtI3N0eWxpbmdGb3JtJykuaGVpZ2h0KCkrXCJweFwiICk7XG5cbiAgICAgICAgICAgICQoJyNzdHlsZUVkaXRvciBmb3JtI3N0eWxpbmdGb3JtIC5mb3JtLWdyb3VwOm5vdCgjc3R5bGVFbFRlbXBsYXRlKScpLmZhZGVPdXQoNTAwLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy9yZXNldCBpY29uXG5cbiAgICAgICAgICAgIGlmKCBzdHlsZWVkaXRvci5fb2xkSWNvblskKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudCkuYXR0cignaWQnKV0gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0ID0gJC5ncmVwKHN0eWxlZWRpdG9yLmFjdGl2ZUVsZW1lbnQuZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbih2LCBpKXtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5pbmRleE9mKCdmYS0nKSA9PT0gMDtcblxuICAgICAgICAgICAgICAgIH0pLmpvaW4oKTtcblxuICAgICAgICAgICAgICAgICQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5yZW1vdmVDbGFzcyggZ2V0ICkuYWRkQ2xhc3MoIHN0eWxlZWRpdG9yLl9vbGRJY29uWyQoc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lbGVtZW50KS5hdHRyKCdpZCcpXSApO1xuXG4gICAgICAgICAgICAgICAgJCgnc2VsZWN0I2ljb25zIG9wdGlvbicpLmVhY2goZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgICAgICBpZiggJCh0aGlzKS52YWwoKSA9PT0gc3R5bGVlZGl0b3IuX29sZEljb25bJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ2lkJyldICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjaWNvbnMnKS50cmlnZ2VyKCdjaG9zZW46dXBkYXRlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7c3R5bGVlZGl0b3IuYnVpbGRlU3R5bGVFbGVtZW50cyggJChzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmVsZW1lbnQpLmF0dHIoJ2RhdGEtc2VsZWN0b3InKSApO30sIDU1MCk7XG5cbiAgICAgICAgICAgIHNpdGVCdWlsZGVyLnNpdGUuc2V0UGVuZGluZ0NoYW5nZXModHJ1ZSk7XG5cbiAgICAgICAgICAgIHB1Ymxpc2hlci5wdWJsaXNoKCdvbkJsb2NrQ2hhbmdlJywgc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5wYXJlbnRCbG9jaywgJ2NoYW5nZScpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIGhpZGVzIGZpbGUgdXBsb2FkIGZvcm1zXG4gICAgICAgICovXG4gICAgICAgIGhpZGVGaWxlVXBsb2FkczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICQoJ2Zvcm0jaW1hZ2VVcGxvYWRGb3JtJykuaGlkZSgpO1xuICAgICAgICAgICAgJCgnI2ltYWdlTW9kYWwgI3VwbG9hZFRhYkxJJykuaGlkZSgpO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKlxuICAgICAgICAgICAgY2xvc2VzIHRoZSBzdHlsZSBlZGl0b3JcbiAgICAgICAgKi9cbiAgICAgICAgY2xvc2VTdHlsZUVkaXRvcjogZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgaWYgKCBlICE9PSB1bmRlZmluZWQgKSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmICggc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lZGl0YWJsZUF0dHJpYnV0ZXMgJiYgc3R5bGVlZGl0b3IuYWN0aXZlRWxlbWVudC5lZGl0YWJsZUF0dHJpYnV0ZXMuaW5kZXhPZignY29udGVudCcpID09PSAtMSApIHtcbiAgICAgICAgICAgICAgICBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LnJlbW92ZU91dGxpbmUoKTtcbiAgICAgICAgICAgICAgICBzdHlsZWVkaXRvci5hY3RpdmVFbGVtZW50LmFjdGl2YXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCAkKCcjc3R5bGVFZGl0b3InKS5jc3MoJ2xlZnQnKSA9PT0gJzBweCcgKSB7XG5cbiAgICAgICAgICAgICAgICBzdHlsZWVkaXRvci50b2dnbGVTaWRlUGFuZWwoJ2Nsb3NlJyk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIHRvZ2dsZXMgdGhlIHNpZGUgcGFuZWxcbiAgICAgICAgKi9cbiAgICAgICAgdG9nZ2xlU2lkZVBhbmVsOiBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAgICAgaWYoIHZhbCA9PT0gJ29wZW4nICYmICQoJyNzdHlsZUVkaXRvcicpLmNzcygnbGVmdCcpID09PSAnLTMwMHB4JyApIHtcbiAgICAgICAgICAgICAgICAkKCcjc3R5bGVFZGl0b3InKS5hbmltYXRlKHsnbGVmdCc6ICcwcHgnfSwgMjUwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggdmFsID09PSAnY2xvc2UnICYmICQoJyNzdHlsZUVkaXRvcicpLmNzcygnbGVmdCcpID09PSAnMHB4JyApIHtcbiAgICAgICAgICAgICAgICAkKCcjc3R5bGVFZGl0b3InKS5hbmltYXRlKHsnbGVmdCc6ICctMzAwcHgnfSwgMjUwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgc3R5bGVlZGl0b3IuaW5pdCgpO1xuXG4gICAgZXhwb3J0cy5zdHlsZWVkaXRvciA9IHN0eWxlZWRpdG9yO1xuXG59KCkpOyIsIihmdW5jdGlvbiAoKSB7XG5cbi8qIGdsb2JhbHMgc2l0ZVVybDpmYWxzZSwgYmFzZVVybDpmYWxzZSAqL1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBcbiAgICB2YXIgYXBwVUkgPSB7XG4gICAgICAgIFxuICAgICAgICBmaXJzdE1lbnVXaWR0aDogMTkwLFxuICAgICAgICBzZWNvbmRNZW51V2lkdGg6IDMwMCxcbiAgICAgICAgbG9hZGVyQW5pbWF0aW9uOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGVyJyksXG4gICAgICAgIHNlY29uZE1lbnVUcmlnZ2VyQ29udGFpbmVyczogJCgnI21lbnUgI21haW4gI2VsZW1lbnRDYXRzLCAjbWVudSAjbWFpbiAjdGVtcGxhdGVzVWwnKSxcbiAgICAgICAgc2l0ZVVybDogc2l0ZVVybCxcbiAgICAgICAgYmFzZVVybDogYmFzZVVybCxcbiAgICAgICAgXG4gICAgICAgIHNldHVwOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGYWRlIHRoZSBsb2FkZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICAkKGFwcFVJLmxvYWRlckFuaW1hdGlvbikuZmFkZU91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQoJyNtZW51JykuYW5pbWF0ZSh7J2xlZnQnOiAtYXBwVUkuZmlyc3RNZW51V2lkdGh9LCAxMDAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUYWJzXG4gICAgICAgICAgICAkKFwiLm5hdi10YWJzIGFcIikub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS50YWIoXCJzaG93XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQoXCJzZWxlY3Quc2VsZWN0XCIpLnNlbGVjdDIoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJCgnOnJhZGlvLCA6Y2hlY2tib3gnKS5yYWRpb2NoZWNrKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRvb2x0aXBzXG4gICAgICAgICAgICAkKFwiW2RhdGEtdG9nZ2xlPXRvb2x0aXBdXCIpLnRvb2x0aXAoXCJoaWRlXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUYWJsZTogVG9nZ2xlIGFsbCBjaGVja2JveGVzXG4gICAgICAgICAgICAkKCcudGFibGUgLnRvZ2dsZS1hbGwgOmNoZWNrYm94Jykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gJHRoaXMucHJvcCgnY2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgICR0aGlzLmNsb3Nlc3QoJy50YWJsZScpLmZpbmQoJ3Rib2R5IDpjaGVja2JveCcpLnJhZGlvY2hlY2soIWNoID8gJ3VuY2hlY2snIDogJ2NoZWNrJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHN0eWxlIGNsYXNzIG5hbWUgdG8gYSB0b29sdGlwc1xuICAgICAgICAgICAgJChcIi50b29sdGlwXCIpLmFkZENsYXNzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnByZXYoKS5hdHRyKFwiZGF0YS10b29sdGlwLXN0eWxlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRvb2x0aXAtXCIgKyAkKHRoaXMpLnByZXYoKS5hdHRyKFwiZGF0YS10b29sdGlwLXN0eWxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAkKFwiLmJ0bi1ncm91cFwiKS5vbignY2xpY2snLCBcImFcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLmVuZCgpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZvY3VzIHN0YXRlIGZvciBhcHBlbmQvcHJlcGVuZCBpbnB1dHNcbiAgICAgICAgICAgICQoJy5pbnB1dC1ncm91cCcpLm9uKCdmb2N1cycsICcuZm9ybS1jb250cm9sJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnLmlucHV0LWdyb3VwLCAuZm9ybS1ncm91cCcpLmFkZENsYXNzKCdmb2N1cycpO1xuICAgICAgICAgICAgfSkub24oJ2JsdXInLCAnLmZvcm0tY29udHJvbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJy5pbnB1dC1ncm91cCwgLmZvcm0tZ3JvdXAnKS5yZW1vdmVDbGFzcygnZm9jdXMnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUYWJsZTogVG9nZ2xlIGFsbCBjaGVja2JveGVzXG4gICAgICAgICAgICAkKCcudGFibGUgLnRvZ2dsZS1hbGwnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSAkKHRoaXMpLmZpbmQoJzpjaGVja2JveCcpLnByb3AoJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJy50YWJsZScpLmZpbmQoJ3Rib2R5IDpjaGVja2JveCcpLmNoZWNrYm94KCFjaCA/ICdjaGVjaycgOiAndW5jaGVjaycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRhYmxlOiBBZGQgY2xhc3Mgcm93IHNlbGVjdGVkXG4gICAgICAgICAgICAkKCcudGFibGUgdGJvZHkgOmNoZWNrYm94Jykub24oJ2NoZWNrIHVuY2hlY2sgdG9nZ2xlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICAgICAgICAgICAgLCBjaGVjayA9ICR0aGlzLnByb3AoJ2NoZWNrZWQnKVxuICAgICAgICAgICAgICAgICwgdG9nZ2xlID0gZS50eXBlID09PSAndG9nZ2xlJ1xuICAgICAgICAgICAgICAgICwgY2hlY2tib3hlcyA9ICQoJy50YWJsZSB0Ym9keSA6Y2hlY2tib3gnKVxuICAgICAgICAgICAgICAgICwgY2hlY2tBbGwgPSBjaGVja2JveGVzLmxlbmd0aCA9PT0gY2hlY2tib3hlcy5maWx0ZXIoJzpjaGVja2VkJykubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgJHRoaXMuY2xvc2VzdCgndHInKVtjaGVjayA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnc2VsZWN0ZWQtcm93Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZSkgJHRoaXMuY2xvc2VzdCgnLnRhYmxlJykuZmluZCgnLnRvZ2dsZS1hbGwgOmNoZWNrYm94JykuY2hlY2tib3goY2hlY2tBbGwgPyAnY2hlY2snIDogJ3VuY2hlY2snKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTd2l0Y2hcbiAgICAgICAgICAgICQoXCJbZGF0YS10b2dnbGU9J3N3aXRjaCddXCIpLndyYXAoJzxkaXYgY2xhc3M9XCJzd2l0Y2hcIiAvPicpLnBhcmVudCgpLmJvb3RzdHJhcFN3aXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBhcHBVSS5zZWNvbmRNZW51VHJpZ2dlckNvbnRhaW5lcnMub24oJ2NsaWNrJywgJ2E6bm90KC5idG4pJywgYXBwVUkuc2Vjb25kTWVudUFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHNlY29uZE1lbnVBbmltYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgJCgnI21lbnUgI21haW4gYScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcbiAgICAgICAgICAgIC8vc2hvdyBvbmx5IHRoZSByaWdodCBlbGVtZW50c1xuICAgICAgICAgICAgJCgnI21lbnUgI3NlY29uZCB1bCBsaScpLmhpZGUoKTtcbiAgICAgICAgICAgICQoJyNtZW51ICNzZWNvbmQgdWwgbGkuJyskKHRoaXMpLmF0dHIoJ2lkJykpLnNob3coKTtcblxuICAgICAgICAgICAgaWYoICQodGhpcykuYXR0cignaWQnKSA9PT0gJ2FsbCcgKSB7XG4gICAgICAgICAgICAgICAgJCgnI21lbnUgI3NlY29uZCB1bCNlbGVtZW50cyBsaScpLnNob3coKTtcdFx0XG4gICAgICAgICAgICB9XG5cdFxuICAgICAgICAgICAgJCgnLm1lbnUgLnNlY29uZCcpLmNzcygnZGlzcGxheScsICdibG9jaycpLnN0b3AoKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBwVUkuc2Vjb25kTWVudVdpZHRoXG4gICAgICAgICAgICB9LCA1MDApO1x0XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICAvL2luaXRpYXRlIHRoZSBVSVxuICAgIGFwcFVJLnNldHVwKCk7XG5cblxuICAgIC8vKioqKiBFWFBPUlRTXG4gICAgbW9kdWxlLmV4cG9ydHMuYXBwVUkgPSBhcHBVSTtcbiAgICBcbn0oKSk7IiwiKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgZXhwb3J0cy5nZXRSYW5kb21BcmJpdHJhcnkgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pO1xuICAgIH07XG4gICAgXG59KCkpOyIsIi8qIVxuICogcHVibGlzaGVyLmpzIC0gKGMpIFJ5YW4gRmxvcmVuY2UgMjAxMVxuICogZ2l0aHViLmNvbS9ycGZsb3JlbmNlL3B1Ymxpc2hlci5qc1xuICogTUlUIExpY2Vuc2VcbiovXG5cbi8vIFVNRCBCb2lsZXJwbGF0ZSBcXG8vICYmIEQ6XG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyAvLyBub2RlXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpOyAvLyBhbWRcbiAgfSBlbHNlIHtcbiAgICAvLyB3aW5kb3cgd2l0aCBub0NvbmZsaWN0XG4gICAgdmFyIF9wdWJsaXNoZXIgPSByb290LnB1Ymxpc2hlcjtcbiAgICB2YXIgcHVibGlzaGVyID0gcm9vdC5wdWJsaXNoZXIgPSBmYWN0b3J5KCk7XG4gICAgcm9vdC5wdWJsaXNoZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3QucHVibGlzaGVyID0gX3B1Ymxpc2hlcjtcbiAgICAgIHJldHVybiBwdWJsaXNoZXI7XG4gICAgfVxuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcHVibGlzaGVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciB0b3BpY3MgPSB7fTtcbiAgICBvYmogPSBvYmogfHwge307XG5cbiAgICBvYmoucHVibGlzaCA9IGZ1bmN0aW9uICh0b3BpYy8qLCBtZXNzYWdlcy4uLiovKSB7XG4gICAgICBpZiAoIXRvcGljc1t0b3BpY10pIHJldHVybiBvYmo7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRvcGljc1t0b3BpY10ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRvcGljc1t0b3BpY11baV0uaGFuZGxlci5hcHBseSh0b3BpY3NbdG9waWNdW2ldLmNvbnRleHQsIG1lc3NhZ2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIG9iai5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodG9waWNPclN1YnNjcmliZXIsIGhhbmRsZXJPclRvcGljcykge1xuICAgICAgdmFyIGZpcnN0VHlwZSA9IHR5cGVvZiB0b3BpY09yU3Vic2NyaWJlcjtcblxuICAgICAgaWYgKGZpcnN0VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RUeXBlID09PSAnb2JqZWN0JyAmJiAhaGFuZGxlck9yVG9waWNzKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVNdWx0aXBsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXJPclRvcGljcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhpdGNoLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoaXRjaE11bHRpcGxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZSAodG9waWMsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZWZlcmVuY2UgPSB7IGhhbmRsZXI6IGhhbmRsZXIsIGNvbnRleHQ6IGNvbnRleHQgfHwgb2JqIH07XG4gICAgICB0b3BpYyA9IHRvcGljc1t0b3BpY10gfHwgKHRvcGljc1t0b3BpY10gPSBbXSk7XG4gICAgICB0b3BpYy5wdXNoKHJlZmVyZW5jZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0b3BpYy5wdXNoKHJlZmVyZW5jZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVyYXNlKHRvcGljLCByZWZlcmVuY2UpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmVNdWx0aXBsZSAocGFpcnMpIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb25zID0ge307XG4gICAgICBmb3IgKHZhciB0b3BpYyBpbiBwYWlycykge1xuICAgICAgICBpZiAoIXBhaXJzLmhhc093blByb3BlcnR5KHRvcGljKSkgY29udGludWU7XG4gICAgICAgIHN1YnNjcmlwdGlvbnNbdG9waWNdID0gc3Vic2NyaWJlKHRvcGljLCBwYWlyc1t0b3BpY10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbnM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhpdGNoIChzdWJzY3JpYmVyLCB0b3BpYykge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZSh0b3BpYywgc3Vic2NyaWJlclt0b3BpY10sIHN1YnNjcmliZXIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoaXRjaE11bHRpcGxlIChzdWJzY3JpYmVyLCB0b3BpY3MpIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRvcGljcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKCBoaXRjaChzdWJzY3JpYmVyLCB0b3BpY3NbaV0pICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9ucztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXJhc2UgKGFyciwgdmljdGltKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspe1xuICAgICAgICBpZiAoYXJyW2ldID09PSB2aWN0aW0pIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBwdWJsaXNoZXIgaXMgYSBwdWJsaXNoZXIsIHNvIG1ldGEgLi4uXG4gIHJldHVybiBwdWJsaXNoZXIocHVibGlzaGVyKTtcbn0pKTtcbiIsIi8qZ2xvYmFsIHNlbGYsIGRvY3VtZW50LCBET01FeGNlcHRpb24gKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9jbGFzc0xpc3QuanMgKi9cblxuLy8gRnVsbCBwb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aCBubyBjbGFzc0xpc3Qgc3VwcG9ydFxuaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSkpIHtcbiAgKGZ1bmN0aW9uICh2aWV3KSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XG5cbiAgdmFyXG4gICAgICBjbGFzc0xpc3RQcm9wID0gXCJjbGFzc0xpc3RcIlxuICAgICwgcHJvdG9Qcm9wID0gXCJwcm90b3R5cGVcIlxuICAgICwgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF1cbiAgICAsIG9iakN0ciA9IE9iamVjdFxuICAgICwgc3RyVHJpbSA9IFN0cmluZ1twcm90b1Byb3BdLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgfVxuICAgICwgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyXG4gICAgICAgICAgaSA9IDBcbiAgICAgICAgLCBsZW4gPSB0aGlzLmxlbmd0aFxuICAgICAgO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcbiAgICAsIERPTUV4ID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubmFtZSA9IHR5cGU7XG4gICAgICB0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICAsIGNoZWNrVG9rZW5BbmRHZXRJbmRleCA9IGZ1bmN0aW9uIChjbGFzc0xpc3QsIHRva2VuKSB7XG4gICAgICBpZiAodG9rZW4gPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4KFxuICAgICAgICAgICAgXCJTWU5UQVhfRVJSXCJcbiAgICAgICAgICAsIFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXgoXG4gICAgICAgICAgICBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiXG4gICAgICAgICAgLCBcIlN0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3RlclwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJySW5kZXhPZi5jYWxsKGNsYXNzTGlzdCwgdG9rZW4pO1xuICAgIH1cbiAgICAsIENsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICB2YXJcbiAgICAgICAgICB0cmltbWVkQ2xhc3NlcyA9IHN0clRyaW0uY2FsbChlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpXG4gICAgICAgICwgY2xhc3NlcyA9IHRyaW1tZWRDbGFzc2VzID8gdHJpbW1lZENsYXNzZXMuc3BsaXQoL1xccysvKSA6IFtdXG4gICAgICAgICwgaSA9IDBcbiAgICAgICAgLCBsZW4gPSBjbGFzc2VzLmxlbmd0aFxuICAgICAgO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goY2xhc3Nlc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICAgIH07XG4gICAgfVxuICAgICwgY2xhc3NMaXN0UHJvdG8gPSBDbGFzc0xpc3RbcHJvdG9Qcm9wXSA9IFtdXG4gICAgLCBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IENsYXNzTGlzdCh0aGlzKTtcbiAgICB9XG4gIDtcbiAgLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxuICAvLyBvbiBub24tRE9NRXhjZXB0aW9ucy4gRXJyb3IncyB0b1N0cmluZygpIGlzIHN1ZmZpY2llbnQgaGVyZS5cbiAgRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XG4gIGNsYXNzTGlzdFByb3RvLml0ZW0gPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiB0aGlzW2ldIHx8IG51bGw7XG4gIH07XG4gIGNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdG9rZW4gKz0gXCJcIjtcbiAgICByZXR1cm4gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSAhPT0gLTE7XG4gIH07XG4gIGNsYXNzTGlzdFByb3RvLmFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXJcbiAgICAgICAgdG9rZW5zID0gYXJndW1lbnRzXG4gICAgICAsIGkgPSAwXG4gICAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXG4gICAgICAsIHRva2VuXG4gICAgICAsIHVwZGF0ZWQgPSBmYWxzZVxuICAgIDtcbiAgICBkbyB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XG4gICAgICBpZiAoY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5wdXNoKHRva2VuKTtcbiAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgrK2kgPCBsKTtcblxuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH07XG4gIGNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXJcbiAgICAgICAgdG9rZW5zID0gYXJndW1lbnRzXG4gICAgICAsIGkgPSAwXG4gICAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXG4gICAgICAsIHRva2VuXG4gICAgICAsIHVwZGF0ZWQgPSBmYWxzZVxuICAgICAgLCBpbmRleFxuICAgIDtcbiAgICBkbyB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XG4gICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG4gICAgICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKCsraSA8IGwpO1xuXG4gICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuICAgIH1cbiAgfTtcbiAgY2xhc3NMaXN0UHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xuICAgIHRva2VuICs9IFwiXCI7XG5cbiAgICB2YXJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jb250YWlucyh0b2tlbilcbiAgICAgICwgbWV0aG9kID0gcmVzdWx0ID9cbiAgICAgICAgZm9yY2UgIT09IHRydWUgJiYgXCJyZW1vdmVcIlxuICAgICAgOlxuICAgICAgICBmb3JjZSAhPT0gZmFsc2UgJiYgXCJhZGRcIlxuICAgIDtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXSh0b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9XG4gIH07XG4gIGNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmpvaW4oXCIgXCIpO1xuICB9O1xuXG4gIGlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcbiAgICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XG4gICAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyXG4gICAgICAsIGVudW1lcmFibGU6IHRydWVcbiAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuICAgIH0gY2F0Y2ggKGV4KSB7IC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGVudW1lcmFibGU6dHJ1ZVxuICAgICAgaWYgKGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcbiAgICAgICAgY2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iakN0cltwcm90b1Byb3BdLl9fZGVmaW5lR2V0dGVyX18pIHtcbiAgICBlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xuICB9XG5cbiAgfShzZWxmKSk7XG59XG5cbi8qIEJsb2IuanNcbiAqIEEgQmxvYiBpbXBsZW1lbnRhdGlvbi5cbiAqIDIwMTQtMDctMjRcbiAqXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKiBCeSBEZXZpbiBTYW1hcmluLCBodHRwczovL2dpdGh1Yi5jb20vZHNhbWFyaW5cbiAqIExpY2Vuc2U6IFgxMS9NSVRcbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L0Jsb2IuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuICovXG5cbi8qZ2xvYmFsIHNlbGYsIHVuZXNjYXBlICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlLCByZWdleHA6IHRydWUsIGNvbmZ1c2lvbjogdHJ1ZSwgZXM1OiB0cnVlLCB2YXJzOiB0cnVlLCB3aGl0ZTogdHJ1ZSxcbiAgcGx1c3BsdXM6IHRydWUgKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL0Jsb2IuanMvYmxvYi9tYXN0ZXIvQmxvYi5qcyAqL1xuXG4oZnVuY3Rpb24gKHZpZXcpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmlldy5VUkwgPSB2aWV3LlVSTCB8fCB2aWV3LndlYmtpdFVSTDtcblxuICBpZiAodmlldy5CbG9iICYmIHZpZXcuVVJMKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBCbG9iO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICAvLyBJbnRlcm5hbGx5IHdlIHVzZSBhIEJsb2JCdWlsZGVyIGltcGxlbWVudGF0aW9uIHRvIGJhc2UgQmxvYiBvZmYgb2ZcbiAgLy8gaW4gb3JkZXIgdG8gc3VwcG9ydCBvbGRlciBicm93c2VycyB0aGF0IG9ubHkgaGF2ZSBCbG9iQnVpbGRlclxuICB2YXIgQmxvYkJ1aWxkZXIgPSB2aWV3LkJsb2JCdWlsZGVyIHx8IHZpZXcuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgdmlldy5Nb3pCbG9iQnVpbGRlciB8fCAoZnVuY3Rpb24odmlldykge1xuICAgIHZhclxuICAgICAgICBnZXRfY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpLm1hdGNoKC9eXFxbb2JqZWN0XFxzKC4qKVxcXSQvKVsxXTtcbiAgICAgIH1cbiAgICAgICwgRmFrZUJsb2JCdWlsZGVyID0gZnVuY3Rpb24gQmxvYkJ1aWxkZXIoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgfVxuICAgICAgLCBGYWtlQmxvYiA9IGZ1bmN0aW9uIEJsb2IoZGF0YSwgdHlwZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgICwgRkJCX3Byb3RvID0gRmFrZUJsb2JCdWlsZGVyLnByb3RvdHlwZVxuICAgICAgLCBGQl9wcm90byA9IEZha2VCbG9iLnByb3RvdHlwZVxuICAgICAgLCBGaWxlUmVhZGVyU3luYyA9IHZpZXcuRmlsZVJlYWRlclN5bmNcbiAgICAgICwgRmlsZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpc1t0aGlzLm5hbWUgPSB0eXBlXTtcbiAgICAgIH1cbiAgICAgICwgZmlsZV9leF9jb2RlcyA9IChcbiAgICAgICAgICBcIk5PVF9GT1VORF9FUlIgU0VDVVJJVFlfRVJSIEFCT1JUX0VSUiBOT1RfUkVBREFCTEVfRVJSIEVOQ09ESU5HX0VSUiBcIlxuICAgICAgICArIFwiTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSIElOVkFMSURfU1RBVEVfRVJSIFNZTlRBWF9FUlJcIlxuICAgICAgKS5zcGxpdChcIiBcIilcbiAgICAgICwgZmlsZV9leF9jb2RlID0gZmlsZV9leF9jb2Rlcy5sZW5ndGhcbiAgICAgICwgcmVhbF9VUkwgPSB2aWV3LlVSTCB8fCB2aWV3LndlYmtpdFVSTCB8fCB2aWV3XG4gICAgICAsIHJlYWxfY3JlYXRlX29iamVjdF9VUkwgPSByZWFsX1VSTC5jcmVhdGVPYmplY3RVUkxcbiAgICAgICwgcmVhbF9yZXZva2Vfb2JqZWN0X1VSTCA9IHJlYWxfVVJMLnJldm9rZU9iamVjdFVSTFxuICAgICAgLCBVUkwgPSByZWFsX1VSTFxuICAgICAgLCBidG9hID0gdmlldy5idG9hXG4gICAgICAsIGF0b2IgPSB2aWV3LmF0b2JcblxuICAgICAgLCBBcnJheUJ1ZmZlciA9IHZpZXcuQXJyYXlCdWZmZXJcbiAgICAgICwgVWludDhBcnJheSA9IHZpZXcuVWludDhBcnJheVxuXG4gICAgICAsIG9yaWdpbiA9IC9eW1xcdy1dKzpcXC8qXFxbP1tcXHdcXC46LV0rXFxdPyg/OjpbMC05XSspPy9cbiAgICA7XG4gICAgRmFrZUJsb2IuZmFrZSA9IEZCX3Byb3RvLmZha2UgPSB0cnVlO1xuICAgIHdoaWxlIChmaWxlX2V4X2NvZGUtLSkge1xuICAgICAgRmlsZUV4Y2VwdGlvbi5wcm90b3R5cGVbZmlsZV9leF9jb2Rlc1tmaWxlX2V4X2NvZGVdXSA9IGZpbGVfZXhfY29kZSArIDE7XG4gICAgfVxuICAgIC8vIFBvbHlmaWxsIFVSTFxuICAgIGlmICghcmVhbF9VUkwuY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICBVUkwgPSB2aWV3LlVSTCA9IGZ1bmN0aW9uKHVyaSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHVyaV9pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImFcIilcbiAgICAgICAgICAsIHVyaV9vcmlnaW5cbiAgICAgICAgO1xuICAgICAgICB1cmlfaW5mby5ocmVmID0gdXJpO1xuICAgICAgICBpZiAoIShcIm9yaWdpblwiIGluIHVyaV9pbmZvKSkge1xuICAgICAgICAgIGlmICh1cmlfaW5mby5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSBcImRhdGE6XCIpIHtcbiAgICAgICAgICAgIHVyaV9pbmZvLm9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVyaV9vcmlnaW4gPSB1cmkubWF0Y2gob3JpZ2luKTtcbiAgICAgICAgICAgIHVyaV9pbmZvLm9yaWdpbiA9IHVyaV9vcmlnaW4gJiYgdXJpX29yaWdpblsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaV9pbmZvO1xuICAgICAgfTtcbiAgICB9XG4gICAgVVJMLmNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgICAgIHZhclxuICAgICAgICAgIHR5cGUgPSBibG9iLnR5cGVcbiAgICAgICAgLCBkYXRhX1VSSV9oZWFkZXJcbiAgICAgIDtcbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2IgaW5zdGFuY2VvZiBGYWtlQmxvYikge1xuICAgICAgICBkYXRhX1VSSV9oZWFkZXIgPSBcImRhdGE6XCIgKyB0eXBlO1xuICAgICAgICBpZiAoYmxvYi5lbmNvZGluZyA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgIHJldHVybiBkYXRhX1VSSV9oZWFkZXIgKyBcIjtiYXNlNjQsXCIgKyBibG9iLmRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoYmxvYi5lbmNvZGluZyA9PT0gXCJVUklcIikge1xuICAgICAgICAgIHJldHVybiBkYXRhX1VSSV9oZWFkZXIgKyBcIixcIiArIGRlY29kZVVSSUNvbXBvbmVudChibG9iLmRhdGEpO1xuICAgICAgICB9IGlmIChidG9hKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGFfVVJJX2hlYWRlciArIFwiO2Jhc2U2NCxcIiArIGJ0b2EoYmxvYi5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGF0YV9VUklfaGVhZGVyICsgXCIsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoYmxvYi5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWFsX2NyZWF0ZV9vYmplY3RfVVJMKSB7XG4gICAgICAgIHJldHVybiByZWFsX2NyZWF0ZV9vYmplY3RfVVJMLmNhbGwocmVhbF9VUkwsIGJsb2IpO1xuICAgICAgfVxuICAgIH07XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCA9IGZ1bmN0aW9uKG9iamVjdF9VUkwpIHtcbiAgICAgIGlmIChvYmplY3RfVVJMLnN1YnN0cmluZygwLCA1KSAhPT0gXCJkYXRhOlwiICYmIHJlYWxfcmV2b2tlX29iamVjdF9VUkwpIHtcbiAgICAgICAgcmVhbF9yZXZva2Vfb2JqZWN0X1VSTC5jYWxsKHJlYWxfVVJMLCBvYmplY3RfVVJMKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEZCQl9wcm90by5hcHBlbmQgPSBmdW5jdGlvbihkYXRhLyosIGVuZGluZ3MqLykge1xuICAgICAgdmFyIGJiID0gdGhpcy5kYXRhO1xuICAgICAgLy8gZGVjb2RlIGRhdGEgdG8gYSBiaW5hcnkgc3RyaW5nXG4gICAgICBpZiAoVWludDhBcnJheSAmJiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHN0ciA9IFwiXCJcbiAgICAgICAgICAsIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGRhdGEpXG4gICAgICAgICAgLCBpID0gMFxuICAgICAgICAgICwgYnVmX2xlbiA9IGJ1Zi5sZW5ndGhcbiAgICAgICAgO1xuICAgICAgICBmb3IgKDsgaSA8IGJ1Zl9sZW47IGkrKykge1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYmIucHVzaChzdHIpO1xuICAgICAgfSBlbHNlIGlmIChnZXRfY2xhc3MoZGF0YSkgPT09IFwiQmxvYlwiIHx8IGdldF9jbGFzcyhkYXRhKSA9PT0gXCJGaWxlXCIpIHtcbiAgICAgICAgaWYgKEZpbGVSZWFkZXJTeW5jKSB7XG4gICAgICAgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXJTeW5jO1xuICAgICAgICAgIGJiLnB1c2goZnIucmVhZEFzQmluYXJ5U3RyaW5nKGRhdGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhc3luYyBGaWxlUmVhZGVyIHdvbid0IHdvcmsgYXMgQmxvYkJ1aWxkZXIgaXMgc3luY1xuICAgICAgICAgIHRocm93IG5ldyBGaWxlRXhjZXB0aW9uKFwiTk9UX1JFQURBQkxFX0VSUlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRmFrZUJsb2IpIHtcbiAgICAgICAgaWYgKGRhdGEuZW5jb2RpbmcgPT09IFwiYmFzZTY0XCIgJiYgYXRvYikge1xuICAgICAgICAgIGJiLnB1c2goYXRvYihkYXRhLmRhdGEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmVuY29kaW5nID09PSBcIlVSSVwiKSB7XG4gICAgICAgICAgYmIucHVzaChkZWNvZGVVUklDb21wb25lbnQoZGF0YS5kYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5lbmNvZGluZyA9PT0gXCJyYXdcIikge1xuICAgICAgICAgIGJiLnB1c2goZGF0YS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZGF0YSArPSBcIlwiOyAvLyBjb252ZXJ0IHVuc3VwcG9ydGVkIHR5cGVzIHRvIHN0cmluZ3NcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWNvZGUgVVRGLTE2IHRvIGJpbmFyeSBzdHJpbmdcbiAgICAgICAgYmIucHVzaCh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEZCQl9wcm90by5nZXRCbG9iID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBGYWtlQmxvYih0aGlzLmRhdGEuam9pbihcIlwiKSwgdHlwZSwgXCJyYXdcIik7XG4gICAgfTtcbiAgICBGQkJfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgQmxvYkJ1aWxkZXJdXCI7XG4gICAgfTtcbiAgICBGQl9wcm90by5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHR5cGUpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzIDwgMykge1xuICAgICAgICB0eXBlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRmFrZUJsb2IoXG4gICAgICAgICAgdGhpcy5kYXRhLnNsaWNlKHN0YXJ0LCBhcmdzID4gMSA/IGVuZCA6IHRoaXMuZGF0YS5sZW5ndGgpXG4gICAgICAgICwgdHlwZVxuICAgICAgICAsIHRoaXMuZW5jb2RpbmdcbiAgICAgICk7XG4gICAgfTtcbiAgICBGQl9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiW29iamVjdCBCbG9iXVwiO1xuICAgIH07XG4gICAgRkJfcHJvdG8uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5kYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIEZha2VCbG9iQnVpbGRlcjtcbiAgfSh2aWV3KSk7XG5cbiAgdmlldy5CbG9iID0gZnVuY3Rpb24oYmxvYlBhcnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zID8gKG9wdGlvbnMudHlwZSB8fCBcIlwiKSA6IFwiXCI7XG4gICAgdmFyIGJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICBpZiAoYmxvYlBhcnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYmxvYlBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChVaW50OEFycmF5ICYmIGJsb2JQYXJ0c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBidWlsZGVyLmFwcGVuZChibG9iUGFydHNbaV0uYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBidWlsZGVyLmFwcGVuZChibG9iUGFydHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBibG9iID0gYnVpbGRlci5nZXRCbG9iKHR5cGUpO1xuICAgIGlmICghYmxvYi5zbGljZSAmJiBibG9iLndlYmtpdFNsaWNlKSB7XG4gICAgICBibG9iLnNsaWNlID0gYmxvYi53ZWJraXRTbGljZTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2I7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QuX19wcm90b19fO1xuICB9O1xuICB2aWV3LkJsb2IucHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YobmV3IHZpZXcuQmxvYigpKTtcbn0odHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZiB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyB8fCB0aGlzLmNvbnRlbnQgfHwgdGhpcykpO1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuTWVkaXVtRWRpdG9yID0gZmFjdG9yeTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gTWVkaXVtRWRpdG9yKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiB0aGlzLmluaXQoZWxlbWVudHMsIG9wdGlvbnMpO1xufVxuXG5NZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucyA9IHt9O1xuLypqc2hpbnQgdW51c2VkOiB0cnVlICovXG4oZnVuY3Rpb24gKHdpbmRvdykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGNvcHlJbnRvKG92ZXJ3cml0ZSwgZGVzdCkge1xuICAgICAgICB2YXIgcHJvcCxcbiAgICAgICAgICAgIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICBkZXN0ID0gZGVzdCB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VbcHJvcF0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAob3ZlcndyaXRlIHx8IGRlc3QuaGFzT3duUHJvcGVydHkocHJvcCkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9jb250YWluc1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgKGluY2x1ZGluZyBwaGFudG9tKSBkb24ndCByZXR1cm4gdHJ1ZSBmb3IgTm9kZS5jb250YWlucyhjaGlsZClcbiAgICAvLyBpZiBjaGlsZCBpcyBhIHRleHQgbm9kZS4gIERldGVjdCB0aGVzZSBjYXNlcyBoZXJlIGFuZCB1c2UgYSBmYWxsYmFja1xuICAgIC8vIGZvciBjYWxscyB0byBVdGlsLmlzRGVzY2VuZGFudCgpXG4gICAgdmFyIG5vZGVDb250YWluc1dvcmtzV2l0aFRleHROb2RlcyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXN0UGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICB0ZXN0VGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICAgIHRlc3RQYXJlbnQuYXBwZW5kQ2hpbGQodGVzdFRleHQpO1xuICAgICAgICBub2RlQ29udGFpbnNXb3Jrc1dpdGhUZXh0Tm9kZXMgPSB0ZXN0UGFyZW50LmNvbnRhaW5zKHRlc3RUZXh0KTtcbiAgICB9IGNhdGNoIChleGMpIHt9XG5cbiAgICB2YXIgVXRpbCA9IHtcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3OTA3NDQ1L2hvdy10by1kZXRlY3QtaWUxMSNjb21tZW50MzAxNjU4ODhfMTc5MDc1NjJcbiAgICAgICAgLy8gYnkgcmc4OVxuICAgICAgICBpc0lFOiAoKG5hdmlnYXRvci5hcHBOYW1lID09PSAnTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyJykgfHwgKChuYXZpZ2F0b3IuYXBwTmFtZSA9PT0gJ05ldHNjYXBlJykgJiYgKG5ldyBSZWdFeHAoJ1RyaWRlbnQvLipydjooWzAtOV17MSx9Wy4wLTldezAsfSknKS5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpICE9PSBudWxsKSkpLFxuXG4gICAgICAgIGlzRWRnZTogKC9FZGdlXFwvXFxkKy8pLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgIT09IG51bGwsXG5cbiAgICAgICAgLy8gaWYgZmlyZWZveFxuICAgICAgICBpc0ZGOiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xKSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTc1MjA4NC81NjkxMDFcbiAgICAgICAgaXNNYWM6ICh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignTUFDJykgPj0gMCksXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlXG4gICAgICAgIGtleUNvZGU6IHtcbiAgICAgICAgICAgIEJBQ0tTUEFDRTogOCxcbiAgICAgICAgICAgIFRBQjogOSxcbiAgICAgICAgICAgIEVOVEVSOiAxMyxcbiAgICAgICAgICAgIEVTQ0FQRTogMjcsXG4gICAgICAgICAgICBTUEFDRTogMzIsXG4gICAgICAgICAgICBERUxFVEU6IDQ2LFxuICAgICAgICAgICAgSzogNzUsIC8vIEsga2V5Y29kZSwgYW5kIG5vdCBrXG4gICAgICAgICAgICBNOiA3N1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgaXQncyBtZXRhS2V5IG9uIE1hYywgb3IgY3RybEtleSBvbiBub24tTWFjLlxuICAgICAgICAgKiBTZWUgIzU5MVxuICAgICAgICAgKi9cbiAgICAgICAgaXNNZXRhQ3RybEtleTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoKFV0aWwuaXNNYWMgJiYgZXZlbnQubWV0YUtleSkgfHwgKCFVdGlsLmlzTWFjICYmIGV2ZW50LmN0cmxLZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgYXNzb2NpYXRlZCB0byB0aGUgZXZlbnQgaXMgaW5zaWRlIGtleXMgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMDcwNWJlNDc1MDkyYWVkZTFlZGRhZTAxMzE5ZWM5MzFmYjljNjVmYy9zcmMvZXZlbnQuanMjTDQ3My1MNDg0XG4gICAgICAgICAqIEBzZWUgOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS80NDcxNTgyLzU2OTEwMVxuICAgICAgICAgKi9cbiAgICAgICAgaXNLZXk6IGZ1bmN0aW9uIChldmVudCwga2V5cykge1xuICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBVdGlsLmdldEtleUNvZGUoZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBpdCdzIG5vdCBhbiBhcnJheSBsZXQncyBqdXN0IGNvbXBhcmUgc3RyaW5ncyFcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlDb2RlID09PSBrZXlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoLTEgPT09IGtleXMuaW5kZXhPZihrZXlDb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0S2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LndoaWNoO1xuXG4gICAgICAgICAgICAvLyBnZXR0aW5nIHRoZSBrZXkgY29kZSBmcm9tIGV2ZW50XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0ga2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIGtleUNvZGUgPSBldmVudC5jaGFyQ29kZSAhPT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGtleUNvZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmxvY2tDb250YWluZXJFbGVtZW50TmFtZXM6IFtcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIG91ciBlZGl0b3IgZ2VuZXJhdGVzXG4gICAgICAgICAgICAncCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdibG9ja3F1b3RlJywgJ3ByZScsICd1bCcsICdsaScsICdvbCcsXG4gICAgICAgICAgICAvLyBhbGwgb3RoZXIga25vd24gYmxvY2sgZWxlbWVudHNcbiAgICAgICAgICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnY2FudmFzJywgJ2RkJywgJ2RsJywgJ2R0JywgJ2ZpZWxkc2V0JyxcbiAgICAgICAgICAgICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdoZWFkZXInLCAnaGdyb3VwJywgJ21haW4nLCAnbmF2JyxcbiAgICAgICAgICAgICdub3NjcmlwdCcsICdvdXRwdXQnLCAnc2VjdGlvbicsICd2aWRlbycsXG4gICAgICAgICAgICAndGFibGUnLCAndGhlYWQnLCAndGJvZHknLCAndGZvb3QnLCAndHInLCAndGgnLCAndGQnXG4gICAgICAgIF0sXG5cbiAgICAgICAgZW1wdHlFbGVtZW50TmFtZXM6IFsnYnInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdzb3VyY2UnLCAnd2JyJ10sXG5cbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoLyogZGVzdCwgc291cmNlMSwgc291cmNlMiwgLi4uKi8pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW3RydWVdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5SW50by5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHMoLypkZXN0LCBzb3VyY2UxLCBzb3VyY2UyLCAuLi4qLykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbZmFsc2VdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5SW50by5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBDcmVhdGUgYSBsaW5rIGFyb3VuZCB0aGUgcHJvdmlkZWQgdGV4dCBub2RlcyB3aGljaCBtdXN0IGJlIGFkamFjZW50IHRvIGVhY2ggb3RoZXIgYW5kIGFsbCBiZVxuICAgICAgICAgKiBkZXNjZW5kYW50cyBvZiB0aGUgc2FtZSBjbG9zZXN0IGJsb2NrIGNvbnRhaW5lci4gSWYgdGhlIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBtZXQsIHVuZXhwZWN0ZWRcbiAgICAgICAgICogYmVoYXZpb3Igd2lsbCByZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVMaW5rOiBmdW5jdGlvbiAoZG9jdW1lbnQsIHRleHROb2RlcywgaHJlZiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgVXRpbC5tb3ZlVGV4dFJhbmdlSW50b0VsZW1lbnQodGV4dE5vZGVzWzBdLCB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aCAtIDFdLCBhbmNob3IpO1xuICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEdpdmVuIHRoZSBwcm92aWRlZCBtYXRjaCBpbiB0aGUgZm9ybWF0IHtzdGFydDogMSwgZW5kOiAyfSB3aGVyZSBzdGFydCBhbmQgZW5kIGFyZSBpbmRpY2VzIGludG8gdGhlXG4gICAgICAgICAqIHRleHRDb250ZW50IG9mIHRoZSBwcm92aWRlZCBlbGVtZW50IGFyZ3VtZW50LCBtb2RpZnkgdGhlIERPTSBpbnNpZGUgZWxlbWVudCB0byBlbnN1cmUgdGhhdCB0aGUgdGV4dFxuICAgICAgICAgKiBpZGVudGlmaWVkIGJ5IHRoZSBwcm92aWRlZCBtYXRjaCBjYW4gYmUgcmV0dXJuZWQgYXMgdGV4dCBub2RlcyB0aGF0IGNvbnRhaW4gZXhhY3RseSB0aGF0IHRleHQsIHdpdGhvdXRcbiAgICAgICAgICogYW55IGFkZGl0aW9uYWwgdGV4dCBhdCB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgcmV0dXJuZWQgYXJyYXkgb2YgYWRqYWNlbnQgdGV4dCBub2Rlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG9ubHkgRE9NIG1hbmlwdWxhdGlvbiBwZXJmb3JtZWQgYnkgdGhpcyBmdW5jdGlvbiBpcyBzcGxpdHRpbmcgdGhlIHRleHQgbm9kZXMsIG5vbi10ZXh0IG5vZGVzIGFyZVxuICAgICAgICAgKiBub3QgYWZmZWN0ZWQgaW4gYW55IHdheS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRPckNyZWF0ZU1hdGNoaW5nVGV4dE5vZGVzOiBmdW5jdGlvbiAoZG9jdW1lbnQsIGVsZW1lbnQsIG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX0FMTCwgbnVsbCwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIG1hdGNoZWROb2RlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVhY2hlZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gbnVsbCxcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gbnVsbDtcblxuICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50Tm9kZSA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGFydFJlYWNoZWQgJiYgbWF0Y2guc3RhcnQgPCAoY3VycmVudFRleHRJbmRleCArIGN1cnJlbnROb2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFJlYWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IFV0aWwuc3BsaXRTdGFydE5vZGVJZk5lZWRlZChjdXJyZW50Tm9kZSwgbWF0Y2guc3RhcnQsIGN1cnJlbnRUZXh0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwuc3BsaXRFbmROb2RlSWZOZWVkZWQoY3VycmVudE5vZGUsIG5ld05vZGUsIG1hdGNoLmVuZCwgY3VycmVudFRleHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0UmVhY2hlZCAmJiBjdXJyZW50VGV4dEluZGV4ID09PSBtYXRjaC5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBGb3VuZCB0aGUgbm9kZShzKSBjb3JyZXNwb25kaW5nIHRvIHRoZSBsaW5rLiBCcmVhayBvdXQgYW5kIG1vdmUgb24gdG8gdGhlIG5leHQuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRSZWFjaGVkICYmIGN1cnJlbnRUZXh0SW5kZXggPiAobWF0Y2guZW5kICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGVyZm9ybUxpbmtpbmcgb3ZlcnNob3QgdGhlIHRhcmdldCEnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlbi4uLlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0UmVhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZE5vZGVzLnB1c2gobmV3Tm9kZSB8fCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEluZGV4ICs9IGN1cnJlbnROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEluZGV4ICs9IG5ld05vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIG5ld05vZGUgYXMgd2UnbGwgYWxyZWFkeSBoYXZlIHB1c2hlZCBpdCB0byB0aGUgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0UmVhY2hlZCAmJiAobWF0Y2guc3RhcnQgPD0gY3VycmVudFRleHRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UmVhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0UmVhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZE5vZGVzLnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWROb2RlcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBHaXZlbiB0aGUgcHJvdmlkZWQgdGV4dCBub2RlIGFuZCB0ZXh0IGNvb3JkaW5hdGVzLCBzcGxpdCB0aGUgdGV4dCBub2RlIGlmIG5lZWRlZCB0byBtYWtlIGl0IGFsaWduXG4gICAgICAgICAqIHByZWNpc2VseSB3aXRoIHRoZSBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSBVdGlsLmZpbmRPckNyZWF0ZU1hdGNoaW5nVGV4dE5vZGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3BsaXRTdGFydE5vZGVJZk5lZWRlZDogZnVuY3Rpb24gKGN1cnJlbnROb2RlLCBtYXRjaFN0YXJ0SW5kZXgsIGN1cnJlbnRUZXh0SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0SW5kZXggIT09IGN1cnJlbnRUZXh0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudE5vZGUuc3BsaXRUZXh0KG1hdGNoU3RhcnRJbmRleCAtIGN1cnJlbnRUZXh0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICogR2l2ZW4gdGhlIHByb3ZpZGVkIHRleHQgbm9kZSBhbmQgdGV4dCBjb29yZGluYXRlcywgc3BsaXQgdGhlIHRleHQgbm9kZSBpZiBuZWVkZWQgdG8gbWFrZSBpdCBhbGlnblxuICAgICAgICAgKiBwcmVjaXNlbHkgd2l0aCB0aGUgY29vcmRpbmF0ZXMuIFRoZSBuZXdOb2RlIGFyZ3VtZW50IHNob3VsZCBmcm9tIHRoZSByZXN1bHQgb2YgVXRpbC5zcGxpdFN0YXJ0Tm9kZUlmTmVlZGVkLFxuICAgICAgICAgKiBpZiB0aGF0IGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZCBvbiB0aGUgc2FtZSBjdXJyZW50Tm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSBVdGlsLmZpbmRPckNyZWF0ZU1hdGNoaW5nVGV4dE5vZGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3BsaXRFbmROb2RlSWZOZWVkZWQ6IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSwgbmV3Tm9kZSwgbWF0Y2hFbmRJbmRleCwgY3VycmVudFRleHRJbmRleCkge1xuICAgICAgICAgICAgdmFyIHRleHRJbmRleE9mRW5kT2ZGYXJ0aGVzdE5vZGUsXG4gICAgICAgICAgICAgICAgZW5kU3BsaXRQb2ludDtcbiAgICAgICAgICAgIHRleHRJbmRleE9mRW5kT2ZGYXJ0aGVzdE5vZGUgPSBjdXJyZW50VGV4dEluZGV4ICsgKG5ld05vZGUgfHwgY3VycmVudE5vZGUpLm5vZGVWYWx1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAobmV3Tm9kZSA/IGN1cnJlbnROb2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwKSAtXG4gICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICBlbmRTcGxpdFBvaW50ID0gKG5ld05vZGUgfHwgY3VycmVudE5vZGUpLm5vZGVWYWx1ZS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgICAodGV4dEluZGV4T2ZFbmRPZkZhcnRoZXN0Tm9kZSArIDEgLSBtYXRjaEVuZEluZGV4KTtcbiAgICAgICAgICAgIGlmICh0ZXh0SW5kZXhPZkVuZE9mRmFydGhlc3ROb2RlID49IG1hdGNoRW5kSW5kZXggJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHRJbmRleCAhPT0gdGV4dEluZGV4T2ZFbmRPZkZhcnRoZXN0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBlbmRTcGxpdFBvaW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgKG5ld05vZGUgfHwgY3VycmVudE5vZGUpLnNwbGl0VGV4dChlbmRTcGxpdFBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAqIFRha2UgYW4gZWxlbWVudCwgYW5kIGJyZWFrIHVwIGFsbCBvZiBpdHMgdGV4dCBjb250ZW50IGludG8gdW5pcXVlIHBpZWNlcyBzdWNoIHRoYXQ6XG4gICAgICAgICAqIDEpIEFsbCB0ZXh0IGNvbnRlbnQgb2YgdGhlIGVsZW1lbnRzIGFyZSBpbiBzZXBhcmF0ZSBibG9ja3MuIE5vIHBpZWNlIG9mIHRleHQgY29udGVudCBzaG91bGQgc3BhblxuICAgICAgICAgKiAgICBhY3Jvc3MgbXVsdGlwbGUgYmxvY2tzLiBUaGlzIG1lYW5zIG5vIGVsZW1lbnQgcmV0dXJuIGJ5IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGhhdmVcbiAgICAgICAgICogICAgYW55IGJsb2NrcyBhcyBjaGlsZHJlbi5cbiAgICAgICAgICogMikgVGhlIHVuaW9uIG9mIHRoZSB0ZXh0Y29udGVudCBvZiBhbGwgb2YgdGhlIGVsZW1lbnRzIHJldHVybmVkIGhlcmUgY292ZXJzIGFsbFxuICAgICAgICAgKiAgICBvZiB0aGUgdGV4dCB3aXRoaW4gdGhlIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEVYQU1QTEU6XG4gICAgICAgICAqIEluIHRoZSBldmVudCB0aGF0IHdlIGhhdmUgc29tZXRoaW5nIGxpa2U6XG4gICAgICAgICAqXG4gICAgICAgICAqIDxibG9ja3F1b3RlPlxuICAgICAgICAgKiAgIDxwPlNvbWUgVGV4dDwvcD5cbiAgICAgICAgICogICA8b2w+XG4gICAgICAgICAqICAgICA8bGk+TGlzdCBJdGVtIDE8L2xpPlxuICAgICAgICAgKiAgICAgPGxpPkxpc3QgSXRlbSAyPC9saT5cbiAgICAgICAgICogICA8L29sPlxuICAgICAgICAgKiA8L2Jsb2NrcXVvdGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd291bGQgcmV0dXJuIHRoZXNlIGVsZW1lbnRzIGFzIGFuIGFycmF5OlxuICAgICAgICAgKiAgIFsgPHA+U29tZSBUZXh0PC9wPiwgPGxpPkxpc3QgSXRlbSAxPC9saT4sIDxsaT5MaXN0IEl0ZW0gMjwvbGk+IF1cbiAgICAgICAgICpcbiAgICAgICAgICogU2luY2UgdGhlIDxibG9ja3F1b3RlPiBhbmQgPG9sPiBlbGVtZW50cyBjb250YWluIGJsb2NrcyB3aXRoaW4gdGhlbSB0aGV5IGFyZSBub3QgcmV0dXJuZWQuXG4gICAgICAgICAqIFNpbmNlIHRoZSA8cD4gYW5kIDxsaT4ncyBkb24ndCBjb250YWluIGJsb2NrIGVsZW1lbnRzIGFuZCBjb3ZlciBhbGwgdGhlIHRleHQgY29udGVudCBvZiB0aGVcbiAgICAgICAgICogPGJsb2NrcXVvdGU+IGNvbnRhaW5lciwgdGhleSBhcmUgdGhlIGVsZW1lbnRzIHJldHVybmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc3BsaXRCeUJsb2NrRWxlbWVudHM6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMyAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9SZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBibG9ja0VsZW1lbnRRdWVyeSA9IE1lZGl1bUVkaXRvci51dGlsLmJsb2NrQ29udGFpbmVyRWxlbWVudE5hbWVzLmpvaW4oJywnKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDMgfHwgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGJsb2NrRWxlbWVudFF1ZXJ5KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tFbGVtZW50cyA9IGNoaWxkLnF1ZXJ5U2VsZWN0b3JBbGwoYmxvY2tFbGVtZW50UXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXQgPSB0b1JldC5jb25jYXQoTWVkaXVtRWRpdG9yLnV0aWwuc3BsaXRCeUJsb2NrRWxlbWVudHMoY2hpbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvUmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZpbmQgdGhlIG5leHQgbm9kZSBpbiB0aGUgRE9NIHRyZWUgdGhhdCByZXByZXNlbnRzIGFueSB0ZXh0IHRoYXQgaXMgYmVpbmdcbiAgICAgICAgLy8gZGlzcGxheWVkIGRpcmVjdGx5IG5leHQgdG8gdGhlIHRhcmdldE5vZGUgKHBhc3NlZCBhcyBhbiBhcmd1bWVudClcbiAgICAgICAgLy8gVGV4dCB0aGF0IGFwcGVhcnMgZGlyZWN0bHkgbmV4dCB0byB0aGUgY3VycmVudCBub2RlIGNhbiBiZTpcbiAgICAgICAgLy8gIC0gQSBzaWJsaW5nIHRleHQgbm9kZVxuICAgICAgICAvLyAgLSBBIGRlc2NlbmRhbnQgb2YgYSBzaWJsaW5nIGVsZW1lbnRcbiAgICAgICAgLy8gIC0gQSBzaWJsaW5nIHRleHQgbm9kZSBvZiBhbiBhbmNlc3RvclxuICAgICAgICAvLyAgLSBBIGRlc2NlbmRhbnQgb2YgYSBzaWJsaW5nIGVsZW1lbnQgb2YgYW4gYW5jZXN0b3JcbiAgICAgICAgZmluZEFkamFjZW50VGV4dE5vZGVXaXRoQ29udGVudDogZnVuY3Rpb24gZmluZEFkamFjZW50VGV4dE5vZGVXaXRoQ29udGVudChyb290Tm9kZSwgdGFyZ2V0Tm9kZSwgb3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgdmFyIHBhc3RUYXJnZXQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSxcbiAgICAgICAgICAgICAgICBub2RlSXRlcmF0b3IgPSBvd25lckRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihyb290Tm9kZSwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gVXNlIGEgbmF0aXZlIE5vZGVJdGVyYXRvciB0byBpdGVyYXRlIG92ZXIgYWxsIHRoZSB0ZXh0IG5vZGVzIHRoYXQgYXJlIGRlc2NlbmRhbnRzXG4gICAgICAgICAgICAvLyBvZiB0aGUgcm9vdE5vZGUuICBPbmNlIHBhc3QgdGhlIHRhcmdldE5vZGUsIGNob29zZSB0aGUgZmlyc3Qgbm9uLWVtcHR5IHRleHQgbm9kZVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Tm9kZSA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXN0VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROb2RlLm5vZGVUeXBlID09PSAzICYmIG5leHROb2RlLm5vZGVWYWx1ZSAmJiBuZXh0Tm9kZS5ub2RlVmFsdWUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGaW5kIGFuIGVsZW1lbnQncyBwcmV2aW91cyBzaWJsaW5nIHdpdGhpbiBhIG1lZGl1bS1lZGl0b3IgZWxlbWVudFxuICAgICAgICAvLyBJZiBvbmUgZG9lc24ndCBleGlzdCwgZmluZCB0aGUgY2xvc2VzdCBhbmNlc3RvcidzIHByZXZpb3VzIHNpYmxpbmdcbiAgICAgICAgZmluZFByZXZpb3VzU2libGluZzogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKCFwcmV2aW91c1NpYmxpbmcgJiYgIVV0aWwuaXNNZWRpdW1FZGl0b3JFbGVtZW50KG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRGVzY2VuZGFudDogZnVuY3Rpb24gaXNEZXNjZW5kYW50KHBhcmVudCwgY2hpbGQsIGNoZWNrRXF1YWxpdHkpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFjaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhY2hlY2tFcXVhbGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHBhcmVudCBpcyBub3QgYW4gZWxlbWVudCwgaXQgY2FuJ3QgaGF2ZSBhbnkgZGVzY2VuZGFudHNcbiAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZUNvbnRhaW5zV29ya3NXaXRoVGV4dE5vZGVzIHx8IGNoaWxkLm5vZGVUeXBlICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlXG4gICAgICAgIGlzRWxlbWVudDogZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgICAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZVxuICAgICAgICB0aHJvdHRsZTogZnVuY3Rpb24gKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgICAgIHZhciBUSFJPVFRMRV9JTlRFUlZBTCA9IDUwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSAwLFxuICAgICAgICAgICAgICAgIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghd2FpdCAmJiB3YWl0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FpdCA9IFRIUk9UVExFX0lOVEVSVkFMO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYXZlcnNlVXA6IGZ1bmN0aW9uIChjdXJyZW50LCB0ZXN0RWxlbWVudEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdEVsZW1lbnRGdW5jdGlvbihjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHRyYXZlcnNlIHVwd2FyZHMgcGFzdCB0aGUgbmVhcmVzdCBjb250YWluaW5nIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc01lZGl1bUVkaXRvckVsZW1lbnQoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWxFbnRpdGllczogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgLy8gY29udmVydHMgc3BlY2lhbCBjaGFyYWN0ZXJzIChsaWtlIDwpIGludG8gdGhlaXIgZXNjYXBlZC9lbmNvZGVkIHZhbHVlcyAobGlrZSAmbHQ7KS5cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBzaG93IHRvIGRpc3BsYXkgdGhlIHN0cmluZyB3aXRob3V0IHRoZSBicm93c2VyIHJlYWRpbmcgaXQgYXMgSFRNTC5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjY5MDc1Mi9pbnNlcnQtaHRtbC1hdC1jYXJldC1pbi1hLWNvbnRlbnRlZGl0YWJsZS1kaXZcbiAgICAgICAgaW5zZXJ0SFRNTENvbW1hbmQ6IGZ1bmN0aW9uIChkb2MsIGh0bWwpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24sIHJhbmdlLCBlbCwgZnJhZ21lbnQsIG5vZGUsIGxhc3ROb2RlLCB0b1JlcGxhY2UsXG4gICAgICAgICAgICAgICAgcmVzID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgZWNBcmdzID0gWydpbnNlcnRIVE1MJywgZmFsc2UsIGh0bWxdO1xuXG4gICAgICAgICAgICAvKiBFZGdlJ3MgaW1wbGVtZW50YXRpb24gb2YgaW5zZXJ0SFRNTCBpcyBqdXN0IGJ1Z2d5IHJpZ2h0IG5vdzpcbiAgICAgICAgICAgICAqIC0gRG9lc24ndCBhbGxvdyBsZWFkaW5nIHdoaXRlIHNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gZWxlbWVudFxuICAgICAgICAgICAgICogLSBGb3VuZCBhIGNhc2Ugd2hlbiBhIDxmb250IHNpemU9XCIyXCI+IHRhZyB3YXMgaW5zZXJ0ZWQgd2hlbiBjYWxsaW5nIGFsaWduQ2VudGVyIGluc2lkZSBhIGJsb2NrcXVvdGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGVyZSBhcmUgbGlrZWx5IG90aGVyIGJ1Z3MsIHRoZXNlIGFyZSBqdXN0IHRoZSBvbmVzIHdlIGZvdW5kIHNvIGZhci5cbiAgICAgICAgICAgICAqIEZvciBub3csIGxldCdzIGp1c3QgdXNlIHRoZSBzYW1lIGZhbGxiYWNrIHdlIGRpZCBmb3IgSUVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFNZWRpdW1FZGl0b3IudXRpbC5pc0VkZ2UgJiYgZG9jLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCgnaW5zZXJ0SFRNTCcpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5leGVjQ29tbWFuZC5hcHBseShkb2MsIGVjQXJncyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBkb2MuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgIHRvUmVwbGFjZSA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3lhYndlL21lZGl1bS1lZGl0b3IvaXNzdWVzLzc0OFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYW4gZW1wdHkgZWRpdG9yIGVsZW1lbnQsIGNyZWF0ZSBhIHRlbXBvcmFyeSB0ZXh0IG5vZGUgaW5zaWRlIG9mIHRoZSBlZGl0b3JcbiAgICAgICAgICAgICAgICAvLyBhbmQgc2VsZWN0IGl0IHNvIHRoYXQgd2UgZG9uJ3QgZGVsZXRlIHRoZSBlZGl0b3IgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudCh0b1JlcGxhY2UpICYmICF0b1JlcGxhY2UuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlKHRvUmVwbGFjZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoJycpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodG9SZXBsYWNlLm5vZGVUeXBlID09PSAzICYmIHJhbmdlLnN0YXJ0T2Zmc2V0ID09PSAwICYmIHJhbmdlLmVuZE9mZnNldCA9PT0gdG9SZXBsYWNlLm5vZGVWYWx1ZS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodG9SZXBsYWNlLm5vZGVUeXBlICE9PSAzICYmIHRvUmVwbGFjZS5pbm5lckhUTUwgPT09IHJhbmdlLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSByYW5nZSBjb3ZlcnMgbWF4aW11bSBhbW91bnQgb2Ygbm9kZXMgYXMgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgbW92aW5nIHVwIHRoZSBET00gYW5kIHNlbGVjdGluZyBhbmNlc3RvcnMgd2hvc2Ugb25seSBjaGlsZCBpcyB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudCh0b1JlcGxhY2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXBsYWNlLnBhcmVudE5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1JlcGxhY2UucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudCh0b1JlcGxhY2UucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVwbGFjZSA9IHRvUmVwbGFjZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGUodG9SZXBsYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcblxuICAgICAgICAgICAgICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Tm9kZSA9IGZyYWdtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGZyYWdtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBzZWxlY3Rpb246XG4gICAgICAgICAgICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKGxhc3ROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3lhYndlL21lZGl1bS1lZGl0b3IvaXNzdWVzLzk5MlxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbW9uaXRvcmluZyBjYWxscyB0byBleGVjQ29tbWFuZCwgbm90aWZ5IGxpc3RlbmVycyBhcyBpZiBhIHJlYWwgY2FsbCBoYWQgaGFwcGVuZWRcbiAgICAgICAgICAgIGlmIChkb2MuZXhlY0NvbW1hbmQuY2FsbExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZC5jYWxsTGlzdGVuZXJzKGVjQXJncywgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhlY0Zvcm1hdEJsb2NrOiBmdW5jdGlvbiAoZG9jLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHRvcCBsZXZlbCBibG9jayBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgdmFyIGJsb2NrQ29udGFpbmVyID0gVXRpbC5nZXRUb3BCbG9ja0NvbnRhaW5lcihNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvblN0YXJ0KGRvYykpLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGJsb2NrcXVvdGVcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnYmxvY2txdW90ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJsb2NrQ29udGFpbmVyLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYmxvY2txdW90ZSBoYXMgYSBibG9jayBlbGVtZW50IGFzIGEgY2hpbGQgKG5lc3RlZCBibG9ja3MpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLnNvbWUoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuaXNCbG9ja0NvbnRhaW5lcihjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkYgaGFuZGxlcyBibG9ja3F1b3RlIGRpZmZlcmVudGx5IG9uIGZvcm1hdEJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd2luZyBuZXN0aW5nLCB3ZSBuZWVkIHRvIHVzZSBvdXRkZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1JpY2gtVGV4dF9FZGl0aW5nX2luX01vemlsbGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2MuZXhlY0NvbW1hbmQoJ291dGRlbnQnLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIElFIGJsb2NrcXVvdGUgbmVlZHMgdG8gYmUgY2FsbGVkIGFzIGluZGVudFxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxNjIyMy9yaWNoLXRleHQtZWRpdG9yLXdpdGgtYmxvY2txdW90ZS1mdW5jdGlvbi8xODIxNzc3IzE4MjE3NzdcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc0lFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2MuZXhlY0NvbW1hbmQoJ2luZGVudCcsIGZhbHNlLCB0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBibG9ja0NvbnRhaW5lciBpcyBhbHJlYWR5IHRoZSBlbGVtZW50IHR5cGUgYmVpbmcgcGFzc2VkIGluXG4gICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyAndW5kbycgZm9ybWF0dGluZyBhbmQganVzdCBjb252ZXJ0IGl0IHRvIGEgPHA+XG4gICAgICAgICAgICBpZiAoYmxvY2tDb250YWluZXIgJiYgdGFnTmFtZSA9PT0gYmxvY2tDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAncCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gSUUgd2UgbmVlZCB0byBhZGQgPD4gdG8gaGVhZGluZyBlbGVtZW50c1xuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDc0MTgzMS9leGVjY29tbWFuZC1mb3JtYXRibG9jay1oZWFkaW5ncy1pbi1pZVxuICAgICAgICAgICAgaWYgKFV0aWwuaXNJRSkge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnPCcgKyB0YWdOYW1lICsgJz4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIEZGLCBJRSBhbmQgRWRnZSwgd2UgaGF2ZSB0byBoYW5kbGUgYmxvY2txdW90ZSBub2RlIHNlcGVyYXRlbHkgYXMgJ2Zvcm1hdGJsb2NrJyBkb2VzIG5vdCB3b3JrLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2V4ZWNDb21tYW5kI0NvbW1hbmRzXG4gICAgICAgICAgICBpZiAoYmxvY2tDb250YWluZXIgJiYgYmxvY2tDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Jsb2NrcXVvdGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIElFLCBqdXN0IHVzZSBvdXRkZW50XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNJRSAmJiB0YWdOYW1lID09PSAnPHA+Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmV4ZWNDb21tYW5kKCdvdXRkZW50JywgZmFsc2UsIHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvciBGaXJlZm94IGFuZCBFZGdlLCBtYWtlIHN1cmUgdGhlcmUncyBhIG5lc3RlZCBibG9jayBlbGVtZW50IGJlZm9yZSBjYWxsaW5nIG91dGRlbnRcbiAgICAgICAgICAgICAgICBpZiAoKFV0aWwuaXNGRiB8fCBVdGlsLmlzRWRnZSkgJiYgdGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChibG9ja0NvbnRhaW5lci5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHNvbWUgbm9uLWJsb2NrIGVsZW1lbnRzIHdlIG5lZWQgdG8gd3JhcCBldmVyeXRoaW5nIGluIGEgPHA+IGJlZm9yZSB3ZSBvdXRkZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLnNvbWUoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFVdGlsLmlzQmxvY2tDb250YWluZXIoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZCgnZm9ybWF0QmxvY2snLCBmYWxzZSwgdGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5leGVjQ29tbWFuZCgnb3V0ZGVudCcsIGZhbHNlLCB0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb2MuZXhlY0NvbW1hbmQoJ2Zvcm1hdEJsb2NrJywgZmFsc2UsIHRhZ05hbWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGFyZ2V0IHRvIGJsYW5rIG9uIHRoZSBnaXZlbiBlbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IG5vdCBzdXJlIGlmIHRoaXMgc2hvdWxkIGJlIGhlcmVcbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBjcmVhdGluZyBhIGxpbmsgKHVzaW5nIGNvcmUgLT4gY3JlYXRlTGluaykgdGhlIHNlbGVjdGlvbiByZXR1cm5lZCBieSBGaXJlZm94IHdpbGwgYmUgdGhlIHBhcmVudCBvZiB0aGUgY3JlYXRlZCBsaW5rXG4gICAgICAgICAqIGluc3RlYWQgb2YgdGhlIGNyZWF0ZWQgbGluayBpdHNlbGYgKGFzIGl0IGlzIGZvciBDaHJvbWUgZm9yIGV4YW1wbGUpLCBzbyB3ZSByZXRyaWV2ZSBhbGwgXCJhXCIgY2hpbGRyZW4gdG8gZ3JhYiB0aGUgZ29vZCBvbmUgYnlcbiAgICAgICAgICogdXNpbmcgYGFuY2hvclVybGAgdG8gZW5zdXJlIHRoYXQgd2UgYXJlIGFkZGluZyB0YXJnZXQ9XCJfYmxhbmtcIiBvbiB0aGUgZ29vZCBvbmUuXG4gICAgICAgICAqIFRoaXMgaXNuJ3QgYSBidWxsZXRwcm9vZiBzb2x1dGlvbiBhbnl3YXkgLi5cbiAgICAgICAgICovXG4gICAgICAgIHNldFRhcmdldEJsYW5rOiBmdW5jdGlvbiAoZWwsIGFuY2hvclVybCkge1xuICAgICAgICAgICAgdmFyIGksIHVybCA9IGFuY2hvclVybCB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICBlbC50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gdXJsIHx8IHVybCA9PT0gZWxbaV0uYXR0cmlidXRlcy5ocmVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbFtpXS50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBleHBsaWNpdGx5IHJlbW92ZSB0aGUgdGFyZ2V0PSdfYmxhbmsnIGFzIEZGIGhvbGRzIG9uIHRvIF9ibGFuayB2YWx1ZSBldmVuXG4gICAgICAgICAqIGFmdGVyIHVuY2hlY2tpbmcgdGhlIGNoZWNrYm94IG9uIGFuY2hvciBmb3JtXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVUYXJnZXRCbGFuazogZnVuY3Rpb24gKGVsLCBhbmNob3JVcmwpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5jaG9yVXJsID09PSBlbFtpXS5hdHRyaWJ1dGVzLmhyZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2xhc3NUb0FuY2hvcnM6IGZ1bmN0aW9uIChlbCwgYnV0dG9uQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGo7XG4gICAgICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNMaXN0SXRlbTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdsaScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHdoaWxlICh0YWdOYW1lID09PSAnbGknIHx8ICghVXRpbC5pc0Jsb2NrQ29udGFpbmVyKHBhcmVudE5vZGUpICYmIHRhZ05hbWUgIT09ICdkaXYnKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbkxpc3RET006IGZ1bmN0aW9uIChvd25lckRvY3VtZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGlzdCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKGxpc3QucGFyZW50RWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncCcpIHsgLy8geWVzIHdlIG5lZWQgdG8gY2xlYW4gdXBcbiAgICAgICAgICAgICAgICBVdGlsLnVud3JhcChsaXN0LnBhcmVudEVsZW1lbnQsIG93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBjdXJzb3IgYXQgdGhlIGVuZCBvZiB0aGUgdGV4dCBpbnNpZGUgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyBmb3Igc29tZSB1bmtub3duIHJlYXNvbiwgdGhlIGN1cnNvciBpcyBtb3ZlZCB0byBlbmQgb2YgdGhlIFwidmlzdWFsXCIgbGluZVxuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24ubW92ZUN1cnNvcihvd25lckRvY3VtZW50LCBlbGVtZW50LmZpcnN0Q2hpbGQsIGVsZW1lbnQuZmlyc3RDaGlsZC50ZXh0Q29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIHNwbGl0RE9NVHJlZVxuICAgICAgICAgKlxuICAgICAgICAgKiBHaXZlbiBhIHJvb3QgZWxlbWVudCBzb21lIGRlc2NlbmRhbnQgZWxlbWVudCwgc3BsaXQgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgKiBpbnRvIGl0cyBvd24gZWxlbWVudCBjb250YWluaW5nIHRoZSBkZXNjZW5kYW50IGVsZW1lbnQgYW5kIGFsbCBlbGVtZW50c1xuICAgICAgICAgKiBvbiB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBkZXNjZW5kYW50ICgncmlnaHQnIGlzIGRlZmF1bHQpXG4gICAgICAgICAqXG4gICAgICAgICAqIGV4YW1wbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgPGRpdj5cbiAgICAgICAgICogICAgICAvICAgIHwgICBcXFxuICAgICAgICAgKiAgPHNwYW4+IDxzcGFuPiA8c3Bhbj5cbiAgICAgICAgICogICAvIFxcICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAgKiAgMSAgIDIgIDMgICA0ICA1ICAgNlxuICAgICAgICAgKlxuICAgICAgICAgKiAgSWYgSSB3YW50ZWQgdG8gc3BsaXQgdGhpcyB0cmVlIGdpdmVuIHRoZSA8ZGl2PiBhcyB0aGUgcm9vdCBhbmQgXCI0XCIgYXMgdGhlIGxlYWZcbiAgICAgICAgICogIHRoZSByZXN1bHQgd291bGQgYmUgKHRoZSBwcmltZSAnIG1hcmtzIGluZGljYXRlcyBub2RlcyB0aGF0IGFyZSBjcmVhdGVkIGFzIGNsb25lcyk6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgU1BMSVRUSU5HIE9GRiAnUklHSFQnIFRSRUUgICAgICAgU1BMSVRUSU5HIE9GRiAnTEVGVCcgVFJFRVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgPGRpdj4gICAgICAgICAgICA8ZGl2PicgICAgICAgICAgICAgIDxkaXY+JyAgICAgIDxkaXY+XG4gICAgICAgICAqICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICB8XG4gICAgICAgICAqIDxzcGFuPiA8c3Bhbj4gICA8c3Bhbj4nIDxzcGFuPiAgICAgICA8c3Bhbj4gPHNwYW4+ICAgPHNwYW4+XG4gICAgICAgICAqICAgLyBcXCAgICB8ICAgICAgICB8ICAgICAgLyBcXCAgICAgICAgICAgL1xcICAgICAvXFwgICAgICAgL1xcXG4gICAgICAgICAqICAxICAgMiAgIDMgICAgICAgIDQgICAgIDUgICA2ICAgICAgICAgMSAgMiAgIDMgIDQgICAgIDUgIDZcbiAgICAgICAgICpcbiAgICAgICAgICogIFRoZSBhYm92ZSBleGFtcGxlIHJlcHJlc2VudHMgc3BsaXR0aW5nIG9mZiB0aGUgJ3JpZ2h0JyBvciAnbGVmdCcgcGFydCBvZiBhIHRyZWUsIHdoZXJlXG4gICAgICAgICAqICB0aGUgPGRpdj4nIHdvdWxkIGJlIHJldHVybmVkIGFzIGFuIGVsZW1lbnQgbm90IGFwcGVuZGVkIHRvIHRoZSBET00sIGFuZCB0aGUgPGRpdj5cbiAgICAgICAgICogIHdvdWxkIHJlbWFpbiBpbiBwbGFjZSB3aGVyZSBpdCB3YXNcbiAgICAgICAgICpcbiAgICAgICAgKi9cbiAgICAgICAgc3BsaXRPZmZET01UcmVlOiBmdW5jdGlvbiAocm9vdE5vZGUsIGxlYWZOb2RlLCBzcGxpdExlZnQpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdE9uTm9kZSA9IGxlYWZOb2RlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWROb2RlID0gbnVsbCxcbiAgICAgICAgICAgICAgICBzcGxpdFJpZ2h0ID0gIXNwbGl0TGVmdDtcblxuICAgICAgICAgICAgLy8gbG9vcCB1bnRpbCB3ZSBoaXQgdGhlIHJvb3RcbiAgICAgICAgICAgIHdoaWxlIChzcGxpdE9uTm9kZSAhPT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhcmVudCA9IHNwbGl0T25Ob2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudCA9IGN1cnJQYXJlbnQuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IChzcGxpdFJpZ2h0ID8gc3BsaXRPbk5vZGUgOiBjdXJyUGFyZW50LmZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRMYXN0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcmVudCBlbGVtZW50IHdoaWNoIGlzIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgcGFyZW50XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBzcGxpdHRpbmcgcmlnaHQsIGFkZCBwcmV2aW91cyBjcmVhdGVkIGVsZW1lbnQgYmVmb3JlIHNpYmxpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGxlZnQsIGFkZCBwcmV2aW91cyBjcmVhdGVkIGVsZW1lbnQgbGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kTGFzdCA9IGNyZWF0ZWROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyZWF0ZWROb2RlID0gbmV3UGFyZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSB0YXJnZXROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0aGUgJ3NwbGl0Tm9kZSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgPT09IHNwbGl0T25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldE5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIG5vZGUgd2UncmUgc3BsaXR0aW5nIG9uLCBpZiBpdCBoYXMgY2hpbGRyZW4sIHdlIG5lZWQgdG8gY2xvbmUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbm90IGp1c3QgbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB0YXJnZXROb2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0aW5nIHNwbGl0IG5vZGUgaGFzIGNvbnRlbnQsIGFkZCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkTm9kZS5hcHBlbmRDaGlsZCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IChzcGxpdFJpZ2h0ID8gc2libGluZyA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGdlbmVyYWwgY2FzZSwganVzdCByZW1vdmUgdGhlIGVsZW1lbnQgYW5kIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB0byB0aGUgc3BsaXQgdHJlZSBpZiBpdCBjb250YWlucyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlLmhhc0NoaWxkTm9kZXMoKSB8fCB0YXJnZXROb2RlLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZE5vZGUuYXBwZW5kQ2hpbGQodGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGFuIGVsZW1lbnQgd2Ugd2FudGVkIHRvIGFwcGVuZCBhdCB0aGUgZW5kLCBkbyB0aGF0IG5vd1xuICAgICAgICAgICAgICAgIGlmIChhcHBlbmRMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWROb2RlLmFwcGVuZENoaWxkKGFwcGVuZExhc3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNwbGl0T25Ob2RlID0gY3VyclBhcmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZWROb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVUZXh0UmFuZ2VJbnRvRWxlbWVudDogZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbmV3RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCFzdGFydE5vZGUgfHwgIWVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb290Tm9kZSA9IFV0aWwuZmluZENvbW1vblJvb3Qoc3RhcnROb2RlLCBlbmROb2RlKTtcbiAgICAgICAgICAgIGlmICghcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmROb2RlID09PSBzdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHN0YXJ0Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHRlbXAucmVtb3ZlQ2hpbGQoc3RhcnROb2RlKTtcbiAgICAgICAgICAgICAgICBuZXdFbGVtZW50LmFwcGVuZENoaWxkKHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgc2libGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQuaGFzQ2hpbGROb2RlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgcm9vdENoaWxkcmVuIGFycmF5IHdoaWNoIGluY2x1ZGVzIGFsbCB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHdlIGNhcmUgYWJvdXRcbiAgICAgICAgICAgIHZhciByb290Q2hpbGRyZW4gPSBbXSxcbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIGxhc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5leHROb2RlID0gcm9vdE5vZGUuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNEZXNjZW5kYW50KG5leHROb2RlLCBzdGFydE5vZGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENoaWxkID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc0Rlc2NlbmRhbnQobmV4dE5vZGUsIGVuZE5vZGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdENoaWxkcmVuLnB1c2gobmV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWZ0ZXJMYXN0ID0gbGFzdENoaWxkLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcm9vdE5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgICAgIC8vIGJ1aWxkIHVwIGZyYWdtZW50IG9uIHN0YXJ0Tm9kZSBzaWRlIG9mIHRyZWVcbiAgICAgICAgICAgIGlmIChmaXJzdENoaWxkID09PSBzdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKFV0aWwuc3BsaXRPZmZET01UcmVlKGZpcnN0Q2hpbGQsIHN0YXJ0Tm9kZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgYW55IGVsZW1lbnRzIGJldHdlZW4gZmlyc3RDaGlsZCAmIGxhc3RDaGlsZFxuICAgICAgICAgICAgcm9vdENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYnVpbGQgdXAgZnJhZ21lbnQgb24gZW5kTm9kZSBzaWRlIG9mIHRoZSB0cmVlXG4gICAgICAgICAgICBpZiAobGFzdENoaWxkID09PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgbGFzdENoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChsYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChVdGlsLnNwbGl0T2ZmRE9NVHJlZShsYXN0Q2hpbGQsIGVuZE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGZyYWdtZW50IGludG8gcGFzc2VkIGluIGVsZW1lbnRcbiAgICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXG4gICAgICAgICAgICBpZiAobGFzdENoaWxkLnBhcmVudE5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGFzdCBjaGlsZCBpcyBpbiB0aGUgcm9vdCwgaW5zZXJ0IG5ld0VsZW1lbnQgaW4gZnJvbnQgb2YgaXRcbiAgICAgICAgICAgICAgICByb290Tm9kZS5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgbGFzdENoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXJMYXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGFzdCBjaGlsZCB3YXMgcmVtb3ZlZCwgYnV0IGl0IGhhZCBhIHNpYmxpbmcsIGluc2VydCBpbiBmcm9udCBvZiBpdFxuICAgICAgICAgICAgICAgIHJvb3ROb2RlLmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBhZnRlckxhc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsYXN0Q2hpbGQgd2FzIHJlbW92ZWQgYW5kIHdhcyB0aGUgbGFzdCBhY3R1YWwgZWxlbWVudCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgICAgIHJvb3ROb2RlLmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudC5oYXNDaGlsZE5vZGVzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogYmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjE4MzA2OSAqL1xuICAgICAgICBkZXB0aE9mTm9kZTogZnVuY3Rpb24gKGluTm9kZSkge1xuICAgICAgICAgICAgdmFyIHRoZURlcHRoID0gMCxcbiAgICAgICAgICAgICAgICBub2RlID0gaW5Ob2RlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgdGhlRGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGVEZXB0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5kQ29tbW9uUm9vdDogZnVuY3Rpb24gKGluTm9kZTEsIGluTm9kZTIpIHtcbiAgICAgICAgICAgIHZhciBkZXB0aDEgPSBVdGlsLmRlcHRoT2ZOb2RlKGluTm9kZTEpLFxuICAgICAgICAgICAgICAgIGRlcHRoMiA9IFV0aWwuZGVwdGhPZk5vZGUoaW5Ob2RlMiksXG4gICAgICAgICAgICAgICAgbm9kZTEgPSBpbk5vZGUxLFxuICAgICAgICAgICAgICAgIG5vZGUyID0gaW5Ob2RlMjtcblxuICAgICAgICAgICAgd2hpbGUgKGRlcHRoMSAhPT0gZGVwdGgyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoMSA+IGRlcHRoMikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMSA9IG5vZGUxLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoMSAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgyIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAobm9kZTEgIT09IG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgbm9kZTEgPSBub2RlMS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUxO1xuICAgICAgICB9LFxuICAgICAgICAvKiBFTkQgLSBiYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82MTgzMDY5ICovXG5cbiAgICAgICAgaXNFbGVtZW50QXRCZWdpbm5pbmdPZkJsb2NrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHRleHRWYWwsXG4gICAgICAgICAgICAgICAgc2libGluZztcbiAgICAgICAgICAgIHdoaWxlICghVXRpbC5pc0Jsb2NrQ29udGFpbmVyKG5vZGUpICYmICFVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBub2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzaWJsaW5nID0gc2libGluZy5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZhbCA9IHNpYmxpbmcubm9kZVR5cGUgPT09IDMgPyBzaWJsaW5nLm5vZGVWYWx1ZSA6IHNpYmxpbmcudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0VmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNNZWRpdW1FZGl0b3JFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUgJiYgISFlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1tZWRpdW0tZWRpdG9yLWVsZW1lbnQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250YWluZXJFZGl0b3JFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwudHJhdmVyc2VVcChlbGVtZW50LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQmxvY2tDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSAzICYmIFV0aWwuYmxvY2tDb250YWluZXJFbGVtZW50TmFtZXMuaW5kZXhPZihlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpICE9PSAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiBGaW5kcyB0aGUgY2xvc2VzdCBhbmNlc3RvciB3aGljaCBpcyBhIGJsb2NrIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAqIElmIGVsZW1lbnQgaXMgd2l0aGluIGVkaXRvciBlbGVtZW50IGJ1dCBub3Qgd2l0aGluIGFueSBvdGhlciBibG9jayBlbGVtZW50LFxuICAgICAgICAgKiB0aGUgZWRpdG9yIGVsZW1lbnQgaXMgcmV0dXJuZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldENsb3Nlc3RCbG9ja0NvbnRhaW5lcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlsLnRyYXZlcnNlVXAobm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5pc0Jsb2NrQ29udGFpbmVyKG5vZGUpIHx8IFV0aWwuaXNNZWRpdW1FZGl0b3JFbGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogRmluZHMgaGlnaGVzdCBsZXZlbCBhbmNlc3RvciBlbGVtZW50IHdoaWNoIGlzIGEgYmxvY2sgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICogSWYgZWxlbWVudCBpcyB3aXRoaW4gZWRpdG9yIGVsZW1lbnQgYnV0IG5vdCB3aXRoaW4gYW55IG90aGVyIGJsb2NrIGVsZW1lbnQsXG4gICAgICAgICAqIHRoZSBlZGl0b3IgZWxlbWVudCBpcyByZXR1cm5lZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VG9wQmxvY2tDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdG9wQmxvY2sgPSBVdGlsLmlzQmxvY2tDb250YWluZXIoZWxlbWVudCkgPyBlbGVtZW50IDogZmFsc2U7XG4gICAgICAgICAgICBVdGlsLnRyYXZlcnNlVXAoZWxlbWVudCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNCbG9ja0NvbnRhaW5lcihlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQmxvY2sgPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0b3BCbG9jayAmJiBVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQmxvY2sgPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvcEJsb2NrO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEZpcnN0U2VsZWN0YWJsZUxlYWZOb2RlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBzZXQgdGhlIHNlbGVjdGlvbiB0byBhbiBlbGVtZW50IHRoYXQgY2FuJ3QgaGF2ZSBjaGlsZHJlbiwgdGhpcyBtZXNzZXMgdXAgR2Vja28uXG4gICAgICAgICAgICBlbGVtZW50ID0gVXRpbC50cmF2ZXJzZVVwKGVsZW1lbnQsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlsLmVtcHR5RWxlbWVudE5hbWVzLmluZGV4T2YoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZWxlY3RpbmcgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHRhYmxlIGRvZXNuJ3Qgd29yayBpbiBQaGFudG9tSlMuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2VsbCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGgsIHRkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZmlyc3RDZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBnZXRGaXJzdFRleHROb2RlIEFORCBfZ2V0Rmlyc3RUZXh0Tm9kZSB3aGVuIGp1bXBpbmcgaW4gNi4wLjAgKG5vIGNvZGUgcmVmZXJlbmNlcylcbiAgICAgICAgZ2V0Rmlyc3RUZXh0Tm9kZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIFV0aWwud2FybignZ2V0Rmlyc3RUZXh0Tm9kZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjAuMCcpO1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwuX2dldEZpcnN0VGV4dE5vZGUoZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEZpcnN0VGV4dE5vZGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IFV0aWwuX2dldEZpcnN0VGV4dE5vZGUoZWxlbWVudC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuc3VyZVVybEhhc1Byb3RvY29sOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaHR0cDovLycgKyB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdhcm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3cuY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2Fybi5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXByZWNhdGVkOiBmdW5jdGlvbiAob2xkTmFtZSwgbmV3TmFtZSwgdmVyc2lvbikge1xuICAgICAgICAgICAgLy8gc2ltcGxlIGRlcHJlY2F0aW9uIHdhcm5pbmcgbWVjaGFuaXNtLlxuICAgICAgICAgICAgdmFyIG0gPSBvbGROYW1lICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBuZXdOYW1lICsgJyBpbnN0ZWFkLic7XG4gICAgICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG0gKz0gJyBXaWxsIGJlIHJlbW92ZWQgaW4gJyArIHZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBVdGlsLndhcm4obSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVwcmVjYXRlZE1ldGhvZDogZnVuY3Rpb24gKG9sZE5hbWUsIG5ld05hbWUsIGFyZ3MsIHZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIHJ1biB0aGUgcmVwbGFjZW1lbnQgYW5kIHdhcm4gd2hlbiBzb21lb25lIGNhbGxzIGEgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgICAgIFV0aWwuZGVwcmVjYXRlZChvbGROYW1lLCBuZXdOYW1lLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tuZXdOYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXNbbmV3TmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYW51cEF0dHJzOiBmdW5jdGlvbiAoZWwsIGF0dHJzKSB7XG4gICAgICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYW51cFRhZ3M6IGZ1bmN0aW9uIChlbCwgdGFncykge1xuICAgICAgICAgICAgdGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGdldCB0aGUgY2xvc2VzdCBwYXJlbnRcbiAgICAgICAgZ2V0Q2xvc2VzdFRhZzogZnVuY3Rpb24gKGVsLCB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlsLnRyYXZlcnNlVXAoZWwsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bndyYXA6IGZ1bmN0aW9uIChlbCwgZG9jKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuY2hpbGROb2Rlcyk7XG5cbiAgICAgICAgICAgIC8vIGNhc3Qgbm9kZUxpc3QgdG8gYXJyYXkgc2luY2UgYXBwZW5kaW5nIGNoaWxkXG4gICAgICAgICAgICAvLyB0byBhIGRpZmZlcmVudCBub2RlIHdpbGwgYWx0ZXIgbGVuZ3RoIG9mIGVsLmNoaWxkTm9kZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGZyYWdtZW50LCBlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE1lZGl1bUVkaXRvci51dGlsID0gVXRpbDtcbn0od2luZG93KSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEV4dGVuc2lvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgRXh0ZW5zaW9uLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90b1Byb3BzKSB7XG4gICAgICAgIC8vIG1hZ2ljIGV4dGVuZGVyIHRoaW5nZXIuIG1vc3RseSBib3Jyb3dlZCBmcm9tIGJhY2tib25lL2dvb2cuaW5oZXJpdHNcbiAgICAgICAgLy8gcGxhY2UgdGhpcyBmdW5jdGlvbiBvbiBzb21lIHRoaW5nIHlvdSB3YW50IGV4dGVuZC1hYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBleGFtcGxlOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgIGZ1bmN0aW9uIFRoaW5nKGFyZ3Mpe1xuICAgICAgICAvLyAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBhcmdzO1xuICAgICAgICAvLyAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICBUaGluZy5wcm90b3R5cGUgPSB7IGZvbzogXCJiYXJcIiB9O1xuICAgICAgICAvLyAgICAgIFRoaW5nLmV4dGVuZCA9IGV4dGVuZGVyaWZ5O1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgIHZhciBUaGluZ1R3byA9IFRoaW5nLmV4dGVuZCh7IGZvbzogXCJiYXpcIiB9KTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICB2YXIgdGhpbmdPbmUgPSBuZXcgVGhpbmcoKTsgLy8gZm9vID09PSBcImJhclwiXG4gICAgICAgIC8vICAgICAgdmFyIHRoaW5nVHdvID0gbmV3IFRoaW5nVHdvKCk7IC8vIGZvbyA9PT0gXCJiYXpcIlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgIHdoaWNoIHNlZW1zIGxpa2Ugc29tZSBzaW1wbHkgc2hhbGxvdyBjb3B5IG5vbnNlbnNlXG4gICAgICAgIC8vICAgICAgYXQgZmlyc3QsIGJ1dCBhIGxvdCBtb3JlIGlzIGdvaW5nIG9uIHRoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgIHBhc3NpbmcgYSBgY29uc3RydWN0b3JgIHRvIHRoZSBleHRlbmQgcHJvcHNcbiAgICAgICAgLy8gICAgICB3aWxsIGNhdXNlIHRoZSBpbnN0YW5jZSB0byBpbnN0YW50aWF0ZSB0aHJvdWdoIHRoYXRcbiAgICAgICAgLy8gICAgICBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQncyBjb25zdHJ1Y3Rvci5cblxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcyxcbiAgICAgICAgICAgIGNoaWxkO1xuXG4gICAgICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAgICAgLy8gKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3IgZGVmYXVsdGVkXG4gICAgICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQncyBjb25zdHJ1Y3Rvci5cblxuICAgICAgICBpZiAocHJvdG9Qcm9wcyAmJiBwcm90b1Byb3BzLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGFzIHN0YXRpY3MgKC5leHRlbmQgY29tZXMgb3Zlciwgc28geW91ciBzdWJjbGFzcyBjYW4gaGF2ZSBzdWJjbGFzc2VzIHRvbylcbiAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuZXh0ZW5kKGNoaWxkLCBwYXJlbnQpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgICAgIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgIH07XG4gICAgICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XG5cbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9kbzogJHN1cGVyP1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyogaW5pdDogW2Z1bmN0aW9uXVxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxsZWQgYnkgTWVkaXVtRWRpdG9yIGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogVGhlIC5iYXNlIHByb3BlcnR5IHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gc2V0IHRvXG4gICAgICAgICAqIGN1cnJlbnQgaW5zdGFuY2Ugb2YgTWVkaXVtRWRpdG9yIHdoZW4gdGhpcyBpcyBjYWxsZWQuXG4gICAgICAgICAqIEFsbCBoZWxwZXIgbWV0aG9kcyB3aWxsIGV4aXN0IGFzIHdlbGxcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qIGJhc2U6IFtNZWRpdW1FZGl0b3IgaW5zdGFuY2VdXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vdCBvdmVycmlkZW4sIHRoaXMgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICAgICAgICogb2YgTWVkaXVtRWRpdG9yLCBiZWZvcmUgdGhlIGluaXQgbWV0aG9kIGlzIGNhbGxlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZTogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIG5hbWU6IFtzdHJpbmddXG4gICAgICAgICAqXG4gICAgICAgICAqICduYW1lJyBvZiB0aGUgZXh0ZW5zaW9uLCB1c2VkIGZvciByZXRyaWV2aW5nIHRoZSBleHRlbnNpb24uXG4gICAgICAgICAqIElmIG5vdCBzZXQsIE1lZGl1bUVkaXRvciB3aWxsIHNldCB0aGlzIHRvIGJlIHRoZSBrZXlcbiAgICAgICAgICogdXNlZCB3aGVuIHBhc3NpbmcgdGhlIGV4dGVuc2lvbiBpbnRvIE1lZGl1bUVkaXRvciB2aWEgdGhlXG4gICAgICAgICAqICdleHRlbnNpb25zJyBvcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBjaGVja1N0YXRlOiBbZnVuY3Rpb24gKG5vZGUpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBpbXBsZW1lbnRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmUgb3IgbW9yZSB0aW1lc1xuICAgICAgICAgKiB0aGUgc3RhdGUgb2YgdGhlIGVkaXRvciAmIHRvb2xiYXIgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqIFdoZW4gdGhlIHN0YXRlIGlzIHVwZGF0ZWQsIHRoZSBlZGl0b3IgZG9lcyB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgKlxuICAgICAgICAgKiAxKSBGaW5kIHRoZSBwYXJlbnQgbm9kZSBjb250YWluaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgKiAyKSBDYWxsIGNoZWNrU3RhdGUgb24gdGhlIGV4dGVuc2lvbiwgcGFzc2luZyB0aGUgbm9kZSBhcyBhbiBhcmd1bWVudFxuICAgICAgICAgKiAzKSBHZXQgdGhlIHBhcmVudCBub2RlIG9mIHRoZSBwcmV2aW91cyBub2RlXG4gICAgICAgICAqIDQpIFJlcGVhdCBzdGVwcyAjMiBhbmQgIzMgdW50aWwgd2UgbW92ZSBvdXRzaWRlIHRoZSBwYXJlbnQgY29udGVudGVkaXRhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja1N0YXRlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogZGVzdHJveTogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgcmVtb3ZlIGFueSBjcmVhdGVkIGh0bWwsIGN1c3RvbSBldmVudCBoYW5kbGVyc1xuICAgICAgICAgKiBvciBhbnkgb3RoZXIgY2xlYW51cCB0YXNrcyB0aGF0IHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gICAgICAgICAqIElmIGltcGxlbWVudGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gTWVkaXVtRWRpdG9yJ3NcbiAgICAgICAgICogZGVzdHJveSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIEFzIGFsdGVybmF0aXZlcyB0byBjaGVja1N0YXRlLCB0aGVzZSBmdW5jdGlvbnMgcHJvdmlkZSBhIG1vcmUgc3RydWN0dXJlZFxuICAgICAgICAgKiBwYXRoIHRvIHVwZGF0aW5nIHRoZSBzdGF0ZSBvZiBhbiBleHRlbnNpb24gKHVzdWFsbHkgYSBidXR0b24pIHdoZW5ldmVyXG4gICAgICAgICAqIHRoZSBzdGF0ZSBvZiB0aGUgZWRpdG9yICYgdG9vbGJhciBhcmUgdXBkYXRlZC5cbiAgICAgICAgICovXG5cbiAgICAgICAgLyogcXVlcnlDb21tYW5kU3RhdGU6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgaW1wbGVtZW50ZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25jZSBvbiBlYWNoIGV4dGVuc2lvblxuICAgICAgICAgKiB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgZWRpdG9yL3Rvb2xiYXIgaXMgYmVpbmcgdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbm9uLW51bGwgdmFsdWUsIHRoZSBleHRlbnNpb24gd2lsbFxuICAgICAgICAgKiBiZSBpZ25vcmVkIGFzIHRoZSBjb2RlIGNsaW1icyB0aGUgZG9tIHRyZWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCBhbmQgdGhlIHNldEFjdGl2ZSgpIGZ1bmN0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgICogc2V0QWN0aXZlKCkgd2lsbCBiZSBjYWxsZWRcbiAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5Q29tbWFuZFN0YXRlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogaXNBY3RpdmU6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgaW1wbGVtZW50ZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBNZWRpdW1FZGl0b3JcbiAgICAgICAgICogaGFzIGRldGVybWluZWQgdGhhdCB0aGlzIGV4dGVuc2lvbiBpcyAnYWN0aXZlJyBmb3IgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBUaGlzIG1heSBiZSBjYWxsZWQgd2hlbiB0aGUgZWRpdG9yICYgdG9vbGJhciBhcmUgYmVpbmcgdXBkYXRlZCxcbiAgICAgICAgICogYnV0IG9ubHkgaWYgcXVlcnlDb21tYW5kU3RhdGUoKSBvciBpc0FscmVhZHlBcHBsaWVkKCkgZnVuY3Rpb25zXG4gICAgICAgICAqIGFyZSBpbXBsZW1lbnRlZCwgYW5kIHdoZW4gY2FsbGVkLCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzQWN0aXZlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogaXNBbHJlYWR5QXBwbGllZDogW2Z1bmN0aW9uIChub2RlKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgaW1wbGVtZW50ZWQsIHRoaXMgZnVuY3Rpb24gaXMgc2ltaWxhciB0byBjaGVja1N0YXRlKCkgaW5cbiAgICAgICAgICogdGhhdCBpdCB3aWxsIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFzIE1lZGl1bUVkaXRvciBtb3ZlcyB1cFxuICAgICAgICAgKiB0aGUgRE9NIHRvIHVwZGF0ZSB0aGUgZWRpdG9yICYgdG9vbGJhciBhZnRlciBhIHN0YXRlIGNoYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogTk9URTogVGhpcyBmdW5jdGlvbiB3aWxsIE5PVCBiZSBjYWxsZWQgaWYgY2hlY2tTdGF0ZSgpIGhhc1xuICAgICAgICAgKiBiZWVuIGltcGxlbWVudGVkLiBUaGlzIGZ1bmN0aW9uIHdpbGwgTk9UIGJlIGNhbGxlZCBpZlxuICAgICAgICAgKiBxdWVyeUNvbW1hbmRTdGF0ZSgpIGlzIGltcGxlbWVudGVkIGFuZCByZXR1cm5zIGEgbm9uLW51bGxcbiAgICAgICAgICogdmFsdWUgd2hlbiBjYWxsZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzQWxyZWFkeUFwcGxpZWQ6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBzZXRBY3RpdmU6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgaW1wbGVtZW50ZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gTWVkaXVtRWRpdG9yIGtub3dzXG4gICAgICAgICAqIHRoYXQgdGhpcyBleHRlbnNpb24gaXMgY3VycmVudGx5IGVuYWJsZWQuICBDdXJyZW50bHksIHRoaXNcbiAgICAgICAgICogZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdXBkYXRpbmcgdGhlIGVkaXRvciAmIHRvb2xiYXIsIGFuZFxuICAgICAgICAgKiBvbmx5IGlmIHF1ZXJ5Q29tbWFuZFN0YXRlKCkgb3IgaXNBbHJlYWR5QXBwbGllZChub2RlKSByZXR1cm5cbiAgICAgICAgICogdHJ1ZSB3aGVuIGNhbGxlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWN0aXZlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogc2V0SW5hY3RpdmU6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgaW1wbGVtZW50ZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gTWVkaXVtRWRpdG9yIGtub3dzXG4gICAgICAgICAqIHRoYXQgdGhpcyBleHRlbnNpb24gaXMgY3VycmVudGx5IGRpc2FibGVkLiAgQ3VyZW50bHksIHRoaXNcbiAgICAgICAgICogaXMgY2FsbGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGF0ZSBjaGFuZ2UgZm9yXG4gICAgICAgICAqIHRoZSBlZGl0b3IgJiB0b29sYmFyLiBBZnRlciBjYWxsaW5nIHRoaXMsIE1lZGl1bUVkaXRvclxuICAgICAgICAgKiB3aWxsIGF0dGVtcHQgdG8gdXBkYXRlIHRoZSBleHRlbnNpb24sIGVpdGhlciB2aWEgY2hlY2tTdGF0ZSgpXG4gICAgICAgICAqIG9yIHRoZSBjb21iaW5hdGlvbiBvZiBxdWVyeUNvbW1hbmRTdGF0ZSgpLCBpc0FscmVhZHlBcHBsaWVkKG5vZGUpLFxuICAgICAgICAgKiBpc0FjdGl2ZSgpLCBhbmQgc2V0QWN0aXZlKClcbiAgICAgICAgICovXG4gICAgICAgIHNldEluYWN0aXZlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKiBIZWxwZXJzICoqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGFyZSBoZWxwZXJzIHRoYXQgYXJlIGVpdGhlciBzZXQgYnkgTWVkaXVtRWRpdG9yXG4gICAgICAgICAqIGR1cmluZyBpbml0aWFsaXphdGlvbiwgb3IgYXJlIGhlbHBlciBtZXRob2RzIHdoaWNoIGVpdGhlclxuICAgICAgICAgKiByb3V0ZSBjYWxscyB0byB0aGUgTWVkaXVtRWRpdG9yIGluc3RhbmNlIG9yIHByb3ZpZGUgY29tbW9uXG4gICAgICAgICAqIGZ1bmN0aW9uYWxpdHkgZm9yIGFsbCBleHRlbnNpb25zXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyogd2luZG93OiBbV2luZG93XVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBub3Qgb3ZlcnJpZGVuLCB0aGlzIHdpbGwgYmUgc2V0IHRvIHRoZSB3aW5kb3cgb2JqZWN0XG4gICAgICAgICAqIHRvIGJlIHVzZWQgYnkgTWVkaXVtRWRpdG9yIGFuZCBpdHMgZXh0ZW5zaW9ucy4gIFRoaXMgaXNcbiAgICAgICAgICogcGFzc2VkIHZpYSB0aGUgJ2NvbnRlbnRXaW5kb3cnIG9wdGlvbiB0byBNZWRpdW1FZGl0b3JcbiAgICAgICAgICogYW5kIGlzIHRoZSBnbG9iYWwgJ3dpbmRvdycgb2JqZWN0IGJ5IGRlZmF1bHRcbiAgICAgICAgICovXG4gICAgICAgICd3aW5kb3cnOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogZG9jdW1lbnQ6IFtEb2N1bWVudF1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm90IG92ZXJyaWRlbiwgdGhpcyB3aWxsIGJlIHNldCB0byB0aGUgZG9jdW1lbnQgb2JqZWN0XG4gICAgICAgICAqIHRvIGJlIHVzZWQgYnkgTWVkaXVtRWRpdG9yIGFuZCBpdHMgZXh0ZW5zaW9ucy4gVGhpcyBpc1xuICAgICAgICAgKiBwYXNzZWQgdmlhIHRoZSAnb3duZXJEb2N1bWVudCcgb3B0aW4gdG8gTWVkaXVtRWRpdG9yXG4gICAgICAgICAqIGFuZCBpcyB0aGUgZ2xvYmFsICdkb2N1bWVudCcgb2JqZWN0IGJ5IGRlZmF1bHRcbiAgICAgICAgICovXG4gICAgICAgICdkb2N1bWVudCc6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBnZXRFZGl0b3JFbGVtZW50czogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nXG4gICAgICAgICAqIGFsbCB0aGUgY29udGVudGVkaXRhYmxlIGVsZW1lbnRzIGZvciB0aGlzIGluc3RhbmNlXG4gICAgICAgICAqIG9mIE1lZGl1bUVkaXRvclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RWRpdG9yRWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2UuZWxlbWVudHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogZ2V0RWRpdG9ySWQ6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSB1bmlxdWUgaWRlbnRpZmllclxuICAgICAgICAgKiBmb3IgdGhpcyBpbnN0YW5jZSBvZiBNZWRpdW1FZGl0b3JcbiAgICAgICAgICovXG4gICAgICAgIGdldEVkaXRvcklkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGdldEVkaXRvck9wdGlvbnM6IFtmdW5jdGlvbiAob3B0aW9uKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHZhbHVlIG9mIGFuIG9wdGlvblxuICAgICAgICAgKiB1c2VkIHRvIGluaXRpYWxpemUgdGhpcyBpbnN0YW5jZSBvZiBNZWRpdW1FZGl0b3JcbiAgICAgICAgICovXG4gICAgICAgIGdldEVkaXRvck9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZS5vcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogTGlzdCBvZiBtZXRob2QgbmFtZXMgdG8gYWRkIHRvIHRoZSBwcm90b3R5cGUgb2YgRXh0ZW5zaW9uXG4gICAgICogRWFjaCBvZiB0aGVzZSBtZXRob2RzIHdpbGwgYmUgZGVmaW5lZCBhcyBoZWxwZXJzIHRoYXRcbiAgICAgKiBqdXN0IGNhbGwgZGlyZWN0bHkgaW50byB0aGUgTWVkaXVtRWRpdG9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogZXhhbXBsZSBmb3IgJ29uJyBtZXRob2Q6XG4gICAgICogRXh0ZW5zaW9uLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRoaXMuYmFzZS5vbi5hcHBseSh0aGlzLmJhc2UsIGFyZ3VtZW50cyk7XG4gICAgICogfVxuICAgICAqL1xuICAgIFtcbiAgICAgICAgLy8gZ2VuZXJhbCBoZWxwZXJzXG4gICAgICAgICdleGVjQWN0aW9uJyxcblxuICAgICAgICAvLyBldmVudCBoYW5kbGluZ1xuICAgICAgICAnb24nLFxuICAgICAgICAnb2ZmJyxcbiAgICAgICAgJ3N1YnNjcmliZScsXG4gICAgICAgICd0cmlnZ2VyJ1xuXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChoZWxwZXIpIHtcbiAgICAgICAgRXh0ZW5zaW9uLnByb3RvdHlwZVtoZWxwZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVtoZWxwZXJdLmFwcGx5KHRoaXMuYmFzZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5FeHRlbnNpb24gPSBFeHRlbnNpb247XG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGZpbHRlck9ubHlQYXJlbnRFbGVtZW50cyhub2RlKSB7XG4gICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0Jsb2NrQ29udGFpbmVyKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU2VsZWN0aW9uID0ge1xuICAgICAgICBmaW5kTWF0Y2hpbmdTZWxlY3Rpb25QYXJlbnQ6IGZ1bmN0aW9uICh0ZXN0RWxlbWVudEZ1bmN0aW9uLCBjb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gY29udGVudFdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50O1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgICAgICAgIHJldHVybiBNZWRpdW1FZGl0b3IudXRpbC50cmF2ZXJzZVVwKGN1cnJlbnQsIHRlc3RFbGVtZW50RnVuY3Rpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNlbGVjdGlvbkVsZW1lbnQ6IGZ1bmN0aW9uIChjb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kTWF0Y2hpbmdTZWxlY3Rpb25QYXJlbnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lZGl1bUVkaXRvci51dGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChlbCk7XG4gICAgICAgICAgICB9LCBjb250ZW50V2luZG93KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3Njc4ODQzL2NhbnQtcmVzdG9yZS1zZWxlY3Rpb24tYWZ0ZXItaHRtbC1tb2RpZnktZXZlbi1pZi1pdHMtdGhlLXNhbWUtaHRtbFxuICAgICAgICAvLyBUaW0gRG93blxuICAgICAgICBleHBvcnRTZWxlY3Rpb246IGZ1bmN0aW9uIChyb290LCBkb2MpIHtcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhdGUgPSBudWxsLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLFxuICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb25SYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb25SYW5nZS5zZWxlY3ROb2RlQ29udGVudHMocm9vdCk7XG4gICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uUmFuZ2Uuc2V0RW5kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwcmVTZWxlY3Rpb25SYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc3RhcnQgKyByYW5nZS50b1N0cmluZygpLmxlbmd0aFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHNlbGVjdGlvbiBzdGFydHMgd2l0aCBhbnkgaW1hZ2VzXG4gICAgICAgICAgICAgICAgLy8gaWYgc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlbGVjdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIHNldCBjb3JyZWN0bHkgd2hlbiBpbXBvcnRpbmcgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9lc1JhbmdlU3RhcnRXaXRoSW1hZ2VzKHJhbmdlLCBkb2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLnN0YXJ0c1dpdGhJbWFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBzZWxlY3Rpb24gaGFzIGFueSB0cmFpbGluZyBpbWFnZXNcbiAgICAgICAgICAgICAgICAvLyBpZiBzbywgdGhpcyB0aGlzIG1lYW5zIHdlIG5lZWQgdG8gbG9vayBmb3IgdGhlbSB3aGVuIHdlIGltcG9ydCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgdHJhaWxpbmdJbWFnZUNvdW50ID0gdGhpcy5nZXRUcmFpbGluZ0ltYWdlQ291bnQocm9vdCwgc2VsZWN0aW9uU3RhdGUsIHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAodHJhaWxpbmdJbWFnZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLnRyYWlsaW5nSW1hZ2VDb3VudCA9IHRyYWlsaW5nSW1hZ2VDb3VudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCA9IDAgdGhlcmUgbWF5IHN0aWxsIGJlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgaXQsIGJ1dCB3ZSBkb24ndCBjYXJlLlxuICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW1wdHlCbG9ja3NJbmRleCA9IHRoaXMuZ2V0SW5kZXhSZWxhdGl2ZVRvQWRqYWNlbnRFbXB0eUJsb2Nrcyhkb2MsIHJvb3QsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eUJsb2Nrc0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhdGUuZW1wdHlCbG9ja3NJbmRleCA9IGVtcHR5QmxvY2tzSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3Njc4ODQzL2NhbnQtcmVzdG9yZS1zZWxlY3Rpb24tYWZ0ZXItaHRtbC1tb2RpZnktZXZlbi1pZi1pdHMtdGhlLXNhbWUtaHRtbFxuICAgICAgICAvLyBUaW0gRG93blxuICAgICAgICAvL1xuICAgICAgICAvLyB7b2JqZWN0fSBzZWxlY3Rpb25TdGF0ZSAtIHRoZSBzZWxlY3Rpb24gdG8gaW1wb3J0XG4gICAgICAgIC8vIHtET01FbGVtZW50fSByb290IC0gdGhlIHJvb3QgZWxlbWVudCB0aGUgc2VsZWN0aW9uIGlzIGJlaW5nIHJlc3RvcmVkIGluc2lkZSBvZlxuICAgICAgICAvLyB7RG9jdW1lbnR9IGRvYyAtIHRoZSBkb2N1bWVudCB0byB1c2UgZm9yIG1hbmFnaW5nIHNlbGVjdGlvblxuICAgICAgICAvLyB7Ym9vbGVhbn0gW2Zhdm9yTGF0ZXJTZWxlY3Rpb25BbmNob3JdIC0gZGVmYXVsdHMgdG8gZmFsc2UuIElmIHRydWUsIGltcG9ydCB0aGUgY3Vyc29yIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vICAgICAgc3Vic2VxdWVudCB0byBhbiBhbmNob3IgdGFnIGlmIGl0IHdvdWxkIG90aGVyd2lzZSBiZSBwbGFjZWQgcmlnaHQgYXQgdGhlIHRyYWlsaW5nIGVkZ2UgaW5zaWRlIHRoZVxuICAgICAgICAvLyAgICAgIGFuY2hvci4gVGhpcyBjdXJzb3IgcG9zaXRpb25pbmcsIGV2ZW4gdGhvdWdoIHZpc3VhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIHVzZXIsIGNhbiBhZmZlY3QgYmVoYXZpb3JcbiAgICAgICAgLy8gICAgICBpbiBNUyBJRS5cbiAgICAgICAgaW1wb3J0U2VsZWN0aW9uOiBmdW5jdGlvbiAoc2VsZWN0aW9uU3RhdGUsIHJvb3QsIGRvYywgZmF2b3JMYXRlclNlbGVjdGlvbkFuY2hvcikge1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25TdGF0ZSB8fCAhcm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChyb290LCAwKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHJvb3QsXG4gICAgICAgICAgICAgICAgbm9kZVN0YWNrID0gW10sXG4gICAgICAgICAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICBmb3VuZFN0YXJ0ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgZm91bmRFbmQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0ltYWdlQ291bnQgPSAwLFxuICAgICAgICAgICAgICAgIHN0b3AgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXh0Q2hhckluZGV4LFxuICAgICAgICAgICAgICAgIGFsbG93UmFuZ2VUb1N0YXJ0QXRFbmRPZk5vZGUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXN0VGV4dE5vZGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGltcG9ydGluZyBzZWxlY3Rpb24sIHRoZSBzdGFydCBvZiB0aGUgc2VsZWN0aW9uIG1heSBsaWUgYXQgdGhlIGVuZCBvZiBhbiBlbGVtZW50XG4gICAgICAgICAgICAvLyBvciBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGVsZW1lbnQuICBTaW5jZSB2aXN1YWxseSB0aGVyZSBpcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlc2UgMlxuICAgICAgICAgICAgLy8gd2Ugd2lsbCB0cnkgdG8gbW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBiZWdpbm5pbmcgb2YgYW4gZWxlbWVudCBzaW5jZSB0aGlzIGlzIGdlbmVyYWxseVxuICAgICAgICAgICAgLy8gd2hhdCB1c2VycyB3aWxsIGV4cGVjdCBhbmQgaXQncyBhIG1vcmUgcHJlZGljdGFibGUgYmVoYXZpb3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlcmUgYXJlIHNvbWUgc3BlY2lmaWMgY2FzZXMgd2hlbiB3ZSBkb24ndCB3YW50IHRvIGRvIHRoaXM6XG4gICAgICAgICAgICAvLyAgMSkgV2UncmUgYXR0ZW1wdGluZyB0byBtb3ZlIHRoZSBjdXJzb3Igb3V0c2lkZSBvZiB0aGUgZW5kIG9mIGFuIGFuY2hvciBbZmF2b3JMYXRlclNlbGVjdGlvbkFuY2hvciA9IHRydWVdXG4gICAgICAgICAgICAvLyAgMikgVGhlIHNlbGVjdGlvbiBzdGFydHMgd2l0aCBhbiBpbWFnZSwgd2hpY2ggaXMgc3BlY2lhbCBzaW5jZSBhbiBpbWFnZSBkb2Vzbid0IGhhdmUgYW55ICdjb250ZW50J1xuICAgICAgICAgICAgLy8gICAgIGFzIGZhciBhcyBzZWxlY3Rpb24gYW5kIHJhbmdlcyBhcmUgY29uY2VybmVkXG4gICAgICAgICAgICAvLyAgMykgVGhlIHNlbGVjdGlvbiBzdGFydHMgYWZ0ZXIgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVtcHR5IGJsb2NrIGVsZW1lbnRzIChzZWxlY3Rpb25TdGF0ZS5lbXB0eUJsb2Nrc0luZGV4KVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciB0aGVzZSBjYXNlcywgd2Ugd2FudCB0aGUgc2VsZWN0aW9uIHRvIHN0YXJ0IGF0IGEgdmVyeSBzcGVjaWZpYyBsb2NhdGlvbiwgc28gd2Ugc2hvdWxkIE5PVFxuICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBtb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlyc3QgYWN0dWFsIGNodW5rIG9mIHRleHRcbiAgICAgICAgICAgIGlmIChmYXZvckxhdGVyU2VsZWN0aW9uQW5jaG9yIHx8IHNlbGVjdGlvblN0YXRlLnN0YXJ0c1dpdGhJbWFnZSB8fCB0eXBlb2Ygc2VsZWN0aW9uU3RhdGUuZW1wdHlCbG9ja3NJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBhbGxvd1JhbmdlVG9TdGFydEF0RW5kT2ZOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKCFzdG9wICYmIG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGl0ZXJhdGUgb3ZlciBlbGVtZW50cyBhbmQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID4gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoaXQgYSB0ZXh0IG5vZGUsIHdlIG5lZWQgdG8gYWRkIHRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0byB0aGUgb3ZlcmFsbCBjb3VudFxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzICYmICFmb3VuZEVuZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhckluZGV4ID0gY2hhckluZGV4ICsgbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGF0IG9yIGJleW9uZCB0aGUgc3RhcnQgb2YgdGhlIHNlbGVjdGlvbiB3ZSdyZSBpbXBvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJ0ICYmIHNlbGVjdGlvblN0YXRlLnN0YXJ0ID49IGNoYXJJbmRleCAmJiBzZWxlY3Rpb25TdGF0ZS5zdGFydCA8PSBuZXh0Q2hhckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBvbmx5IHdhbnQgdG8gYWxsb3cgYSBzZWxlY3Rpb24gdG8gc3RhcnQgYXQgdGhlIEVORCBvZiBhbiBlbGVtZW50IGlmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgYWxsb3dSYW5nZVRvU3RhcnRBdEVuZE9mTm9kZSBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dSYW5nZVRvU3RhcnRBdEVuZE9mTm9kZSB8fCBzZWxlY3Rpb25TdGF0ZS5zdGFydCA8IG5leHRDaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBzZWxlY3Rpb25TdGF0ZS5zdGFydCAtIGNoYXJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIGEgdGV4dCBub2RlIHdoZXJlIHRoZSBzZWxlY3Rpb24gY291bGQgc3RhcnQgYnV0IHdlIHNob3VsZG4ndFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgc2VsZWN0aW9uIHN0YXJ0IGhlcmUgYmVjYXVzZSBhbGxvd1JhbmdlVG9TdGFydEF0RW5kT2ZOb2RlIGlzIGZhbHNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2Ugc2hvdWxkIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhpcyBub2RlIGluIGNhc2UgdGhlcmUgYXJlbid0IGFueSBtb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IG5vZGVzIGFmdGVyIHRoaXMsIHNvIHRoYXQgd2UgaGF2ZSBzb21ld2hlcmUgdG8gaW1wb3J0IHRoZSBzZWxlY3Rpb24gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZm91bmQgdGhlIHN0YXJ0IG9mIHRoZSBzZWxlY3Rpb24sIGNoZWNrIGlmIHdlJ3JlIGF0IG9yIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBzZWxlY3Rpb24gd2UncmUgaW1wb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFN0YXJ0ICYmIHNlbGVjdGlvblN0YXRlLmVuZCA+PSBjaGFySW5kZXggJiYgc2VsZWN0aW9uU3RhdGUuZW5kIDw9IG5leHRDaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uU3RhdGUudHJhaWxpbmdJbWFnZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHNlbGVjdGlvblN0YXRlLmVuZCAtIGNoYXJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFySW5kZXggPSBuZXh0Q2hhckluZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGF0ZS50cmFpbGluZ0ltYWdlQ291bnQgJiYgZm91bmRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJbWFnZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhaWxpbmdJbWFnZUNvdW50ID09PSBzZWxlY3Rpb25TdGF0ZS50cmFpbGluZ0ltYWdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHdoaWNoIGluZGV4IHRoZSBpbWFnZSBpcyBpbiBpdHMgcGFyZW50J3MgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1tlbmRJbmRleF0gIT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUucGFyZW50Tm9kZSwgZW5kSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcCAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhbGwgaXRzIGNoaWxkcmVuIHRvIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlU3RhY2sucHVzaChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UndmUgZ29uZSB0aHJvdWdoIHRoZSBlbnRpcmUgdGV4dCBidXQgZGlkbid0IGZpbmQgdGhlIGJlZ2lubmluZyBvZiBhIHRleHQgbm9kZVxuICAgICAgICAgICAgLy8gdG8gbWFrZSB0aGUgc2VsZWN0aW9uIHN0YXJ0IGF0LCB3ZSBzaG91bGQgZmFsbCBiYWNrIHRvIHN0YXJ0aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIGF0IHRoZSBFTkQgb2YgdGhlIGxhc3QgdGV4dCBub2RlIHdlIGZvdW5kXG4gICAgICAgICAgICBpZiAoIWZvdW5kU3RhcnQgJiYgbGFzdFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobGFzdFRleHROb2RlLCBsYXN0VGV4dE5vZGUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobGFzdFRleHROb2RlLCBsYXN0VGV4dE5vZGUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rpb25TdGF0ZS5lbXB0eUJsb2Nrc0luZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5pbXBvcnRTZWxlY3Rpb25Nb3ZlQ3Vyc29yUGFzdEJsb2Nrcyhkb2MsIHJvb3QsIHNlbGVjdGlvblN0YXRlLmVtcHR5QmxvY2tzSW5kZXgsIHJhbmdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyByaWdodCBhdCB0aGUgZW5kaW5nIGVkZ2Ugb2YgYSBsaW5rLCBwdXQgaXQgb3V0c2lkZSB0aGUgYW5jaG9yIHRhZyBpbnN0ZWFkIG9mIGluc2lkZS5cbiAgICAgICAgICAgIGlmIChmYXZvckxhdGVyU2VsZWN0aW9uQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmltcG9ydFNlbGVjdGlvbk1vdmVDdXJzb3JQYXN0QW5jaG9yKHNlbGVjdGlvblN0YXRlLCByYW5nZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWwgPSBkb2MuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFV0aWxpdHkgbWV0aG9kIGNhbGxlZCBmcm9tIGltcG9ydFNlbGVjdGlvbiBvbmx5XG4gICAgICAgIGltcG9ydFNlbGVjdGlvbk1vdmVDdXJzb3JQYXN0QW5jaG9yOiBmdW5jdGlvbiAoc2VsZWN0aW9uU3RhdGUsIHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUluc2lkZUFuY2hvclRhZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLnN0YXJ0ID09PSBzZWxlY3Rpb25TdGF0ZS5lbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwudHJhdmVyc2VVcChyYW5nZS5zdGFydENvbnRhaW5lciwgbm9kZUluc2lkZUFuY2hvclRhZ0Z1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsICYmIGN1cnJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY2hpbGROb2Rlc1tjdXJyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdICE9PSBwcmV2Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgIT09IG51bGwgJiYgY3VycmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZUluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGN1cnJlbnROb2RlSW5kZXggPT09IG51bGwgJiYgaSA8IGN1cnJlbnROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1tpXSA9PT0gY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChjdXJyZW50Tm9kZS5wYXJlbnROb2RlLCBjdXJyZW50Tm9kZUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBVc2VzIHRoZSBlbXB0eUJsb2Nrc0luZGV4IGNhbGN1bGF0ZWQgYnkgZ2V0SW5kZXhSZWxhdGl2ZVRvQWRqYWNlbnRFbXB0eUJsb2Nrc1xuICAgICAgICAvLyB0byBtb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgc3RhcnQgb2YgdGhlIGNvcnJlY3QgcGFyYWdyYXBoXG4gICAgICAgIGltcG9ydFNlbGVjdGlvbk1vdmVDdXJzb3JQYXN0QmxvY2tzOiBmdW5jdGlvbiAoZG9jLCByb290LCBpbmRleCwgcmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jLmNyZWF0ZVRyZWVXYWxrZXIocm9vdCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIGZpbHRlck9ubHlQYXJlbnRFbGVtZW50cywgZmFsc2UpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgc3RhcnRCbG9jayxcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIGN1cnJJbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4IHx8IDE7IC8vIElmIGluZGV4IGlzIDAsIHdlIHN0aWxsIHdhbnQgdG8gbW92ZSB0byB0aGUgbmV4dCBibG9ja1xuXG4gICAgICAgICAgICAvLyBDaHJvbWUgY291bnRzIG5ld2xpbmVzIGFuZCBzcGFjZXMgdGhhdCBzZXBhcmF0ZSBibG9jayBlbGVtZW50cyBhcyBhY3R1YWwgZWxlbWVudHMuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGluc2lkZSBvbmUgb2YgdGhlc2UgdGV4dCBub2RlcywgYW5kIGl0IGhhcyBhIHByZXZpb3VzIHNpYmxpbmdcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgYmxvY2sgZWxlbWVudCwgd2Ugd2FudCB0aGUgdHJlZXdhbGtlciB0byBzdGFydCBhdCB0aGUgcHJldmlvdXMgc2libGluZ1xuICAgICAgICAgICAgLy8gYW5kIE5PVCBhdCB0aGUgcGFyZW50IG9mIHRoZSB0ZXh0bm9kZVxuICAgICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAzICYmIE1lZGl1bUVkaXRvci51dGlsLmlzQmxvY2tDb250YWluZXIoc3RhcnRDb250YWluZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBzdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBNZWRpdW1FZGl0b3IudXRpbC5nZXRDbG9zZXN0QmxvY2tDb250YWluZXIoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTa2lwIG92ZXIgZW1wdHkgYmxvY2tzIHVudGlsIHdlIGhpdCB0aGUgYmxvY2sgd2Ugd2FudCB0aGUgc2VsZWN0aW9uIHRvIGJlIGluXG4gICAgICAgICAgICB3aGlsZSAodHJlZVdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgYmxvY2tzIHVudGlsIHdlIGhpdCB0aGUgc3RhcnRpbmcgYmxvY2sgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA9PT0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRyZWVXYWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhpdCB0aGUgdGFyZ2V0IGluZGV4LCBiYWlsXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJySW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGEgbm9uLWVtcHR5IGJsb2NrLCBpZ25vcmUgdGhlIGVtcHR5QmxvY2tzSW5kZXggYW5kIGp1c3QgcHV0IHNlbGVjdGlvbiBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlLnRleHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gc3RhcnRCbG9jaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UncmUgc2VsZWN0aW5nIGEgaGlnaC1sZXZlbCBibG9jayBub2RlLCBzbyBtYWtlIHN1cmUgdGhlIGN1cnNvciBnZXRzIG1vdmVkIGludG8gdGhlIGRlZXBlc3RcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYmxvY2tcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KE1lZGl1bUVkaXRvci51dGlsLmdldEZpcnN0U2VsZWN0YWJsZUxlYWZOb2RlKHRhcmdldE5vZGUpLCAwKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJldHVybnMgLTEgdW5sZXNzIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHBhcmFncmFwaC9ibG9ja1xuICAgICAgICAvLyBJZiB0aGUgcGFyYWdyYXBoL2Jsb2NrIGlzIHByZWNlZWRlZCBieSBlbXB0eSBwYXJhZ3JhcGhzL2Jsb2NrICh3aXRoIG5vIHRleHQpXG4gICAgICAgIC8vIGl0IHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZW1wdHkgcGFyYWdyYXBocyBiZWZvcmUgdGhlIGN1cnNvci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiAwLCB3aGljaCBpbmRpY2F0ZXMgdGhlIGN1cnNvciBpcyBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgIC8vIG9mIGEgcGFyYWdyYXBoL2Jsb2NrLCBhbmQgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaC9ibG9jayBiZWZvcmUgaXRcbiAgICAgICAgZ2V0SW5kZXhSZWxhdGl2ZVRvQWRqYWNlbnRFbXB0eUJsb2NrczogZnVuY3Rpb24gKGRvYywgcm9vdCwgY3Vyc29yQ29udGFpbmVyLCBjdXJzb3JPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHRleHQgaW4gZnJvbnQgb2YgdGhlIGN1cnNvciwgdGhhdCBtZWFucyB0aGVyZSBpc24ndCBvbmx5IGVtcHR5IGJsb2NrcyBiZWZvcmUgaXRcbiAgICAgICAgICAgIGlmIChjdXJzb3JDb250YWluZXIudGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiBjdXJzb3JPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYmxvY2sgdGhhdCBjb250YWlucyB0aGUgY3Vyc29yIGhhcyBhbnkgb3RoZXIgdGV4dCBpbiBmcm9udCBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGN1cnNvckNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGN1cnNvckNvbnRhaW5lci5jaGlsZE5vZGVzW2N1cnNvck9mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzbid0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBibG9jaywgc28gaXQgaGFzIGNvbnRlbnQgYmVmb3JlIGl0XG4gICAgICAgICAgICAgICAgaWYgKCFNZWRpdW1FZGl0b3IudXRpbC5pc0VsZW1lbnRBdEJlZ2lubmluZ09mQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBNZWRpdW1FZGl0b3IudXRpbC5maW5kUHJldmlvdXNTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIHNpYmxpbmcsIHRoaXMgaXMgdGhlIGZpcnN0IHRleHQgZWxlbWVudCBpbiB0aGUgZWRpdG9yXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgc2libGluZyBoYXMgdGV4dCwgdGhlbiB0aGVyZSBhcmUgbm8gZW1wdHkgYmxvY2tzIGJlZm9yZSB0aGlzXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldmlvdXNTaWJsaW5nLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWxrIG92ZXIgYmxvY2sgZWxlbWVudHMsIGNvdW50aW5nIG51bWJlciBvZiBlbXB0eSBibG9ja3MgYmV0d2VlbiBsYXN0IHBpZWNlIG9mIHRleHRcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgYmxvY2sgdGhlIGN1cnNvciBpcyBpblxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RCbG9jayA9IE1lZGl1bUVkaXRvci51dGlsLmdldENsb3Nlc3RCbG9ja0NvbnRhaW5lcihjdXJzb3JDb250YWluZXIpLFxuICAgICAgICAgICAgICAgIHRyZWVXYWxrZXIgPSBkb2MuY3JlYXRlVHJlZVdhbGtlcihyb290LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgZmlsdGVyT25seVBhcmVudEVsZW1lbnRzLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgZW1wdHlCbG9ja3NDb3VudCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodHJlZVdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrSXNFbXB0eSA9IHRyZWVXYWxrZXIuY3VycmVudE5vZGUudGV4dENvbnRlbnQgPT09ICcnO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja0lzRW1wdHkgfHwgZW1wdHlCbG9ja3NDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlCbG9ja3NDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJlZVdhbGtlci5jdXJyZW50Tm9kZSA9PT0gY2xvc2VzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUJsb2Nrc0NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrSXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eUJsb2Nrc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eUJsb2Nrc0NvdW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIHJhbmdlIGJlZ2lucyB3aXRoIGFuIGltYWdlIHRhZ1xuICAgICAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSByYW5nZSBzdGFydHMgd2l0aCBhbnkgbm9uIGVtcHR5IHRleHQgbm9kZXNcbiAgICAgICAgZG9lc1JhbmdlU3RhcnRXaXRoSW1hZ2VzOiBmdW5jdGlvbiAocmFuZ2UsIGRvYykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSAwIHx8IHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltZyA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jLmNyZWF0ZVRyZWVXYWxrZXIocmFuZ2Uuc3RhcnRDb250YWluZXIsIE5vZGVGaWx0ZXIuU0hPV19BTEwsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIHdoaWxlICh0cmVlV2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRyZWVXYWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGl0IHRoZSBpbWFnZSwgdGhlbiB0aGVyZSBpc24ndCBhbnkgdGV4dCBiZWZvcmUgdGhlIGltYWdlIHNvXG4gICAgICAgICAgICAgICAgLy8gdGhlIGltYWdlIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IGltZykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBoaXQgdGhlIGlhbWdlLCBidXQgZm91bmQgdGV4dCB0aGF0IGNvbnRhaW5zIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSByYW5nZSBkb2Vzbid0IHN0YXJ0IHdpdGggYW4gaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VHJhaWxpbmdJbWFnZUNvdW50OiBmdW5jdGlvbiAocm9vdCwgc2VsZWN0aW9uU3RhdGUsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZW5kT2Zmc2V0IG9mIGEgcmFuZ2UgaXMgMCwgdGhlIGVuZENvbnRhaW5lciBkb2Vzbid0IGNvbnRhaW4gaW1hZ2VzXG4gICAgICAgICAgICAvLyBJZiB0aGUgZW5kQ29udGFpbmVyIGlzIGEgdGV4dCBub2RlLCB0aGVyZSBhcmUgbm8gdHJhaWxpbmcgaW1hZ2VzXG4gICAgICAgICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwIHx8IGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZW5kQ29udGFpbmVyIGlzbid0IGFuIGltYWdlLCBhbmQgZG9lc24ndCBoYXZlIGFuIGltYWdlIGRlc2NlbmRhbnRzXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gdHJhaWxpbmcgaW1hZ2VzXG4gICAgICAgICAgICBpZiAoZW5kQ29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdpbWcnICYmICFlbmRDb250YWluZXIucXVlcnlTZWxlY3RvcignaW1nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gZW5kQ29udGFpbmVyLmNoaWxkTm9kZXNbZW5kT2Zmc2V0IC0gMV07XG4gICAgICAgICAgICB3aGlsZSAobGFzdE5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub2RlID0gcm9vdCxcbiAgICAgICAgICAgICAgICBub2RlU3RhY2sgPSBbXSxcbiAgICAgICAgICAgICAgICBjaGFySW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIGZvdW5kU3RhcnQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3VuZEVuZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0b3AgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXh0Q2hhckluZGV4LFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nSW1hZ2VzID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKCFzdG9wICYmIG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGl0ZXJhdGUgb3ZlciBlbGVtZW50cyBhbmQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID4gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAhZm91bmRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJbWFnZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhckluZGV4ID0gY2hhckluZGV4ICsgbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFydCAmJiBzZWxlY3Rpb25TdGF0ZS5zdGFydCA+PSBjaGFySW5kZXggJiYgc2VsZWN0aW9uU3RhdGUuc3RhcnQgPD0gbmV4dENoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RhcnQgJiYgc2VsZWN0aW9uU3RhdGUuZW5kID49IGNoYXJJbmRleCAmJiBzZWxlY3Rpb25TdGF0ZS5lbmQgPD0gbmV4dENoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJJbmRleCA9IG5leHRDaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSW1hZ2VzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGFsbCBpdHMgY2hpbGRyZW4gdG8gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVTdGFjay5wdXNoKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdJbWFnZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBjb250YWlucyBhbnkgJ2NvbnRlbnQnXG4gICAgICAgIC8vIGNvbnRlbnQgYmVpbmcgYW55IG5vbi13aGl0ZSBzcGFjZSB0ZXh0IG9yIGFuIGltYWdlXG4gICAgICAgIHNlbGVjdGlvbkNvbnRhaW5zQ29udGVudDogZnVuY3Rpb24gKGRvYykge1xuICAgICAgICAgICAgdmFyIHNlbCA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgLy8gY29sbGFwc2VkIHNlbGVjdGlvbiBvciBzZWxlY3Rpb24gd2l0aG91ciByYW5nZSBkb2Vzbid0IGNvbnRhaW4gY29udGVudFxuICAgICAgICAgICAgaWYgKCFzZWwgfHwgc2VsLmlzQ29sbGFwc2VkIHx8ICFzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdG9TdHJpbmcoKSBjb250YWlucyBhbnkgdGV4dCwgdGhlIHNlbGVjdGlvbiBjb250YWlucyBzb21lIGNvbnRlbnRcbiAgICAgICAgICAgIGlmIChzZWwudG9TdHJpbmcoKS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdGlvbiBjb250YWlucyBvbmx5IGltYWdlKHMpLCBpdCB3aWxsIHJldHVybiBlbXB0eSBmb3IgdG9TdHJpbmcoKVxuICAgICAgICAgICAgLy8gc28gY2hlY2sgZm9yIGFuIGltYWdlIG1hbnVhbGx5XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uTm9kZSA9IHRoaXMuZ2V0U2VsZWN0ZWRQYXJlbnRFbGVtZW50KHNlbC5nZXRSYW5nZUF0KDApKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGlvbk5vZGUubm9kZVR5cGUgPT09IDEgJiYgc2VsZWN0aW9uTm9kZS5xdWVyeVNlbGVjdG9yKCdpbWcnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsZWN0aW9uSW5Db250ZW50RWRpdGFibGVGYWxzZTogZnVuY3Rpb24gKGNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgZXhjbHVzaXZlbHkgaW5zaWRlXG4gICAgICAgICAgICAvLyBhIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIsIHRob3VnaCB0cmVhdCB0aGUgY2FzZSBvZiBhblxuICAgICAgICAgICAgLy8gZXhwbGljaXQgY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiIGluc2lkZSBhIFwiZmFsc2VcIiBhcyBmYWxzZS5cbiAgICAgICAgICAgIHZhciBzYXd0cnVlLFxuICAgICAgICAgICAgICAgIHNhd2ZhbHNlID0gdGhpcy5maW5kTWF0Y2hpbmdTZWxlY3Rpb25QYXJlbnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZSA9IGVsICYmIGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXd0cnVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZU5hbWUgIT09ICcjdGV4dCcgJiYgY2UgPT09ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgfSwgY29udGVudFdpbmRvdyk7XG5cbiAgICAgICAgICAgIHJldHVybiAhc2F3dHJ1ZSAmJiBzYXdmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQxNzY5MjMvaHRtbC1vZi1zZWxlY3RlZC10ZXh0XG4gICAgICAgIC8vIGJ5IFRpbSBEb3duXG4gICAgICAgIGdldFNlbGVjdGlvbkh0bWw6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbkh0bWwoZG9jKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBodG1sID0gJycsXG4gICAgICAgICAgICAgICAgc2VsID0gZG9jLmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgICAgICBjb250YWluZXI7XG4gICAgICAgICAgICBpZiAoc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc2VsLnJhbmdlQ291bnQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsLmdldFJhbmdlQXQoaSkuY2xvbmVDb250ZW50cygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogIEZpbmQgdGhlIGNhcmV0IHBvc2l0aW9uIHdpdGhpbiBhbiBlbGVtZW50IGlycmVzcGVjdGl2ZSBvZiBhbnkgaW5saW5lIHRhZ3MgaXQgbWF5IGNvbnRhaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqICBAcGFyYW0ge0RPTUVsZW1lbnR9IEFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY3Vyc29yIHRvIGZpbmQgb2Zmc2V0cyByZWxhdGl2ZSB0by5cbiAgICAgICAgICogIEBwYXJhbSB7UmFuZ2V9IEEgUmFuZ2UgcmVwcmVzZW50aW5nIGN1cnNvciBwb3NpdGlvbi4gV2lsbCB3aW5kb3cuZ2V0U2VsZWN0aW9uIGlmIG5vbmUgaXMgcGFzc2VkLlxuICAgICAgICAgKiAgQHJldHVybiB7T2JqZWN0fSAnbGVmdCcgYW5kICdyaWdodCcgYXR0cmlidXRlcyBjb250YWluIG9mZnNldHMgZnJvbSBiZWdpbmluZyBhbmQgZW5kIG9mIEVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGdldENhcmV0T2Zmc2V0czogZnVuY3Rpb24gZ2V0Q2FyZXRPZmZzZXRzKGVsZW1lbnQsIHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgcHJlQ2FyZXRSYW5nZSwgcG9zdENhcmV0UmFuZ2U7XG5cbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVDYXJldFJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgcG9zdENhcmV0UmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG5cbiAgICAgICAgICAgIHByZUNhcmV0UmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgcHJlQ2FyZXRSYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuXG4gICAgICAgICAgICBwb3N0Q2FyZXRSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWxlbWVudCk7XG4gICAgICAgICAgICBwb3N0Q2FyZXRSYW5nZS5zZXRTdGFydChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogcHJlQ2FyZXRSYW5nZS50b1N0cmluZygpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByaWdodDogcG9zdENhcmV0UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTg2NzU0Mi9yYW5nZS1vYmplY3QtZ2V0LXNlbGVjdGlvbi1wYXJlbnQtbm9kZS1jaHJvbWUtdnMtZmlyZWZveFxuICAgICAgICByYW5nZVNlbGVjdHNTaW5nbGVOb2RlOiBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE5vZGUgPT09IHJhbmdlLmVuZENvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZS5oYXNDaGlsZE5vZGVzKCkgJiZcbiAgICAgICAgICAgICAgICByYW5nZS5lbmRPZmZzZXQgPT09IHJhbmdlLnN0YXJ0T2Zmc2V0ICsgMTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQ6IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24gZW5jb21wYXNzZXMgYSBzaW5nbGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VTZWxlY3RzU2luZ2xlTm9kZShyYW5nZSkgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tyYW5nZS5zdGFydE9mZnNldF0ubm9kZVR5cGUgIT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tyYW5nZS5zdGFydE9mZnNldF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbiByYW5nZSBzdGFydHMgaW5zaWRlIGEgdGV4dCBub2RlLCBzbyBnZXQgaXRzIHBhcmVudFxuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbiBzdGFydHMgaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZWxlY3RlZEVsZW1lbnRzOiBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZG9jLmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIHRvUmV0LFxuICAgICAgICAgICAgICAgIGN1cnJOb2RlO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCAhc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRvUmV0ID0gW107XG4gICAgICAgICAgICAgICAgY3Vyck5vZGUgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyck5vZGUucGFyZW50Tm9kZSAmJiBjdXJyTm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0LnB1c2goY3Vyck5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJOb2RlID0gY3Vyck5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9SZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXS5maWx0ZXIuY2FsbChyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBzZWxlY3Rpb24uY29udGFpbnNOb2RlID09PSAnZnVuY3Rpb24nKSA/IHNlbGVjdGlvbi5jb250YWluc05vZGUoZWwsIHRydWUpIDogdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbGVjdE5vZGU6IGZ1bmN0aW9uIChub2RlLCBkb2MpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpLFxuICAgICAgICAgICAgICAgIHNlbCA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChkb2MsIHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCkge1xuICAgICAgICAgICAgZG9jLmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jLmdldFNlbGVjdGlvbigpLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogIENsZWFyIHRoZSBjdXJyZW50IGhpZ2hsaWdodGVkIHNlbGVjdGlvbiBhbmQgc2V0IHRoZSBjYXJldCB0byB0aGUgc3RhcnQgb3IgdGhlIGVuZCBvZiB0aGF0IHByaW9yIHNlbGVjdGlvbiwgZGVmYXVsdHMgdG8gZW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgQHBhcmFtIHtEb21Eb2N1bWVudH0gZG9jICAgICAgICAgICAgQ3VycmVudCBkb2N1bWVudFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBtb3ZlQ3Vyc29yVG9TdGFydCAgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIGNhcmV0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHByaW9yIHNlbGVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiAoZG9jLCBtb3ZlQ3Vyc29yVG9TdGFydCkge1xuICAgICAgICAgICAgaWYgKG1vdmVDdXJzb3JUb1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZG9jLmdldFNlbGVjdGlvbigpLmNvbGxhcHNlVG9TdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2MuZ2V0U2VsZWN0aW9uKCkuY29sbGFwc2VUb0VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3ZlIGN1cnNvciB0byB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoZSBnaXZlbiBvZmZzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge0RvbURvY3VtZW50fSBkb2MgICAgIEN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7RG9tRWxlbWVudH0gIG5vZGUgICAgRWxlbWVudCB3aGVyZSB0byBqdW1wXG4gICAgICAgICAqIEBwYXJhbSAge2ludGVnZXJ9ICAgICBvZmZzZXQgIFdoZXJlIGluIHRoZSBlbGVtZW50IHNob3VsZCB3ZSBqdW1wLCAwIGJ5IGRlZmF1bHRcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVDdXJzb3I6IGZ1bmN0aW9uIChkb2MsIG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QoZG9jLCBub2RlLCBvZmZzZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNlbGVjdGlvblJhbmdlOiBmdW5jdGlvbiAob3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IG93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExOTc0MDEvaG93LWNhbi1pLWdldC10aGUtZWxlbWVudC10aGUtY2FyZXQtaXMtaW4td2l0aC1qYXZhc2NyaXB0LXdoZW4tdXNpbmctY29udGVudGVkaVxuICAgICAgICAvLyBieSBZb3VcbiAgICAgICAgZ2V0U2VsZWN0aW9uU3RhcnQ6IGZ1bmN0aW9uIChvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkuYW5jaG9yTm9kZSxcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdGFydE5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbiA9IFNlbGVjdGlvbjtcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEV2ZW50cyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5iYXNlLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuZGlzYWJsZWRFdmVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXN0b21FdmVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB9O1xuXG4gICAgRXZlbnRzLnByb3RvdHlwZSA9IHtcbiAgICAgICAgSW5wdXRFdmVudE9uQ29udGVudGVkaXRhYmxlU3VwcG9ydGVkOiAhTWVkaXVtRWRpdG9yLnV0aWwuaXNJRSAmJiAhTWVkaXVtRWRpdG9yLnV0aWwuaXNFZGdlLFxuXG4gICAgICAgIC8vIEhlbHBlcnMgZm9yIGV2ZW50IGhhbmRsaW5nXG5cbiAgICAgICAgYXR0YWNoRE9NRXZlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goW3RhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoRE9NRXZlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mTGlzdGVuZXIodGFyZ2V0LCBldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpLFxuICAgICAgICAgICAgICAgIGU7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZSA9IHRoaXMuZXZlbnRzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgICAgICAgICAgZVswXS5yZW1vdmVFdmVudExpc3RlbmVyKGVbMV0sIGVbMl0sIGVbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluZGV4T2ZMaXN0ZW5lcjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB2YXIgaSwgbiwgaXRlbTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLmV2ZW50cy5sZW5ndGg7IGkgPCBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5ldmVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1bMF0gPT09IHRhcmdldCAmJiBpdGVtWzFdID09PSBldmVudCAmJiBpdGVtWzJdID09PSBsaXN0ZW5lciAmJiBpdGVtWzNdID09PSB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hBbGxET01FdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5ldmVudHMucG9wKCk7XG4gICAgICAgICAgICB3aGlsZSAoZSkge1xuICAgICAgICAgICAgICAgIGVbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihlWzFdLCBlWzJdLCBlWzNdKTtcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5ldmVudHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5hYmxlQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWRFdmVudHNbZXZlbnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kaXNhYmxlZEV2ZW50c1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzYWJsZUN1c3RvbUV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWRFdmVudHNbZXZlbnRdID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgICAgIGF0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwTGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUV2ZW50c1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUV2ZW50c1tldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hDdXN0b21FdmVudDogZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mQ3VzdG9tTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUV2ZW50c1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJZiBhcnJheSBpcyBlbXB0eSwgc2hvdWxkIGRldGFjaCBpbnRlcm5hbCBsaXN0ZW5lcnMgdmlhIGRlc3Ryb3lMaXN0ZW5lcigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5kZXhPZkN1c3RvbUxpc3RlbmVyOiBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCAhdGhpcy5jdXN0b21FdmVudHNbZXZlbnRdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRXZlbnRzW2V2ZW50XS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hBbGxDdXN0b21FdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRXZlbnRzID0ge307XG4gICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgZGV0YWNoIGludGVybmFsIGxpc3RlbmVycyBoZXJlIHZpYSBkZXN0cm95TGlzdGVuZXIoKVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXJDdXN0b21FdmVudDogZnVuY3Rpb24gKG5hbWUsIGRhdGEsIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXN0b21FdmVudHNbbmFtZV0gJiYgIXRoaXMuZGlzYWJsZWRFdmVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUV2ZW50c1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihkYXRhLCBlZGl0YWJsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2xlYW5pbmcgdXBcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFjaEFsbERPTUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hBbGxDdXN0b21FdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRXhlY0NvbW1hbmQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYmFzZS5lbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZS5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1lZGl1bS1mb2N1c2VkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTGlzdGVuaW5nIHRvIGNhbGxzIHRvIGRvY3VtZW50LmV4ZWNDb21tYW5kXG5cbiAgICAgICAgLy8gQXR0YWNoIGEgbGlzdGVuZXIgdG8gYmUgbm90aWZpZWQgd2hlbiBkb2N1bWVudC5leGVjQ29tbWFuZCBpcyBjYWxsZWRcbiAgICAgICAgYXR0YWNoVG9FeGVjQ29tbWFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhlY0NvbW1hbmRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcmUgYW4gaW5zdGFuY2Ugb2YgdGhlIGxpc3RlbmVyIHNvOlxuICAgICAgICAgICAgLy8gMSkgV2Ugb25seSBhdHRhY2ggdG8gZXhlY0NvbW1hbmQgb25jZVxuICAgICAgICAgICAgLy8gMikgV2UgY2FuIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXJcbiAgICAgICAgICAgIHRoaXMuZXhlY0NvbW1hbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChleGVjSW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRFeGVjQ29tbWFuZChleGVjSW5mbyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGV4ZWNDb21tYW5kIGhhcyBiZWVuIHdyYXBwZWQgY29ycmVjdGx5XG4gICAgICAgICAgICB0aGlzLndyYXBFeGVjQ29tbWFuZCgpO1xuXG4gICAgICAgICAgICAvLyBBZGQgbGlzdGVuZXIgdG8gbGlzdCBvZiBleGVjQ29tbWFuZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kLmxpc3RlbmVycy5wdXNoKHRoaXMuZXhlY0NvbW1hbmRMaXN0ZW5lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmVtb3ZlIG91ciBsaXN0ZW5lciBmb3IgY2FsbHMgdG8gZG9jdW1lbnQuZXhlY0NvbW1hbmRcbiAgICAgICAgZGV0YWNoRXhlY0NvbW1hbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGlmICghdGhpcy5leGVjQ29tbWFuZExpc3RlbmVyIHx8ICFkb2MuZXhlY0NvbW1hbmQubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGlzIGxpc3RlbmVyIGluIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgc28gaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGRvYy5leGVjQ29tbWFuZC5saXN0ZW5lcnMuaW5kZXhPZih0aGlzLmV4ZWNDb21tYW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZC5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGxpc3Qgb2YgbGlzdGVuZXJzIGlzIG5vdyBlbXB0eSwgcHV0IGV4ZWNDb21tYW5kIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG4gICAgICAgICAgICBpZiAoIWRvYy5leGVjQ29tbWFuZC5saXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bndyYXBFeGVjQ29tbWFuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdyYXAgZG9jdW1lbnQuZXhlY0NvbW1hbmQgaW4gYSBjdXN0b20gbWV0aG9kIHNvIHdlIGNhbiBsaXN0ZW4gdG8gY2FsbHMgdG8gaXRcbiAgICAgICAgd3JhcEV4ZWNDb21tYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgaW5zdGFuY2Ugb2YgTWVkaXVtRWRpdG9yIG9ubHkgd3JhcCBleGVjQ29tbWFuZCBvbmNlXG4gICAgICAgICAgICBpZiAoZG9jLmV4ZWNDb21tYW5kLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGVscGVyIG1ldGhvZCB0byBjYWxsIGFsbCBsaXN0ZW5lcnMgdG8gZXhlY0NvbW1hbmRcbiAgICAgICAgICAgIHZhciBjYWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGFyZ3MsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jLmV4ZWNDb21tYW5kLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZ3NbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgbWV0aG9kIGZvciBleGVjQ29tbWFuZCB3aGljaCB3aWxsOlxuICAgICAgICAgICAgLy8gMSkgQ2FsbCBkb2N1bWVudC5leGVjQ29tbWFuZCB3aXRoIHRoZSBjb3JyZWN0IGFyZ3VtZW50c1xuICAgICAgICAgICAgLy8gMikgTG9vcCB0aHJvdWdoIGFueSBsaXN0ZW5lcnMgYW5kIG5vdGlmeSB0aGVtIHRoYXQgZXhlY0NvbW1hbmQgd2FzIGNhbGxlZFxuICAgICAgICAgICAgLy8gICAgcGFzc2luZyBleHRyYSBpbmZvIG9uIHRoZSBjYWxsXG4gICAgICAgICAgICAvLyAzKSBSZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkb2MuZXhlY0NvbW1hbmQub3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9jLmV4ZWNDb21tYW5kLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbExpc3RlbmVycyhhcmdzLCByZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGV4ZWNDb21tYW5kXG4gICAgICAgICAgICB3cmFwcGVyLm9yaWcgPSBkb2MuZXhlY0NvbW1hbmQ7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBhbiBhcnJheSBmb3Igc3RvcmluZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHdyYXBwZXIubGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgIC8vIEhlbHBlciBmb3Igbm90aWZ5aW5nIGxpc3RlbmVyc1xuICAgICAgICAgICAgd3JhcHBlci5jYWxsTGlzdGVuZXJzID0gY2FsbExpc3RlbmVycztcblxuICAgICAgICAgICAgLy8gT3ZlcndyaXRlIGV4ZWNDb21tYW5kXG4gICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQgPSB3cmFwcGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJldmVydCBkb2N1bWVudC5leGVjQ29tbWFuZCBiYWNrIHRvIGl0cyBvcmlnaW5hbCBzZWxmXG4gICAgICAgIHVud3JhcEV4ZWNDb21tYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAoIWRvYy5leGVjQ29tbWFuZC5vcmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXhlY0NvbW1hbmQgdG8gcmV2ZXJ0IGJhY2tcbiAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZCA9IGRvYy5leGVjQ29tbWFuZC5vcmlnO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIExpc3RlbmluZyB0byBicm93c2VyIGV2ZW50cyB0byBlbWl0IGV2ZW50cyBtZWRpdW0tZWRpdG9yIGNhcmVzIGFib3V0XG4gICAgICAgIHNldHVwTGlzdGVuZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVybmFsSW50ZXJhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3Rpbmcgd2hlbiB1c2VyIGhhcyBpbnRlcmFjdGVkIHdpdGggZWxlbWVudHMgb3V0c2lkZSBvZiBNZWRpdW1FZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hET01FdmVudCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5ib2R5LCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVCb2R5TW91c2Vkb3duLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaERPTUV2ZW50KHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmJvZHksICdjbGljaycsIHRoaXMuaGFuZGxlQm9keUNsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaERPTUV2ZW50KHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmJvZHksICdmb2N1cycsIHRoaXMuaGFuZGxlQm9keUZvY3VzLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIHdoZW4gZm9jdXMgaXMgbG9zdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwTGlzdGVuZXIoJ2V4dGVybmFsSW50ZXJhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3Rpbmcgd2hlbiBmb2N1cyBtb3ZlcyBpbnRvIHNvbWUgcGFydCBvZiBNZWRpdW1FZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cExpc3RlbmVyKCdleHRlcm5hbEludGVyYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlSW5wdXQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBzZXR1cCBjYWNoZSBmb3Iga25vd2luZyB3aGVuIHRoZSBjb250ZW50IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudENhY2hlID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFzZS5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRDYWNoZVtlbGVtZW50LmdldEF0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci1pbmRleCcpXSA9IGVsZW1lbnQuaW5uZXJIVE1MO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggdG8gdGhlICdvbmlucHV0JyBldmVudCwgaGFuZGxlZCBjb3JyZWN0bHkgYnkgbW9zdCBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuSW5wdXRFdmVudE9uQ29udGVudGVkaXRhYmxlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hET01FdmVudChlbGVtZW50LCAnaW5wdXQnLCB0aGlzLmhhbmRsZUlucHV0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBicm93c2VycyB3aGljaCBkb24ndCBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBvbiBjb250ZW50ZWRpdGFibGUgKElFKVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSdsbCBhdHRhY2ggdG8gJ3NlbGVjdGlvbmNoYW5nZScgb24gdGhlIGRvY3VtZW50IGFuZCAna2V5cHJlc3MnIG9uIHRoZSBlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLklucHV0RXZlbnRPbkNvbnRlbnRlZGl0YWJsZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cExpc3RlbmVyKCdlZGl0YWJsZUtleXByZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleXByZXNzVXBkYXRlSW5wdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hET01FdmVudChkb2N1bWVudCwgJ3NlbGVjdGlvbmNoYW5nZScsIHRoaXMuaGFuZGxlRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gdG8gY2FsbHMgdG8gZXhlY0NvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9FeGVjQ29tbWFuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlQ2xpY2snOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3RpbmcgY2xpY2sgaW4gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0YWJsZUJsdXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3RpbmcgYmx1ciBpbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0YWJsZUtleXByZXNzJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGtleXByZXNzIGluIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9FYWNoRWxlbWVudCgna2V5cHJlc3MnLCB0aGlzLmhhbmRsZUtleXByZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVLZXl1cCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBrZXl1cCBpbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ2tleXVwJywgdGhpcy5oYW5kbGVLZXl1cCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlS2V5ZG93bic6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBrZXlkb3duIG9uIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9FYWNoRWxlbWVudCgna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlS2V5ZG93blNwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGtleWRvd24gZm9yIFNQQUNFIG9uIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBMaXN0ZW5lcignZWRpdGFibGVLZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlS2V5ZG93bkVudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGtleWRvd24gZm9yIEVOVEVSIG9uIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBMaXN0ZW5lcignZWRpdGFibGVLZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlS2V5ZG93blRhYic6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBrZXlkb3duIGZvciBUQUIgb24gdGhlIGNvbnRlbnRlZGl0YWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwTGlzdGVuZXIoJ2VkaXRhYmxlS2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0YWJsZUtleWRvd25EZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3Rpbmcga2V5ZG93biBmb3IgREVMRVRFL0JBQ0tTUEFDRSBvbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwTGlzdGVuZXIoJ2VkaXRhYmxlS2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0YWJsZU1vdXNlb3Zlcic6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBtb3VzZW92ZXIgb24gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdtb3VzZW92ZXInLCB0aGlzLmhhbmRsZU1vdXNlb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlRHJhZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBkcmFnb3ZlciBhbmQgZHJhZ2xlYXZlIG9uIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9FYWNoRWxlbWVudCgnZHJhZ292ZXInLCB0aGlzLmhhbmRsZURyYWdnaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdkcmFnbGVhdmUnLCB0aGlzLmhhbmRsZURyYWdnaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVEcm9wJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGRyb3Agb24gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdkcm9wJywgdGhpcy5oYW5kbGVEcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVQYXN0ZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBwYXN0ZSBvbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ3Bhc3RlJywgdGhpcy5oYW5kbGVQYXN0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaFRvRWFjaEVsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRE9NRXZlbnQoZWxlbWVudCwgbmFtZSwgaGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvY3VzRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9jdXMoZWxlbWVudCwgeyB0YXJnZXQ6IGVsZW1lbnQsIHR5cGU6ICdmb2N1cycgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRm9jdXM6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50T2JqKSB7XG4gICAgICAgICAgICB2YXIgdG9vbGJhciA9IHRoaXMuYmFzZS5nZXRFeHRlbnNpb25CeU5hbWUoJ3Rvb2xiYXInKSxcbiAgICAgICAgICAgICAgICB0b29sYmFyRWwgPSB0b29sYmFyID8gdG9vbGJhci5nZXRUb29sYmFyRWxlbWVudCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBhbmNob3JQcmV2aWV3ID0gdGhpcy5iYXNlLmdldEV4dGVuc2lvbkJ5TmFtZSgnYW5jaG9yLXByZXZpZXcnKSxcbiAgICAgICAgICAgICAgICBwcmV2aWV3RWwgPSAoYW5jaG9yUHJldmlldyAmJiBhbmNob3JQcmV2aWV3LmdldFByZXZpZXdFbGVtZW50KSA/IGFuY2hvclByZXZpZXcuZ2V0UHJldmlld0VsZW1lbnQoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgaGFkRm9jdXMgPSB0aGlzLmJhc2UuZ2V0Rm9jdXNlZEVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICB0b0ZvY3VzO1xuXG4gICAgICAgICAgICAvLyBGb3IgY2xpY2tzLCB3ZSBuZWVkIHRvIGtub3cgaWYgdGhlIG1vdXNlZG93biB0aGF0IGNhdXNlZCB0aGUgY2xpY2sgaGFwcGVuZWQgaW5zaWRlIHRoZSBleGlzdGluZyBmb2N1c2VkIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBJZiBzbywgd2UgZG9uJ3Qgd2FudCB0byBmb2N1cyBhbm90aGVyIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChoYWRGb2N1cyAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudE9iai50eXBlID09PSAnY2xpY2snICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE1vdXNlZG93blRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAoTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KGhhZEZvY3VzLCB0aGlzLmxhc3RNb3VzZWRvd25UYXJnZXQsIHRydWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5pc0Rlc2NlbmRhbnQodG9vbGJhckVsLCB0aGlzLmxhc3RNb3VzZWRvd25UYXJnZXQsIHRydWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5pc0Rlc2NlbmRhbnQocHJldmlld0VsLCB0aGlzLmxhc3RNb3VzZWRvd25UYXJnZXQsIHRydWUpKSkge1xuICAgICAgICAgICAgICAgIHRvRm9jdXMgPSBoYWRGb2N1cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0b0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlLmVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBwYXJ0IG9mIGFuIGVkaXRvciBlbGVtZW50LCB0aGlzIGlzIHRoZSBlbGVtZW50IGdldHRpbmcgZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b0ZvY3VzICYmIChNZWRpdW1FZGl0b3IudXRpbC5pc0Rlc2NlbmRhbnQoZWxlbWVudCwgdGFyZ2V0LCB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvRm9jdXMgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYmFpbCBpZiB3ZSBmb3VuZCBhbiBlbGVtZW50IHRoYXQncyBnZXR0aW5nIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXRvRm9jdXM7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgZXh0ZXJuYWwgKG5vdCBwYXJ0IG9mIHRoZSBlZGl0b3IsIHRvb2xiYXIsIG9yIGFuY2hvcnByZXZpZXcpXG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxFdmVudCA9ICFNZWRpdW1FZGl0b3IudXRpbC5pc0Rlc2NlbmRhbnQoaGFkRm9jdXMsIHRhcmdldCwgdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIU1lZGl1bUVkaXRvci51dGlsLmlzRGVzY2VuZGFudCh0b29sYmFyRWwsIHRhcmdldCwgdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIU1lZGl1bUVkaXRvci51dGlsLmlzRGVzY2VuZGFudChwcmV2aWV3RWwsIHRhcmdldCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0b0ZvY3VzICE9PSBoYWRGb2N1cykge1xuICAgICAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIGZvY3VzLCBhbmQgZm9jdXMgaXMgZ29pbmcgb3V0c2lkZSBvZiBlZGl0b3JcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBibHVyIGZvY3VzZWQgZWxlbWVudCBpZiBjbGlja2luZyBvbiBlZGl0b3IsIHRvb2xiYXIsIG9yIGFuY2hvcnByZXZpZXdcbiAgICAgICAgICAgICAgICBpZiAoaGFkRm9jdXMgJiYgZXh0ZXJuYWxFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGJsdXIgb24gdGhlIGVkaXRhYmxlIHRoYXQgaGFzIGxvc3QgZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgaGFkRm9jdXMucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1lZGl1bS1mb2N1c2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdibHVyJywgZXZlbnRPYmosIGhhZEZvY3VzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBmb2N1cyBpcyBnb2luZyBpbnRvIGFuIGVkaXRvciBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHRvRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBmb2N1cyBvbiB0aGUgZWRpdGFibGUgdGhhdCBub3cgaGFzIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIHRvRm9jdXMuc2V0QXR0cmlidXRlKCdkYXRhLW1lZGl1bS1mb2N1c2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdmb2N1cycsIGV2ZW50T2JqLCB0b0ZvY3VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlcm5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2V4dGVybmFsSW50ZXJhY3Rpb24nLCBldmVudE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlSW5wdXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50T2JqKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudENhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW4gZXZlbnQgdHJpZ2dlcmVkIHdoaWNoIHNpZ25pZmllcyB0aGF0IHRoZSB1c2VyIG1heSBoYXZlIGNoYW5nZWQgc29tZXRpbmdcbiAgICAgICAgICAgIC8vIExvb2sgaW4gb3VyIGNhY2hlIG9mIGlucHV0IGZvciB0aGUgY29udGVudGVkaXRhYmxlcyB0byBzZWUgaWYgc29tZXRoaW5nIGNoYW5nZWRcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaW5uZXJIVE1MICE9PSB0aGlzLmNvbnRlbnRDYWNoZVtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29udGVudCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGNoZWNrZWQsIGZpcmUgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlSW5wdXQnLCBldmVudE9iaiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGVudENhY2hlW2luZGV4XSA9IHRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gV2hlbiBzZWxlY3Rpb25jaGFuZ2UgZmlyZXMsIHRhcmdldCBhbmQgY3VycmVudCB0YXJnZXQgYXJlIHNldFxuICAgICAgICAgICAgLy8gdG8gZG9jdW1lbnQsIHNpbmNlIHRoaXMgaXMgd2hlcmUgdGhlIGV2ZW50IGlzIGhhbmRsZWRcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGN1cnJlbnRUYXJnZXQgd2lsbCBoYXZlIGFuICdhY3RpdmVFbGVtZW50JyBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBwb2ludCB0byB3aGF0ZXZlciBlbGVtZW50IGhhcyBmb2N1cy5cbiAgICAgICAgICAgIGlmIChldmVudC5jdXJyZW50VGFyZ2V0ICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZXZlbnQuY3VycmVudFRhcmdldC5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBsb29rIGF0IHRoZSAnYWN0aXZlRWxlbWVudCcgdG8gZGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3Rpb25jaGFuZ2UgaGFzXG4gICAgICAgICAgICAgICAgLy8gaGFwcGVuZWQgd2l0aGluIGEgY29udGVudGVkaXRhYmxlIG93bmVkIGJ5IHRoaXMgaW5zdGFuY2Ugb2YgTWVkaXVtRWRpdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlLmVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzRGVzY2VuZGFudChlbGVtZW50LCBhY3RpdmVFbGVtZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHNlbGVjdGlvbmNoYW5nZSBmaXJlZCB3aXRoaW4gb25lIG9mIG91ciBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dChjdXJyZW50VGFyZ2V0LCB7IHRhcmdldDogYWN0aXZlRWxlbWVudCwgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRG9jdW1lbnRFeGVjQ29tbWFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuZXhlY0NvbW1hbmQgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAgICAvLyBJZiBvbmUgb2Ygb3VyIGNvbnRlbnRlZGl0YWJsZXMgY3VycmVudGx5IGhhcyBmb2N1cywgd2Ugc2hvdWxkXG4gICAgICAgICAgICAvLyBhdHRlbXB0IHRvIHRyaWdnZXIgdGhlICdlZGl0YWJsZUlucHV0JyBldmVudFxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuYmFzZS5nZXRGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXQodGFyZ2V0LCB7IHRhcmdldDogdGFyZ2V0LCBjdXJyZW50VGFyZ2V0OiB0YXJnZXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQm9keUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9jdXMoZXZlbnQudGFyZ2V0LCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQm9keUZvY3VzOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9jdXMoZXZlbnQudGFyZ2V0LCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQm9keU1vdXNlZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3VzZWRvd25UYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlSW5wdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dChldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlQ2xpY2snLCBldmVudCwgZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQmx1cjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVCbHVyJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUtleXByZXNzOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdlZGl0YWJsZUtleXByZXNzJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBkb2luZyBtYW51YWwgZGV0ZWN0aW9uIG9mIHRoZSBlZGl0YWJsZUlucHV0IGV2ZW50IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGNoZWNrIGZvciBpbnB1dCBjaGFuZ2VzIGR1cmluZyAna2V5cHJlc3MnXG4gICAgICAgICAgICBpZiAodGhpcy5rZXlwcmVzc1VwZGF0ZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50T2JqID0geyB0YXJnZXQ6IGV2ZW50LnRhcmdldCwgY3VycmVudFRhcmdldDogZXZlbnQuY3VycmVudFRhcmdldCB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSW4gSUUsIHdlIG5lZWQgdG8gbGV0IHRoZSByZXN0IG9mIHRoZSBldmVudCBzdGFjayBjb21wbGV0ZSBiZWZvcmUgd2UgZGV0ZWN0XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlcyB0byBpbnB1dCwgc28gdXNpbmcgc2V0VGltZW91dCBoZXJlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXQoZXZlbnRPYmouY3VycmVudFRhcmdldCwgZXZlbnRPYmopO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlS2V5dXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlS2V5dXAnLCBldmVudCwgZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlTW91c2VvdmVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdlZGl0YWJsZU1vdXNlb3ZlcicsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVEcmFnZ2luZzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVEcmFnJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZURyb3A6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlRHJvcCcsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVQYXN0ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVQYXN0ZScsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVLZXlkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlS2V5ZG93bicsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzS2V5KGV2ZW50LCBNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLlNQQUNFKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVLZXlkb3duU3BhY2UnLCBldmVudCwgZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5FTlRFUikgfHwgKGV2ZW50LmN0cmxLZXkgJiYgTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuTSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdlZGl0YWJsZUtleWRvd25FbnRlcicsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzS2V5KGV2ZW50LCBNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLlRBQikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlS2V5ZG93blRhYicsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzS2V5KGV2ZW50LCBbTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5ERUxFVEUsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuQkFDS1NQQUNFXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlS2V5ZG93bkRlbGV0ZScsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNZWRpdW1FZGl0b3IuRXZlbnRzID0gRXZlbnRzO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgQnV0dG9uID0gTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5leHRlbmQoe1xuXG4gICAgICAgIC8qIEJ1dHRvbiBPcHRpb25zICovXG5cbiAgICAgICAgLyogYWN0aW9uOiBbc3RyaW5nXVxuICAgICAgICAgKiBUaGUgYWN0aW9uIGFyZ3VtZW50IHRvIHBhc3MgdG8gTWVkaXVtRWRpdG9yLmV4ZWNBY3Rpb24oKVxuICAgICAgICAgKiB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aW9uOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogYXJpYTogW3N0cmluZ11cbiAgICAgICAgICogVGhlIHZhbHVlIHRvIGFkZCBhcyB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb2YgdGhlIGJ1dHRvblxuICAgICAgICAgKiBlbGVtZW50IGRpc3BsYXllZCBpbiB0aGUgdG9vbGJhci5cbiAgICAgICAgICogVGhpcyBpcyBhbHNvIHVzZWQgYXMgdGhlIHRvb2x0aXAgZm9yIHRoZSBidXR0b25cbiAgICAgICAgICovXG4gICAgICAgIGFyaWE6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiB0YWdOYW1lczogW0FycmF5XVxuICAgICAgICAgKiBOT1RFOiBUaGlzIGlzIG5vdCB1c2VkIGlmIHVzZVF1ZXJ5U3RhdGUgaXMgc2V0IHRvIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFycmF5IG9mIGVsZW1lbnQgdGFnIG5hbWVzIHRoYXQgd291bGQgaW5kaWNhdGUgdGhhdCB0aGlzXG4gICAgICAgICAqIGJ1dHRvbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQuIElmIHRoaXMgYWN0aW9uIGhhcyBhbHJlYWR5XG4gICAgICAgICAqIGJlZW4gYXBwbGllZCwgdGhlIGJ1dHRvbiB3aWxsIGJlIGRpc3BsYXllZCBhcyAnYWN0aXZlJyBpbiB0aGUgdG9vbGJhclxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiBGb3IgJ2JvbGQnLCBpZiB0aGUgdGV4dCBpcyBldmVyIHdpdGhpbiBhIDxiPiBvciA8c3Ryb25nPlxuICAgICAgICAgKiB0YWcgdGhhdCBpbmRpY2F0ZXMgdGhlIHRleHQgaXMgYWxyZWFkeSBib2xkLiBTbyB0aGUgYXJyYXlcbiAgICAgICAgICogb2YgdGFnTmFtZXMgZm9yIGJvbGQgd291bGQgYmU6IFsnYicsICdzdHJvbmcnXVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnTmFtZXM6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBzdHlsZTogW09iamVjdF1cbiAgICAgICAgICogTk9URTogVGhpcyBpcyBub3QgdXNlZCBpZiB1c2VRdWVyeVN0YXRlIGlzIHNldCB0byB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHBhaXIgb2YgY3NzIHByb3BlcnR5ICYgdmFsdWUocykgdGhhdCBpbmRpY2F0ZSB0aGF0IHRoaXNcbiAgICAgICAgICogYnV0dG9uIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZC4gSWYgdGhpcyBhY3Rpb24gaGFzIGFscmVhZHlcbiAgICAgICAgICogYmVlbiBhcHBsaWVkLCB0aGUgYnV0dG9uIHdpbGwgYmUgZGlzcGxheWVkIGFzICdhY3RpdmUnIGluIHRoZSB0b29sYmFyXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgdGhlIG9iamVjdDpcbiAgICAgICAgICogICBwcm9wIFtTdHJpbmddOiBuYW1lIG9mIHRoZSBjc3MgcHJvcGVydHlcbiAgICAgICAgICogICB2YWx1ZSBbU3RyaW5nXTogdmFsdWUocykgb2YgdGhlIGNzcyBwcm9wZXJ0eVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIHNlcGFyYXRlZCBieSBhICd8J1xuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiBGb3IgJ2JvbGQnLCBpZiB0aGUgdGV4dCBpcyBldmVyIHdpdGhpbiBhbiBlbGVtZW50IHdpdGggYSAnZm9udC13ZWlnaHQnXG4gICAgICAgICAqIHN0eWxlIHByb3BlcnR5IHNldCB0byAnNzAwJyBvciAnYm9sZCcsIHRoYXQgaW5kaWNhdGVzIHRoZSB0ZXh0XG4gICAgICAgICAqIGlzIGFscmVhZHkgYm9sZC4gIFNvIHRoZSBzdHlsZSBvYmplY3QgZm9yIGJvbGQgd291bGQgYmU6XG4gICAgICAgICAqIHsgcHJvcDogJ2ZvbnQtd2VpZ2h0JywgdmFsdWU6ICc3MDB8Ym9sZCcgfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiB1c2VRdWVyeVN0YXRlOiBbYm9vbGVhbl1cbiAgICAgICAgICogRW5hYmxlcy9kaXNhYmxlcyB3aGV0aGVyIHRoaXMgYnV0dG9uIHNob3VsZCB1c2UgdGhlIGJ1aWx0LWluXG4gICAgICAgICAqIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKCkgbWV0aG9kIHRvIGRldGVybWluZSB3aGV0aGVyXG4gICAgICAgICAqIHRoZSBhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkLiAgSWYgdGhlIGFjdGlvbiBoYXMgYWxyZWFkeVxuICAgICAgICAgKiBiZWVuIGFwcGxpZWQsIHRoZSBidXR0b24gd2lsbCBiZSBkaXNwbGF5ZWQgYXMgJ2FjdGl2ZScgaW4gdGhlIHRvb2xiYXJcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICogRm9yICdib2xkJywgaWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGNvZGUgd2lsbCBjYWxsOlxuICAgICAgICAgKiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSgnYm9sZCcpIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlXG4gICAgICAgICAqIGJyb3dzZXIgdGhpbmtzIHRoZSB0ZXh0IGlzIGFscmVhZHkgYm9sZCwgYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUXVlcnlTdGF0ZTogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIGNvbnRlbnREZWZhdWx0OiBbc3RyaW5nXVxuICAgICAgICAgKiBEZWZhdWx0IGlubmVySFRNTCB0byBwdXQgaW5zaWRlIHRoZSBidXR0b25cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnREZWZhdWx0OiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogY29udGVudEZBOiBbc3RyaW5nXVxuICAgICAgICAgKiBUaGUgaW5uZXJIVE1MIHRvIHVzZSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhlIGJ1dHRvblxuICAgICAgICAgKiBpZiB0aGUgYGJ1dHRvbkxhYmVsc2Agb3B0aW9uIGZvciBNZWRpdW1FZGl0b3IgaXMgc2V0IHRvICdmb250YXdlc29tZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRGQTogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIGNsYXNzTGlzdDogW0FycmF5XVxuICAgICAgICAgKiBBbiBhcnJheSBvZiBjbGFzc05hbWVzIChzdHJpbmdzKSB0byBiZSBhZGRlZCB0byB0aGUgYnV0dG9uXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc0xpc3Q6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBhdHRyczogW29iamVjdF1cbiAgICAgICAgICogQSBzZXQgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCB0byB0aGUgYnV0dG9uIGFzIGN1c3RvbSBhdHRyaWJ1dGVzXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyczogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8vIFRoZSBidXR0b24gY29uc3RydWN0b3IgY2FuIG9wdGlvbmFsbHkgYWNjZXB0IHRoZSBuYW1lIG9mIGEgYnVpbHQtaW4gYnV0dG9uXG4gICAgICAgIC8vIChpZSAnYm9sZCcsICdpdGFsaWMnLCBldGMuKVxuICAgICAgICAvLyBXaGVuIHRoZSBuYW1lIG9mIGEgYnV0dG9uIGlzIHBhc3NlZCwgaXQgd2lsbCBpbml0aWFsaXplIGl0c2VsZiB3aXRoIHRoZVxuICAgICAgICAvLyBjb25maWd1cmF0aW9uIGZvciB0aGF0IGJ1dHRvblxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChCdXR0b24uaXNCdWlsdEluQnV0dG9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5jYWxsKHRoaXMsIHRoaXMuZGVmYXVsdHNbb3B0aW9uc10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKCk7XG4gICAgICAgICAgICB0aGlzLm9uKHRoaXMuYnV0dG9uLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGdldEJ1dHRvbjogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBpbXBsZW1lbnRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgICAgICAqIHRoZSB0b29sYmFyIGlzIGJlaW5nIGNyZWF0ZWQuICBUaGUgRE9NIEVsZW1lbnQgcmV0dXJuZWRcbiAgICAgICAgICogYnkgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSB0b29sYmFyIGFsb25nXG4gICAgICAgICAqIHdpdGggYW55IG90aGVyIGJ1dHRvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCdXR0b246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1dHRvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHRoaXMuYWN0aW9uID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuYWN0aW9uKHRoaXMuYmFzZS5vcHRpb25zKSA6IHRoaXMuYWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFyaWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHRoaXMuYXJpYSA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLmFyaWEodGhpcy5iYXNlLm9wdGlvbnMpIDogdGhpcy5hcmlhO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRhZ05hbWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB0aGlzLnRhZ05hbWVzID09PSAnZnVuY3Rpb24nKSA/IHRoaXMudGFnTmFtZXModGhpcy5iYXNlLm9wdGlvbnMpIDogdGhpcy50YWdOYW1lcztcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCdXR0b246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBidXR0b24gPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnREZWZhdWx0LFxuICAgICAgICAgICAgICAgIGFyaWFMYWJlbCA9IHRoaXMuZ2V0QXJpYSgpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbkxhYmVscyA9IHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdidXR0b25MYWJlbHMnKTtcbiAgICAgICAgICAgIC8vIEFkZCBjbGFzcyBuYW1lc1xuICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ21lZGl1bS1lZGl0b3ItYWN0aW9uJyk7XG4gICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnbWVkaXVtLWVkaXRvci1hY3Rpb24tJyArIHRoaXMubmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9uJywgdGhpcy5nZXRBY3Rpb24oKSk7XG4gICAgICAgICAgICBpZiAoYXJpYUxhYmVsKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBhcmlhTGFiZWwpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBhcmlhTGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyc1thdHRyXSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChidXR0b25MYWJlbHMgPT09ICdmb250YXdlc29tZScgJiYgdGhpcy5jb250ZW50RkEpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50RkE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgICAgIHJldHVybiBidXR0b247XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5nZXRBY3Rpb24oKTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhlY0FjdGlvbihhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdhY3RpdmVCdXR0b25DbGFzcycpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRJbmFjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5idXR0b24uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldEVkaXRvck9wdGlvbignYWN0aXZlQnV0dG9uQ2xhc3MnKSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5rbm93blN0YXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEFjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLmdldEVkaXRvck9wdGlvbignYWN0aXZlQnV0dG9uQ2xhc3MnKSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5rbm93blN0YXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHF1ZXJ5Q29tbWFuZFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VRdWVyeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlTdGF0ZSA9IHRoaXMuYmFzZS5xdWVyeUNvbW1hbmRTdGF0ZSh0aGlzLmdldEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBxdWVyeVN0YXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWxyZWFkeUFwcGxpZWQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgaXNNYXRjaCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRhZ05hbWVzID0gdGhpcy5nZXRUYWdOYW1lcygpLFxuICAgICAgICAgICAgICAgIHN0eWxlVmFscyxcbiAgICAgICAgICAgICAgICBjb21wdXRlZFN0eWxlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5rbm93blN0YXRlID09PSBmYWxzZSB8fCB0aGlzLmtub3duU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rbm93blN0YXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFnTmFtZXMgJiYgdGFnTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlzTWF0Y2ggPSB0YWdOYW1lcy5pbmRleE9mKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTWF0Y2ggJiYgdGhpcy5zdHlsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlVmFscyA9IHRoaXMuc3R5bGUudmFsdWUuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgICAgICBjb21wdXRlZFN0eWxlID0gdGhpcy53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMuc3R5bGUucHJvcCk7XG4gICAgICAgICAgICAgICAgc3R5bGVWYWxzLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMua25vd25TdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNNYXRjaCA9IChjb21wdXRlZFN0eWxlLmluZGV4T2YodmFsKSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGV4dC1kZWNvcmF0aW9uIGlzIG5vdCBpbmhlcml0ZWQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGZvciB0ZXh0LWRlY29yYXRpb24gZG9lc24ndCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgd3JpdGUgdG8ga25vd25TdGF0ZSBzbyB3ZSBjYW4gZmFsbGJhY2sgdG8gb3RoZXIgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaCB8fCB0aGlzLnN0eWxlLnByb3AgIT09ICd0ZXh0LWRlY29yYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rbm93blN0YXRlID0gaXNNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNNYXRjaDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgQnV0dG9uLmlzQnVpbHRJbkJ1dHRvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSAmJiBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24ucHJvdG90eXBlLmRlZmF1bHRzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgIH07XG5cbiAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24gPSBCdXR0b247XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbi5kZWZhdWx0czogW09iamVjdF1cbiAgICAgKiBTZXQgb2YgZGVmYXVsdCBjb25maWcgb3B0aW9ucyBmb3IgYWxsIG9mIHRoZSBidWlsdC1pbiBNZWRpdW1FZGl0b3IgYnV0dG9uc1xuICAgICAqL1xuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbi5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gICAgICAgICdib2xkJzoge1xuICAgICAgICAgICAgbmFtZTogJ2JvbGQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnYm9sZCcsXG4gICAgICAgICAgICBhcmlhOiAnYm9sZCcsXG4gICAgICAgICAgICB0YWdOYW1lczogWydiJywgJ3N0cm9uZyddLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwcm9wOiAnZm9udC13ZWlnaHQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnNzAwfGJvbGQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlUXVlcnlTdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+QjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1ib2xkXCI+PC9pPidcbiAgICAgICAgfSxcbiAgICAgICAgJ2l0YWxpYyc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdpdGFsaWMnLFxuICAgICAgICAgICAgYWN0aW9uOiAnaXRhbGljJyxcbiAgICAgICAgICAgIGFyaWE6ICdpdGFsaWMnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnaScsICdlbSddLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwcm9wOiAnZm9udC1zdHlsZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdpdGFsaWMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlUXVlcnlTdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+PGk+STwvaT48L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtaXRhbGljXCI+PC9pPidcbiAgICAgICAgfSxcbiAgICAgICAgJ3VuZGVybGluZSc6IHtcbiAgICAgICAgICAgIG5hbWU6ICd1bmRlcmxpbmUnLFxuICAgICAgICAgICAgYWN0aW9uOiAndW5kZXJsaW5lJyxcbiAgICAgICAgICAgIGFyaWE6ICd1bmRlcmxpbmUnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsndSddLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwcm9wOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ3VuZGVybGluZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1c2VRdWVyeVN0YXRlOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj48dT5VPC91PjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS11bmRlcmxpbmVcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnc3RyaWtldGhyb3VnaCc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdzdHJpa2V0aHJvdWdoJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ3N0cmlrZXRocm91Z2gnLFxuICAgICAgICAgICAgYXJpYTogJ3N0cmlrZSB0aHJvdWdoJyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ3N0cmlrZSddLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwcm9wOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ2xpbmUtdGhyb3VnaCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1c2VRdWVyeVN0YXRlOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8cz5BPC9zPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLXN0cmlrZXRocm91Z2hcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnc3VwZXJzY3JpcHQnOiB7XG4gICAgICAgICAgICBuYW1lOiAnc3VwZXJzY3JpcHQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnc3VwZXJzY3JpcHQnLFxuICAgICAgICAgICAgYXJpYTogJ3N1cGVyc2NyaXB0JyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ3N1cCddLFxuICAgICAgICAgICAgLyogZmlyZWZveCBkb2Vzbid0IGJlaGF2ZSB0aGUgd2F5IHdlIHdhbnQgaXQgdG8sIHNvIHdlIENBTidUIHVzZSBxdWVyeUNvbW1hbmRTdGF0ZSBmb3Igc3VwZXJzY3JpcHRcbiAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9ndWFyZGlhbi9zY3JpYmUvYmxvYi9tYXN0ZXIvQlJPV1NFUklOQ09OU0lTVEVOQ0lFUy5tZCNkb2N1bWVudHF1ZXJ5Y29tbWFuZHN0YXRlICovXG4gICAgICAgICAgICAvLyB1c2VRdWVyeVN0YXRlOiB0cnVlXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPng8c3VwPjE8L3N1cD48L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtc3VwZXJzY3JpcHRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnc3Vic2NyaXB0Jzoge1xuICAgICAgICAgICAgbmFtZTogJ3N1YnNjcmlwdCcsXG4gICAgICAgICAgICBhY3Rpb246ICdzdWJzY3JpcHQnLFxuICAgICAgICAgICAgYXJpYTogJ3N1YnNjcmlwdCcsXG4gICAgICAgICAgICB0YWdOYW1lczogWydzdWInXSxcbiAgICAgICAgICAgIC8qIGZpcmVmb3ggZG9lc24ndCBiZWhhdmUgdGhlIHdheSB3ZSB3YW50IGl0IHRvLCBzbyB3ZSBDQU4nVCB1c2UgcXVlcnlDb21tYW5kU3RhdGUgZm9yIHN1YnNjcmlwdFxuICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2d1YXJkaWFuL3NjcmliZS9ibG9iL21hc3Rlci9CUk9XU0VSSU5DT05TSVNURU5DSUVTLm1kI2RvY3VtZW50cXVlcnljb21tYW5kc3RhdGUgKi9cbiAgICAgICAgICAgIC8vIHVzZVF1ZXJ5U3RhdGU6IHRydWVcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+eDxzdWI+MTwvc3ViPjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1zdWJzY3JpcHRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnaW1hZ2UnOiB7XG4gICAgICAgICAgICBuYW1lOiAnaW1hZ2UnLFxuICAgICAgICAgICAgYWN0aW9uOiAnaW1hZ2UnLFxuICAgICAgICAgICAgYXJpYTogJ2ltYWdlJyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ2ltZyddLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5pbWFnZTwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1waWN0dXJlLW9cIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnb3JkZXJlZGxpc3QnOiB7XG4gICAgICAgICAgICBuYW1lOiAnb3JkZXJlZGxpc3QnLFxuICAgICAgICAgICAgYWN0aW9uOiAnaW5zZXJ0b3JkZXJlZGxpc3QnLFxuICAgICAgICAgICAgYXJpYTogJ29yZGVyZWQgbGlzdCcsXG4gICAgICAgICAgICB0YWdOYW1lczogWydvbCddLFxuICAgICAgICAgICAgdXNlUXVlcnlTdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+MS48L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtbGlzdC1vbFwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICd1bm9yZGVyZWRsaXN0Jzoge1xuICAgICAgICAgICAgbmFtZTogJ3Vub3JkZXJlZGxpc3QnLFxuICAgICAgICAgICAgYWN0aW9uOiAnaW5zZXJ0dW5vcmRlcmVkbGlzdCcsXG4gICAgICAgICAgICBhcmlhOiAndW5vcmRlcmVkIGxpc3QnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsndWwnXSxcbiAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGU6IHRydWUsXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPiZidWxsOzwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1saXN0LXVsXCI+PC9pPidcbiAgICAgICAgfSxcbiAgICAgICAgJ2luZGVudCc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRlbnQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnaW5kZW50JyxcbiAgICAgICAgICAgIGFyaWE6ICdpbmRlbnQnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFtdLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj4mcmFycjs8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtaW5kZW50XCI+PC9pPidcbiAgICAgICAgfSxcbiAgICAgICAgJ291dGRlbnQnOiB7XG4gICAgICAgICAgICBuYW1lOiAnb3V0ZGVudCcsXG4gICAgICAgICAgICBhY3Rpb246ICdvdXRkZW50JyxcbiAgICAgICAgICAgIGFyaWE6ICdvdXRkZW50JyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbXSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+JmxhcnI7PC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLW91dGRlbnRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnanVzdGlmeUNlbnRlcic6IHtcbiAgICAgICAgICAgIG5hbWU6ICdqdXN0aWZ5Q2VudGVyJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ2p1c3RpZnlDZW50ZXInLFxuICAgICAgICAgICAgYXJpYTogJ2NlbnRlciBqdXN0aWZ5JyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcHJvcDogJ3RleHQtYWxpZ24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnY2VudGVyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+QzwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1hbGlnbi1jZW50ZXJcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnanVzdGlmeUZ1bGwnOiB7XG4gICAgICAgICAgICBuYW1lOiAnanVzdGlmeUZ1bGwnLFxuICAgICAgICAgICAgYWN0aW9uOiAnanVzdGlmeUZ1bGwnLFxuICAgICAgICAgICAgYXJpYTogJ2Z1bGwganVzdGlmeScsXG4gICAgICAgICAgICB0YWdOYW1lczogW10sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHByb3A6ICd0ZXh0LWFsaWduJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ2p1c3RpZnknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5KPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWFsaWduLWp1c3RpZnlcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnanVzdGlmeUxlZnQnOiB7XG4gICAgICAgICAgICBuYW1lOiAnanVzdGlmeUxlZnQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnanVzdGlmeUxlZnQnLFxuICAgICAgICAgICAgYXJpYTogJ2xlZnQganVzdGlmeScsXG4gICAgICAgICAgICB0YWdOYW1lczogW10sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHByb3A6ICd0ZXh0LWFsaWduJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ2xlZnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5MPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWFsaWduLWxlZnRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnanVzdGlmeVJpZ2h0Jzoge1xuICAgICAgICAgICAgbmFtZTogJ2p1c3RpZnlSaWdodCcsXG4gICAgICAgICAgICBhY3Rpb246ICdqdXN0aWZ5UmlnaHQnLFxuICAgICAgICAgICAgYXJpYTogJ3JpZ2h0IGp1c3RpZnknLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFtdLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwcm9wOiAndGV4dC1hbGlnbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdyaWdodCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPlI8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtYWxpZ24tcmlnaHRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAvLyBLbm93biBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgbm90IHJlbW92ZWQsIG9yIG5vdCByZW1vdmVkIGNvbnNpc3RhbnRseSBhY3Jvc3MgYnJvd3NlcnM6XG4gICAgICAgIC8vIDxzcGFuPiwgPGxhYmVsPiwgPGJyPlxuICAgICAgICAncmVtb3ZlRm9ybWF0Jzoge1xuICAgICAgICAgICAgbmFtZTogJ3JlbW92ZUZvcm1hdCcsXG4gICAgICAgICAgICBhcmlhOiAncmVtb3ZlIGZvcm1hdHRpbmcnLFxuICAgICAgICAgICAgYWN0aW9uOiAncmVtb3ZlRm9ybWF0JyxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+WDwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1lcmFzZXJcIj48L2k+J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKioqKiBCdXR0b25zIGZvciBhcHBlbmRpbmcgYmxvY2sgZWxlbWVudHMgKGFwcGVuZC08ZWxlbWVudD4gYWN0aW9uKSAqKioqKi9cblxuICAgICAgICAncXVvdGUnOiB7XG4gICAgICAgICAgICBuYW1lOiAncXVvdGUnLFxuICAgICAgICAgICAgYWN0aW9uOiAnYXBwZW5kLWJsb2NrcXVvdGUnLFxuICAgICAgICAgICAgYXJpYTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnYmxvY2txdW90ZSddLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj4mbGRxdW87PC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLXF1b3RlLXJpZ2h0XCI+PC9pPidcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByZSc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdwcmUnLFxuICAgICAgICAgICAgYWN0aW9uOiAnYXBwZW5kLXByZScsXG4gICAgICAgICAgICBhcmlhOiAncHJlZm9ybWF0dGVkIHRleHQnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsncHJlJ10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPjAxMDE8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtY29kZSBmYS1sZ1wiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdoMSc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdoMScsXG4gICAgICAgICAgICBhY3Rpb246ICdhcHBlbmQtaDEnLFxuICAgICAgICAgICAgYXJpYTogJ2hlYWRlciB0eXBlIG9uZScsXG4gICAgICAgICAgICB0YWdOYW1lczogWydoMSddLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5IMTwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1oZWFkZXJcIj48c3VwPjE8L3N1cD4nXG4gICAgICAgIH0sXG4gICAgICAgICdoMic6IHtcbiAgICAgICAgICAgIG5hbWU6ICdoMicsXG4gICAgICAgICAgICBhY3Rpb246ICdhcHBlbmQtaDInLFxuICAgICAgICAgICAgYXJpYTogJ2hlYWRlciB0eXBlIHR3bycsXG4gICAgICAgICAgICB0YWdOYW1lczogWydoMiddLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5IMjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1oZWFkZXJcIj48c3VwPjI8L3N1cD4nXG4gICAgICAgIH0sXG4gICAgICAgICdoMyc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdoMycsXG4gICAgICAgICAgICBhY3Rpb246ICdhcHBlbmQtaDMnLFxuICAgICAgICAgICAgYXJpYTogJ2hlYWRlciB0eXBlIHRocmVlJyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ2gzJ10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPkgzPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWhlYWRlclwiPjxzdXA+Mzwvc3VwPidcbiAgICAgICAgfSxcbiAgICAgICAgJ2g0Jzoge1xuICAgICAgICAgICAgbmFtZTogJ2g0JyxcbiAgICAgICAgICAgIGFjdGlvbjogJ2FwcGVuZC1oNCcsXG4gICAgICAgICAgICBhcmlhOiAnaGVhZGVyIHR5cGUgZm91cicsXG4gICAgICAgICAgICB0YWdOYW1lczogWydoNCddLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5INDwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1oZWFkZXJcIj48c3VwPjQ8L3N1cD4nXG4gICAgICAgIH0sXG4gICAgICAgICdoNSc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdoNScsXG4gICAgICAgICAgICBhY3Rpb246ICdhcHBlbmQtaDUnLFxuICAgICAgICAgICAgYXJpYTogJ2hlYWRlciB0eXBlIGZpdmUnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnaDUnXSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+SDU8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtaGVhZGVyXCI+PHN1cD41PC9zdXA+J1xuICAgICAgICB9LFxuICAgICAgICAnaDYnOiB7XG4gICAgICAgICAgICBuYW1lOiAnaDYnLFxuICAgICAgICAgICAgYWN0aW9uOiAnYXBwZW5kLWg2JyxcbiAgICAgICAgICAgIGFyaWE6ICdoZWFkZXIgdHlwZSBzaXgnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnaDYnXSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+SDY8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtaGVhZGVyXCI+PHN1cD42PC9zdXA+J1xuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogQmFzZSBmdW5jdGlvbmFsaXR5IGZvciBhbiBleHRlbnNpb24gd2hpY2ggd2lsbCBkaXNwbGF5XG4gICAgICogYSAnZm9ybScgaW5zaWRlIHRoZSB0b29sYmFyXG4gICAgICovXG4gICAgdmFyIEZvcm1FeHRlbnNpb24gPSBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24uZXh0ZW5kKHtcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24ucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBkZWZhdWx0IGxhYmVscyBmb3IgdGhlIGZvcm0gYnV0dG9uc1xuICAgICAgICBmb3JtU2F2ZUxhYmVsOiAnJiMxMDAwMzsnLFxuICAgICAgICBmb3JtQ2xvc2VMYWJlbDogJyZ0aW1lczsnLFxuXG4gICAgICAgIC8qIGFjdGl2ZUNsYXNzOiBbc3RyaW5nXVxuICAgICAgICAgKiBzZXQgY2xhc3Mgd2hpY2ggYWRkZWQgdG8gc2hvd24gZm9ybVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlQ2xhc3M6ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItZm9ybS1hY3RpdmUnLFxuXG4gICAgICAgIC8qIGhhc0Zvcm06IFtib29sZWFuXVxuICAgICAgICAgKlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIGNhdXNlIGdldEZvcm0oKSB0byBiZSBjYWxsZWRcbiAgICAgICAgICogd2hlbiB0aGUgdG9vbGJhciBpcyBjcmVhdGVkLCBzbyB0aGUgZm9ybSBjYW4gYmUgYXBwZW5kZWRcbiAgICAgICAgICogaW5zaWRlIHRoZSB0b29sYmFyIGNvbnRhaW5lclxuICAgICAgICAgKi9cbiAgICAgICAgaGFzRm9ybTogdHJ1ZSxcblxuICAgICAgICAvKiBnZXRGb3JtOiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gaGFzRm9ybSBpcyB0cnVlLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgaW1wbGVtZW50ZWRcbiAgICAgICAgICogYW5kIHJldHVybiBhIERPTSBFbGVtZW50IHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgdG9cbiAgICAgICAgICogdGhlIHRvb2xiYXIgY29udGFpbmVyLiBUaGUgZm9ybSBzaG91bGQgc3RhcnQgaGlkZGVuLCBhbmRcbiAgICAgICAgICogdGhlIGV4dGVuc2lvbiBjYW4gY2hvb3NlIHdoZW4gdG8gaGlkZS9zaG93IGl0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICAvKiBpc0Rpc3BsYXllZDogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdHJ1ZS9mYWxzZSByZWZsZWN0aW5nXG4gICAgICAgICAqIHdoZXRoZXIgdGhlIGZvcm0gaXMgY3VycmVudGx5IGRpc3BsYXllZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNEaXNwbGF5ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0Zvcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGhpZGVGb3JtOiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHNob3cgdGhlIGZvcm0gZWxlbWVudCBpbnNpZGVcbiAgICAgICAgICogdGhlIHRvb2xiYXIgY29udGFpbmVyXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Rm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRm9ybSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Rm9ybSgpLmNsYXNzTGlzdC5hZGQodGhpcy5hY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogaGlkZUZvcm06IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgaGlkZSB0aGUgZm9ybSBlbGVtZW50IGluc2lkZVxuICAgICAgICAgKiB0aGUgdG9vbGJhciBjb250YWluZXJcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGb3JtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRGb3JtKCkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqIEhlbHBlcnMgKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgYXJlIGhlbHBlcnMgdGhhdCBhcmUgZWl0aGVyIHNldCBieSBNZWRpdW1FZGl0b3JcbiAgICAgICAgICogZHVyaW5nIGluaXRpYWxpemF0aW9uLCBvciBhcmUgaGVscGVyIG1ldGhvZHMgd2hpY2ggZWl0aGVyXG4gICAgICAgICAqIHJvdXRlIGNhbGxzIHRvIHRoZSBNZWRpdW1FZGl0b3IgaW5zdGFuY2Ugb3IgcHJvdmlkZSBjb21tb25cbiAgICAgICAgICogZnVuY3Rpb25hbGl0eSBmb3IgYWxsIGZvcm0gZXh0ZW5zaW9uc1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qIHNob3dUb29sYmFyRGVmYXVsdEFjdGlvbnM6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSGVscGVyIG1ldGhvZCB3aGljaCB3aWxsIHR1cm4gYmFjayB0aGUgdG9vbGJhciBhZnRlciBjYW5jZWxpbmdcbiAgICAgICAgICogdGhlIGN1c3RvbWl6ZWQgZm9ybVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1Rvb2xiYXJEZWZhdWx0QWN0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmJhc2UuZ2V0RXh0ZW5zaW9uQnlOYW1lKCd0b29sYmFyJyk7XG4gICAgICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgICAgIHRvb2xiYXIuc2hvd1Rvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGhpZGVUb29sYmFyRGVmYXVsdEFjdGlvbnM6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIHdpbGwgaGlkZSB0aGUgZGVmYXVsdCBjb250ZW50cyBvZiB0aGVcbiAgICAgICAgICogdG9vbGJhciwgYnV0IGxlYXZlIHRoZSB0b29sYmFyIGNvbnRhaW5lciBpbiB0aGUgc2FtZSBzdGF0ZVxuICAgICAgICAgKiB0byBhbGxvdyBhIGZvcm0gdG8gZGlzcGxheSBpdHMgY3VzdG9tIGNvbnRlbnRzIGluc2lkZSB0aGUgdG9vbGJhclxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZVRvb2xiYXJEZWZhdWx0QWN0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmJhc2UuZ2V0RXh0ZW5zaW9uQnlOYW1lKCd0b29sYmFyJyk7XG4gICAgICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgICAgIHRvb2xiYXIuaGlkZVRvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIHNldFRvb2xiYXJQb3NpdGlvbjogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggd2lsbCB1cGRhdGUgdGhlIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgICAgICAqIG9mIHRoZSB0b29sYmFyIGJhc2VkIG9uIHRoZSB0b29sYmFyIGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50XG4gICAgICAgICAqIHBvc2l0aW9uIG9mIHRoZSB1c2VyJ3Mgc2VsZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzZXRUb29sYmFyUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b29sYmFyID0gdGhpcy5iYXNlLmdldEV4dGVuc2lvbkJ5TmFtZSgndG9vbGJhcicpO1xuICAgICAgICAgICAgaWYgKHRvb2xiYXIpIHtcbiAgICAgICAgICAgICAgICB0b29sYmFyLnNldFRvb2xiYXJQb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb3JtID0gRm9ybUV4dGVuc2lvbjtcbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBBbmNob3JGb3JtID0gTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9ybS5leHRlbmQoe1xuICAgICAgICAvKiBBbmNob3IgRm9ybSBPcHRpb25zICovXG5cbiAgICAgICAgLyogY3VzdG9tQ2xhc3NPcHRpb246IFtzdHJpbmddICAocHJldmlvdXNseSBvcHRpb25zLmFuY2hvckJ1dHRvbiArIG9wdGlvbnMuYW5jaG9yQnV0dG9uQ2xhc3MpXG4gICAgICAgICAqIEN1c3RvbSBjbGFzcyBuYW1lIHRoZSB1c2VyIGNhbiBvcHRpb25hbGx5IGhhdmUgYWRkZWQgdG8gdGhlaXIgY3JlYXRlZCBsaW5rcyAoaWUgJ2J1dHRvbicpLlxuICAgICAgICAgKiBJZiBwYXNzZWQgYXMgYSBub24tZW1wdHkgc3RyaW5nLCBhIGNoZWNrYm94IHdpbGwgYmUgZGlzcGxheWVkIGFsbG93aW5nIHRoZSB1c2VyIHRvIGNob29zZVxuICAgICAgICAgKiB3aGV0aGVyIHRvIGhhdmUgdGhlIGNsYXNzIGFkZGVkIHRvIHRoZSBjcmVhdGVkIGxpbmsgb3Igbm90LlxuICAgICAgICAgKi9cbiAgICAgICAgY3VzdG9tQ2xhc3NPcHRpb246IG51bGwsXG5cbiAgICAgICAgLyogY3VzdG9tQ2xhc3NPcHRpb25UZXh0OiBbc3RyaW5nXVxuICAgICAgICAgKiB0ZXh0IHRvIGJlIHNob3duIGluIHRoZSBjaGVja2JveCB3aGVuIHRoZSBfX2N1c3RvbUNsYXNzT3B0aW9uX18gaXMgYmVpbmcgdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIGN1c3RvbUNsYXNzT3B0aW9uVGV4dDogJ0J1dHRvbicsXG5cbiAgICAgICAgLyogbGlua1ZhbGlkYXRpb246IFtib29sZWFuXSAgKHByZXZpb3VzbHkgb3B0aW9ucy5jaGVja0xpbmtGb3JtYXQpXG4gICAgICAgICAqIGVuYWJsZXMvZGlzYWJsZXMgY2hlY2sgZm9yIGNvbW1vbiBVUkwgcHJvdG9jb2xzIG9uIGFuY2hvciBsaW5rcy5cbiAgICAgICAgICovXG4gICAgICAgIGxpbmtWYWxpZGF0aW9uOiBmYWxzZSxcblxuICAgICAgICAvKiBwbGFjZWhvbGRlclRleHQ6IFtzdHJpbmddICAocHJldmlvdXNseSBvcHRpb25zLmFuY2hvcklucHV0UGxhY2Vob2xkZXIpXG4gICAgICAgICAqIHRleHQgdG8gYmUgc2hvd24gYXMgcGxhY2Vob2xkZXIgb2YgdGhlIGFuY2hvciBpbnB1dC5cbiAgICAgICAgICovXG4gICAgICAgIHBsYWNlaG9sZGVyVGV4dDogJ1Bhc3RlIG9yIHR5cGUgYSBsaW5rJyxcblxuICAgICAgICAvKiB0YXJnZXRDaGVja2JveDogW2Jvb2xlYW5dICAocHJldmlvdXNseSBvcHRpb25zLmFuY2hvclRhcmdldClcbiAgICAgICAgICogZW5hYmxlcy9kaXNhYmxlcyBkaXNwbGF5aW5nIGEgXCJPcGVuIGluIG5ldyB3aW5kb3dcIiBjaGVja2JveCwgd2hpY2ggd2hlbiBjaGVja2VkXG4gICAgICAgICAqIGNoYW5nZXMgdGhlIGB0YXJnZXRgIGF0dHJpYnV0ZSBvZiB0aGUgY3JlYXRlZCBsaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0Q2hlY2tib3g6IGZhbHNlLFxuXG4gICAgICAgIC8qIHRhcmdldENoZWNrYm94VGV4dDogW3N0cmluZ10gIChwcmV2aW91c2x5IG9wdGlvbnMuYW5jaG9ySW5wdXRDaGVja2JveExhYmVsKVxuICAgICAgICAgKiB0ZXh0IHRvIGJlIHNob3duIGluIHRoZSBjaGVja2JveCBlbmFibGVkIHZpYSB0aGUgX190YXJnZXRDaGVja2JveF9fIG9wdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRhcmdldENoZWNrYm94VGV4dDogJ09wZW4gaW4gbmV3IHdpbmRvdycsXG5cbiAgICAgICAgLy8gT3B0aW9ucyBmb3IgdGhlIEJ1dHRvbiBiYXNlIGNsYXNzXG4gICAgICAgIG5hbWU6ICdhbmNob3InLFxuICAgICAgICBhY3Rpb246ICdjcmVhdGVMaW5rJyxcbiAgICAgICAgYXJpYTogJ2xpbmsnLFxuICAgICAgICB0YWdOYW1lczogWydhJ10sXG4gICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+IzwvYj4nLFxuICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWxpbmtcIj48L2k+JyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb3JtLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUtleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGJ1dHRvbiB0aGUgdG9vbGJhciBpcyBjbGlja2VkXG4gICAgICAgIC8vIE92ZXJyaWRlcyBCdXR0b25FeHRlbnNpb24uaGFuZGxlQ2xpY2tcbiAgICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvblJhbmdlKHRoaXMuZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnIHx8XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJyB8fFxuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmdldENsb3Nlc3RUYWcoTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQocmFuZ2UpLCAnYScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0FjdGlvbigndW5saW5rJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdXNlciBoaXRzIHRoZSBkZWZpbmVkIHNob3J0Y3V0IChDVFJMIC8gQ09NTUFORCArIEspXG4gICAgICAgIGhhbmRsZUtleWRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzS2V5KGV2ZW50LCBNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLkspICYmIE1lZGl1bUVkaXRvci51dGlsLmlzTWV0YUN0cmxLZXkoZXZlbnQpICYmICFldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENhbGxlZCBieSBtZWRpdW0tZWRpdG9yIHRvIGFwcGVuZCBmb3JtIHRvIHRoZSB0b29sYmFyXG4gICAgICAgIGdldEZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5jcmVhdGVGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRlbXBsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBbXG4gICAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwibWVkaXVtLWVkaXRvci10b29sYmFyLWlucHV0XCIgcGxhY2Vob2xkZXI9XCInLCB0aGlzLnBsYWNlaG9sZGVyVGV4dCwgJ1wiPidcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHRlbXBsYXRlLnB1c2goXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItc2F2ZVwiPicsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2J1dHRvbkxhYmVscycpID09PSAnZm9udGF3ZXNvbWUnID8gJzxpIGNsYXNzPVwiZmEgZmEtY2hlY2tcIj48L2k+JyA6IHRoaXMuZm9ybVNhdmVMYWJlbCxcbiAgICAgICAgICAgICAgICAnPC9hPidcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRlbXBsYXRlLnB1c2goJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItY2xvc2VcIj4nLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdidXR0b25MYWJlbHMnKSA9PT0gJ2ZvbnRhd2Vzb21lJyA/ICc8aSBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9pPicgOiB0aGlzLmZvcm1DbG9zZUxhYmVsLFxuICAgICAgICAgICAgICAgICc8L2E+Jyk7XG5cbiAgICAgICAgICAgIC8vIGJvdGggb2YgdGhlc2Ugb3B0aW9ucyBhcmUgc2xpZ2h0bHkgbW9vdCB3aXRoIHRoZSBhYmlsaXR5IHRvXG4gICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgdmFyaW91cyBmb3JtIGJ1aWxkdXAvc2VyaWFsaXplIGZ1bmN0aW9ucy5cblxuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0Q2hlY2tib3gpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXhtZTogaWRlYWxseSwgdGhpcyB0YXJnZXRDaGVja2JveFRleHQgd291bGQgYmUgYSBmb3JtTGFiZWwgdG9vLFxuICAgICAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgaG93IHRvIGRlcHJlY2F0ZT8gYWxzbyBjb25zaWRlciBgZmEtYCBpY29uIGRlZmF1bHQgaW1wbGNhdGlvbnMuXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUucHVzaChcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItZm9ybS1yb3dcIj4nLFxuICAgICAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwibWVkaXVtLWVkaXRvci10b29sYmFyLWFuY2hvci10YXJnZXRcIj4nLFxuICAgICAgICAgICAgICAgICAgICAnPGxhYmVsPicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0Q2hlY2tib3hUZXh0LFxuICAgICAgICAgICAgICAgICAgICAnPC9sYWJlbD4nLFxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUNsYXNzT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gZml4bWU6IGV4cG9zZSB0aGlzIGBCdXR0b25gIHRleHQgYXMgYSBmb3JtTGFiZWwgcHJvcGVydHksIHRvb1xuICAgICAgICAgICAgICAgIC8vIGFuZCBwcm92aWRlIHNpbWlsYXIgYWNjZXNzIHRvIGEgYGZhLWAgaWNvbiBkZWZhdWx0LlxuICAgICAgICAgICAgICAgIHRlbXBsYXRlLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibWVkaXVtLWVkaXRvci10b29sYmFyLWZvcm0tcm93XCI+JyxcbiAgICAgICAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdG9vbGJhci1hbmNob3ItYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAgICAgJzxsYWJlbD4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUNsYXNzT3B0aW9uVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgJzwvbGFiZWw+JyxcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUuam9pbignJyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBVc2VkIGJ5IG1lZGl1bS1lZGl0b3Igd2hlbiB0aGUgZGVmYXVsdCB0b29sYmFyIGlzIHRvIGJlIGRpc3BsYXllZFxuICAgICAgICBpc0Rpc3BsYXllZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0ucHJvdG90eXBlLmlzRGlzcGxheWVkLmFwcGx5KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb3JtLnByb3RvdHlwZS5oaWRlRm9ybS5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0SW5wdXQoKS52YWx1ZSA9ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dGb3JtOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dCgpLFxuICAgICAgICAgICAgICAgIHRhcmdldENoZWNrYm94ID0gdGhpcy5nZXRBbmNob3JUYXJnZXRDaGVja2JveCgpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbkNoZWNrYm94ID0gdGhpcy5nZXRBbmNob3JCdXR0b25DaGVja2JveCgpO1xuXG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7IHVybDogJycgfTtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHN1cHBvcnQgdGhlICdzdHJpbmcnIGFyZ3VtZW50IGluIDYuMC4wXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBvcHRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5iYXNlLnNhdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9ybS5wcm90b3R5cGUuc2hvd0Zvcm0uYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNldFRvb2xiYXJQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IG9wdHMudXJsO1xuICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHRhcmdldCBjaGVja2JveCwgd2Ugd2FudCBpdCB0byBiZSBjaGVja2VkL3VuY2hlY2tlZFxuICAgICAgICAgICAgLy8gYmFzZWQgb24gd2hldGhlciB0aGUgZXhpc3RpbmcgbGluayBoYXMgdGFyZ2V0PV9ibGFua1xuICAgICAgICAgICAgaWYgKHRhcmdldENoZWNrYm94KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2hlY2tib3guY2hlY2tlZCA9IG9wdHMudGFyZ2V0ID09PSAnX2JsYW5rJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGN1c3RvbSBjbGFzcyBjaGVja2JveCwgd2Ugd2FudCBpdCB0byBiZSBjaGVja2VkL3VuY2hlY2tlZFxuICAgICAgICAgICAgLy8gYmFzZWQgb24gd2hldGhlciBhbiBleGlzdGluZyBsaW5rIGFscmVhZHkgaGFzIHRoZSBjbGFzc1xuICAgICAgICAgICAgaWYgKGJ1dHRvbkNoZWNrYm94KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IG9wdHMuYnV0dG9uQ2xhc3MgPyBvcHRzLmJ1dHRvbkNsYXNzLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgICAgICAgICBidXR0b25DaGVja2JveC5jaGVja2VkID0gKGNsYXNzTGlzdC5pbmRleE9mKHRoaXMuY3VzdG9tQ2xhc3NPcHRpb24pICE9PSAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGVkIGJ5IGNvcmUgd2hlbiB0ZWFyaW5nIGRvd24gbWVkaXVtLWVkaXRvciAoZGVzdHJveSlcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZvcm07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gY29yZSBtZXRob2RzXG5cbiAgICAgICAgZ2V0Rm9ybU9wdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIG5vIG5vdGlvbiBvZiBwcml2YXRlIGZ1bmN0aW9ucz8gd2FudGVkIGBfZ2V0Rm9ybU9wdHNgXG4gICAgICAgICAgICB2YXIgdGFyZ2V0Q2hlY2tib3ggPSB0aGlzLmdldEFuY2hvclRhcmdldENoZWNrYm94KCksXG4gICAgICAgICAgICAgICAgYnV0dG9uQ2hlY2tib3ggPSB0aGlzLmdldEFuY2hvckJ1dHRvbkNoZWNrYm94KCksXG4gICAgICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLmdldElucHV0KCkudmFsdWUudHJpbSgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGlua1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLnVybCA9IHRoaXMuY2hlY2tMaW5rRm9ybWF0KG9wdHMudXJsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0cy50YXJnZXQgPSAnX3NlbGYnO1xuICAgICAgICAgICAgaWYgKHRhcmdldENoZWNrYm94ICYmIHRhcmdldENoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnV0dG9uQ2hlY2tib3ggJiYgYnV0dG9uQ2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIG9wdHMuYnV0dG9uQ2xhc3MgPSB0aGlzLmN1c3RvbUNsYXNzT3B0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfSxcblxuICAgICAgICBkb0Zvcm1TYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuZ2V0Rm9ybU9wdHMoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVGb3JtU2F2ZShvcHRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wbGV0ZUZvcm1TYXZlOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgdGhpcy5iYXNlLnJlc3RvcmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY0FjdGlvbih0aGlzLmFjdGlvbiwgb3B0cyk7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY2hlY2tTZWxlY3Rpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjaGVja0xpbmtGb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gTWF0Y2hlcyBhbnkgYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMgZm9sbG93ZWQgYnkgOi8vXG4gICAgICAgICAgICAvLyBNYXRjaGVzIHByb3RvY29sIHJlbGF0aXZlIFwiLy9cIlxuICAgICAgICAgICAgLy8gTWF0Y2hlcyBjb21tb24gZXh0ZXJuYWwgcHJvdG9jb2xzIFwibWFpbHRvOlwiIFwidGVsOlwiIFwibWFwczpcIlxuICAgICAgICAgICAgdmFyIHVybFNjaGVtZVJlZ2V4ID0gL14oW2Etel0rOik/XFwvXFwvfF4obWFpbHRvfHRlbHxtYXBzKTovaSxcbiAgICAgICAgICAgIC8vIHZhciB0ZSBpcyBhIHJlZ2V4IGZvciBjaGVja2luZyBpZiB0aGUgc3RyaW5nIGlzIGEgdGVsZXBob25lIG51bWJlclxuICAgICAgICAgICAgdGVsUmVnZXggPSAvXlxcKz9cXHM/XFwoPyg/OlxcZFxccz9cXC0/XFwpPyl7MywyMH0kLztcbiAgICAgICAgICAgIGlmICh0ZWxSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAndGVsOicgKyB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFVSTCBzY2hlbWUgYW5kIGRlZmF1bHQgdG8gaHR0cDovLyBpZiBub25lIGZvdW5kXG4gICAgICAgICAgICAgICAgcmV0dXJuICh1cmxTY2hlbWVSZWdleC50ZXN0KHZhbHVlKSA/ICcnIDogJ2h0dHA6Ly8nKSArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvRm9ybUNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlLnJlc3RvcmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZS5jaGVja1NlbGVjdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGZvcm0gY3JlYXRpb24gYW5kIGV2ZW50IGhhbmRsaW5nXG4gICAgICAgIGF0dGFjaEZvcm1FdmVudHM6IGZ1bmN0aW9uIChmb3JtKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoJy5tZWRpdW0tZWRpdG9yLXRvb2xiYXItY2xvc2UnKSxcbiAgICAgICAgICAgICAgICBzYXZlID0gZm9ybS5xdWVyeVNlbGVjdG9yKCcubWVkaXVtLWVkaXRvci10b29sYmFyLXNhdmUnKSxcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcignLm1lZGl1bS1lZGl0b3ItdG9vbGJhci1pbnB1dCcpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIHRoZSBmb3JtIGl0c2VsZlxuICAgICAgICAgICAgdGhpcy5vbihmb3JtLCAnY2xpY2snLCB0aGlzLmhhbmRsZUZvcm1DbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHR5cGluZyBpbiB0aGUgdGV4dGJveFxuICAgICAgICAgICAgdGhpcy5vbihpbnB1dCwgJ2tleXVwJywgdGhpcy5oYW5kbGVUZXh0Ym94S2V5dXAuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBjbG9zZSBidXR0b24gY2xpY2tzXG4gICAgICAgICAgICB0aGlzLm9uKGNsb3NlLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsb3NlQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBzYXZlIGJ1dHRvbiBjbGlja3MgKGNhcHR1cmUpXG4gICAgICAgICAgICB0aGlzLm9uKHNhdmUsICdjbGljaycsIHRoaXMuaGFuZGxlU2F2ZUNsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZm9ybSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgLy8gQW5jaG9yIEZvcm0gKGRpdilcbiAgICAgICAgICAgIGZvcm0uY2xhc3NOYW1lID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhci1mb3JtJztcbiAgICAgICAgICAgIGZvcm0uaWQgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLWZvcm0tYW5jaG9yLScgKyB0aGlzLmdldEVkaXRvcklkKCk7XG4gICAgICAgICAgICBmb3JtLmlubmVySFRNTCA9IHRoaXMuZ2V0VGVtcGxhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoRm9ybUV2ZW50cyhmb3JtKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5wdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvcm0oKS5xdWVyeVNlbGVjdG9yKCdpbnB1dC5tZWRpdW0tZWRpdG9yLXRvb2xiYXItaW5wdXQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBbmNob3JUYXJnZXRDaGVja2JveDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybSgpLnF1ZXJ5U2VsZWN0b3IoJy5tZWRpdW0tZWRpdG9yLXRvb2xiYXItYW5jaG9yLXRhcmdldCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFuY2hvckJ1dHRvbkNoZWNrYm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkucXVlcnlTZWxlY3RvcignLm1lZGl1bS1lZGl0b3ItdG9vbGJhci1hbmNob3ItYnV0dG9uJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlVGV4dGJveEtleXVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZvciBFTlRFUiAtPiBjcmVhdGUgdGhlIGFuY2hvclxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuRU5URVIpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9Gb3JtU2F2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIEVTQ0FQRSAtPiBjbG9zZSB0aGUgZm9ybVxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuRVNDQVBFKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvRm9ybUNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUZvcm1DbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgbm90IHRvIGhpZGUgZm9ybSB3aGVuIGNsaWNraW5nIGluc2lkZSB0aGUgZm9ybVxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlU2F2ZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIENsaWNraW5nIFNhdmUgLT4gY3JlYXRlIHRoZSBhbmNob3JcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmRvRm9ybVNhdmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVDbG9zZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIENsaWNrIENsb3NlIC0+IGNsb3NlIHRoZSBmb3JtXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5kb0Zvcm1DYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuYW5jaG9yID0gQW5jaG9yRm9ybTtcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEFuY2hvclByZXZpZXcgPSBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLmV4dGVuZCh7XG4gICAgICAgIG5hbWU6ICdhbmNob3ItcHJldmlldycsXG5cbiAgICAgICAgLy8gQW5jaG9yIFByZXZpZXcgT3B0aW9uc1xuXG4gICAgICAgIC8qIGhpZGVEZWxheTogW251bWJlcl0gIChwcmV2aW91c2x5IG9wdGlvbnMuYW5jaG9yUHJldmlld0hpZGVEZWxheSlcbiAgICAgICAgICogdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gc2hvdyB0aGUgYW5jaG9yIHRhZyBwcmV2aWV3IGFmdGVyIHRoZSBtb3VzZSBoYXMgbGVmdCB0aGUgYW5jaG9yIHRhZy5cbiAgICAgICAgICovXG4gICAgICAgIGhpZGVEZWxheTogNTAwLFxuXG4gICAgICAgIC8qIHByZXZpZXdWYWx1ZVNlbGVjdG9yOiBbc3RyaW5nXVxuICAgICAgICAgKiB0aGUgZGVmYXVsdCBzZWxlY3RvciB0byBsb2NhdGUgd2hlcmUgdG8gcHV0IHRoZSBhY3RpdmVBbmNob3IgdmFsdWUgaW4gdGhlIHByZXZpZXdcbiAgICAgICAgICovXG4gICAgICAgIHByZXZpZXdWYWx1ZVNlbGVjdG9yOiAnYScsXG5cbiAgICAgICAgLyogc2hvd1doZW5Ub29sYmFySXNWaXNpYmxlOiBbYm9vbGVhbl1cbiAgICAgICAgICogZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhbmNob3IgdGFnIHByZXZpZXcgc2hvd3MgdXAgd2hlbiB0aGUgdG9vbGJhciBpcyB2aXNpYmxlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93V2hlblRvb2xiYXJJc1Zpc2libGU6IGZhbHNlLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldyA9IHRoaXMuY3JlYXRlUHJldmlldygpO1xuXG4gICAgICAgICAgICB0aGlzLmdldEVkaXRvck9wdGlvbignZWxlbWVudHNDb250YWluZXInKS5hcHBlbmRDaGlsZCh0aGlzLmFuY2hvclByZXZpZXcpO1xuXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWRpdGFibGVzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UHJldmlld0VsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuY2hvclByZXZpZXc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUHJldmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgZWwuaWQgPSAnbWVkaXVtLWVkaXRvci1hbmNob3ItcHJldmlldy0nICsgdGhpcy5nZXRFZGl0b3JJZCgpO1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gJ21lZGl1bS1lZGl0b3ItYW5jaG9yLXByZXZpZXcnO1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gdGhpcy5nZXRUZW1wbGF0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLm9uKGVsLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdG9vbGJhci1hbmNob3ItcHJldmlld1wiIGlkPVwibWVkaXVtLWVkaXRvci10b29sYmFyLWFuY2hvci1wcmV2aWV3XCI+JyArXG4gICAgICAgICAgICAgICAgJyAgICA8YSBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdG9vbGJhci1hbmNob3ItcHJldmlldy1pbm5lclwiPjwvYT4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmNob3JQcmV2aWV3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5jaG9yUHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYW5jaG9yUHJldmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFuY2hvclByZXZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZVByZXZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tZWRpdG9yLWFuY2hvci1wcmV2aWV3LWFjdGl2ZScpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVBbmNob3IgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dQcmV2aWV3OiBmdW5jdGlvbiAoYW5jaG9yRWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFuY2hvclByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZWRpdW0tZWRpdG9yLWFuY2hvci1wcmV2aWV3LWFjdGl2ZScpIHx8XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNhYmxlLXByZXZpZXcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aWV3VmFsdWVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5xdWVyeVNlbGVjdG9yKHRoaXMucHJldmlld1ZhbHVlU2VsZWN0b3IpLnRleHRDb250ZW50ID0gYW5jaG9yRWwuYXR0cmlidXRlcy5ocmVmLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5xdWVyeVNlbGVjdG9yKHRoaXMucHJldmlld1ZhbHVlU2VsZWN0b3IpLmhyZWYgPSBhbmNob3JFbC5hdHRyaWJ1dGVzLmhyZWYudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tdG9vbGJhci1hcnJvdy1vdmVyJyk7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLXRvb2xiYXItYXJyb3ctdW5kZXInKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmFuY2hvclByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZWRpdW0tZWRpdG9yLWFuY2hvci1wcmV2aWV3LWFjdGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JQcmV2aWV3LmNsYXNzTGlzdC5hZGQoJ21lZGl1bS1lZGl0b3ItYW5jaG9yLXByZXZpZXctYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQW5jaG9yID0gYW5jaG9yRWw7XG5cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25QcmV2aWV3KCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFByZXZpZXdIYW5kbGVycygpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBwb3NpdGlvblByZXZpZXc6IGZ1bmN0aW9uIChhY3RpdmVBbmNob3IpIHtcbiAgICAgICAgICAgIGFjdGl2ZUFuY2hvciA9IGFjdGl2ZUFuY2hvciB8fCB0aGlzLmFjdGl2ZUFuY2hvcjtcbiAgICAgICAgICAgIHZhciBidXR0b25IZWlnaHQgPSB0aGlzLmFuY2hvclByZXZpZXcub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gYWN0aXZlQW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIG1pZGRsZUJvdW5kYXJ5ID0gKGJvdW5kYXJ5LmxlZnQgKyBib3VuZGFyeS5yaWdodCkgLyAyLFxuICAgICAgICAgICAgICAgIGRpZmZMZWZ0ID0gdGhpcy5kaWZmTGVmdCxcbiAgICAgICAgICAgICAgICBkaWZmVG9wID0gdGhpcy5kaWZmVG9wLFxuICAgICAgICAgICAgICAgIGhhbGZPZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGVmdDtcblxuICAgICAgICAgICAgaGFsZk9mZnNldFdpZHRoID0gdGhpcy5hbmNob3JQcmV2aWV3Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgICAgIHZhciB0b29sYmFyRXh0ZW5zaW9uID0gdGhpcy5iYXNlLmdldEV4dGVuc2lvbkJ5TmFtZSgndG9vbGJhcicpO1xuICAgICAgICAgICAgaWYgKHRvb2xiYXJFeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBkaWZmTGVmdCA9IHRvb2xiYXJFeHRlbnNpb24uZGlmZkxlZnQ7XG4gICAgICAgICAgICAgICAgZGlmZlRvcCA9IHRvb2xiYXJFeHRlbnNpb24uZGlmZlRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHRMZWZ0ID0gZGlmZkxlZnQgLSBoYWxmT2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKGJ1dHRvbkhlaWdodCArIGJvdW5kYXJ5LmJvdHRvbSAtIGRpZmZUb3AgKyB0aGlzLndpbmRvdy5wYWdlWU9mZnNldCAtIHRoaXMuYW5jaG9yUHJldmlldy5vZmZzZXRIZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5zdHlsZS5yaWdodCA9ICdpbml0aWFsJztcbiAgICAgICAgICAgIGlmIChtaWRkbGVCb3VuZGFyeSA8IGhhbGZPZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5zdHlsZS5sZWZ0ID0gZGVmYXVsdExlZnQgKyBoYWxmT2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5zdHlsZS5yaWdodCA9ICdpbml0aWFsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHRoaXMud2luZG93LmlubmVyV2lkdGggLSBtaWRkbGVCb3VuZGFyeSkgPCBoYWxmT2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUubGVmdCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUucmlnaHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUubGVmdCA9IGRlZmF1bHRMZWZ0ICsgbWlkZGxlQm91bmRhcnkgKyAncHgnO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5zdHlsZS5yaWdodCA9ICdpbml0aWFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hUb0VkaXRhYmxlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlTW91c2VvdmVyJywgdGhpcy5oYW5kbGVFZGl0YWJsZU1vdXNlb3Zlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yRXh0ZW5zaW9uID0gdGhpcy5iYXNlLmdldEV4dGVuc2lvbkJ5TmFtZSgnYW5jaG9yJyksXG4gICAgICAgICAgICAgICAgYWN0aXZlQW5jaG9yID0gdGhpcy5hY3RpdmVBbmNob3I7XG5cbiAgICAgICAgICAgIGlmIChhbmNob3JFeHRlbnNpb24gJiYgYWN0aXZlQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZS5zZWxlY3RFbGVtZW50KHRoaXMuYWN0aXZlQW5jaG9yKTtcblxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIHNldFRpbWVvdXQgKyBkZWxheSBiZWNhdXNlOlxuICAgICAgICAgICAgICAgIC8vIFdlIG1heSBhY3R1YWxseSBiZSBkaXNwbGF5aW5nIHRoZSBhbmNob3IgZm9ybSwgd2hpY2ggc2hvdWxkIGJlIGNvbnRyb2xsZWQgYnkgZGVsYXlcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2UuZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFjdGl2ZUFuY2hvci5hdHRyaWJ1dGVzLmhyZWYudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBhY3RpdmVBbmNob3IuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzczogYWN0aXZlQW5jaG9yLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckV4dGVuc2lvbi5zaG93Rm9ybShvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUFuY2hvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhpZGVQcmV2aWV3KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQW5jaG9yTW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yVG9QcmV2aWV3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuYWN0aXZlQW5jaG9yLCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlQW5jaG9yTW91c2VvdXQpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZUhhbmRsZUFuY2hvck1vdXNlb3V0ID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVFZGl0YWJsZU1vdXNlb3ZlcjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gTWVkaXVtRWRpdG9yLnV0aWwuZ2V0Q2xvc2VzdFRhZyhldmVudC50YXJnZXQsICdhJyk7XG5cbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlY3QgZW1wdHkgaHJlZiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBUaGUgYnJvd3NlciB3aWxsIG1ha2UgaHJlZj1cIlwiIG9yIGhyZWY9XCIjdG9wXCJcbiAgICAgICAgICAgIC8vIGludG8gYWJzb2x1dGUgdXJscyB3aGVuIGFjY2Vzc2VkIGFzIGV2ZW50LnRhcmdldC5ocmVmLCBzbyBjaGVjayB0aGUgaHRtbFxuICAgICAgICAgICAgaWYgKCEvaHJlZj1bXCInXVxcUytbXCInXS8udGVzdCh0YXJnZXQub3V0ZXJIVE1MKSB8fCAvaHJlZj1bXCInXSNcXFMrW1wiJ10vLnRlc3QodGFyZ2V0Lm91dGVySFRNTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSBzaG93IHdoZW4gdG9vbGJhciBpcyBub3QgcHJlc2VudFxuICAgICAgICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmJhc2UuZ2V0RXh0ZW5zaW9uQnlOYW1lKCd0b29sYmFyJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvd1doZW5Ub29sYmFySXNWaXNpYmxlICYmIHRvb2xiYXIgJiYgdG9vbGJhci5pc0Rpc3BsYXllZCAmJiB0b29sYmFyLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGV0YWNoIGhhbmRsZXIgZm9yIG90aGVyIGFuY2hvciBpbiBjYXNlIHdlIGhvdmVyZWQgbXVsdGlwbGUgYW5jaG9ycyBxdWlja2x5XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVBbmNob3IgJiYgdGhpcy5hY3RpdmVBbmNob3IgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoUHJldmlld0hhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYW5jaG9yVG9QcmV2aWV3ID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlSGFuZGxlQW5jaG9yTW91c2VvdXQgPSB0aGlzLmhhbmRsZUFuY2hvck1vdXNlb3V0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKHRoaXMuYW5jaG9yVG9QcmV2aWV3LCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlQW5jaG9yTW91c2VvdXQpO1xuICAgICAgICAgICAgLy8gVXNpbmcgc2V0VGltZW91dCArIGRlbGF5IGJlY2F1c2U6XG4gICAgICAgICAgICAvLyAtIFdlJ3JlIGdvaW5nIHRvIHNob3cgdGhlIGFuY2hvciBwcmV2aWV3IGFjY29yZGluZyB0byB0aGUgY29uZmlndXJlZCBkZWxheVxuICAgICAgICAgICAgLy8gICBpZiB0aGUgbW91c2UgaGFzIG5vdCBsZWZ0IHRoZSBhbmNob3IgdGFnIGluIHRoYXQgdGltZVxuICAgICAgICAgICAgdGhpcy5iYXNlLmRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmNob3JUb1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93UHJldmlldyh0aGlzLmFuY2hvclRvUHJldmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVQcmV2aWV3TW91c2VvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RPdmVyID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJpbmcgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVByZXZpZXdNb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgIS9hbmNob3ItcHJldmlldy8udGVzdChldmVudC5yZWxhdGVkVGFyZ2V0LmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlUHJldmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaG92ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkdXJyID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRoaXMubGFzdE92ZXI7XG4gICAgICAgICAgICBpZiAoZHVyciA+IHRoaXMuaGlkZURlbGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gaGlkZSB0aGUgcHJldmlldyAxLzIgc2Vjb25kIGFmdGVyIG1vdXNlIGxlYXZlcyB0aGUgbGlua1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoUHJldmlld0hhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoUHJldmlld0hhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjbGVhbnVwXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUhhbmRsZVByZXZpZXdNb3VzZW92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZih0aGlzLmFuY2hvclByZXZpZXcsICdtb3VzZW92ZXInLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3Zlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5hbmNob3JQcmV2aWV3LCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVBbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5hY3RpdmVBbmNob3IsICdtb3VzZW92ZXInLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuYWN0aXZlQW5jaG9yLCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaGlkZVByZXZpZXcoKTtcblxuICAgICAgICAgICAgdGhpcy5ob3ZlcmluZyA9IHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdmVyID0gdGhpcy5pbnN0YW5jZUhhbmRsZVByZXZpZXdNb3VzZW91dCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ETzogYnJlYWsgdXAgbWV0aG9kIGFuZCBleHRyYWN0IG91dCBoYW5kbGVyc1xuICAgICAgICBhdHRhY2hQcmV2aWV3SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdE92ZXIgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5ob3ZlcmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdmVyID0gdGhpcy5oYW5kbGVQcmV2aWV3TW91c2VvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3V0ID0gdGhpcy5oYW5kbGVQcmV2aWV3TW91c2VvdXQuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy51cGRhdGVQcmV2aWV3LmJpbmQodGhpcyksIDIwMCk7XG5cbiAgICAgICAgICAgIHRoaXMub24odGhpcy5hbmNob3JQcmV2aWV3LCAnbW91c2VvdmVyJywgdGhpcy5pbnN0YW5jZUhhbmRsZVByZXZpZXdNb3VzZW92ZXIpO1xuICAgICAgICAgICAgdGhpcy5vbih0aGlzLmFuY2hvclByZXZpZXcsICdtb3VzZW91dCcsIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdXQpO1xuICAgICAgICAgICAgdGhpcy5vbih0aGlzLmFjdGl2ZUFuY2hvciwgJ21vdXNlb3ZlcicsIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdmVyKTtcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5hY3RpdmVBbmNob3IsICdtb3VzZW91dCcsIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdXQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5hbmNob3JQcmV2aWV3ID0gQW5jaG9yUHJldmlldztcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFdISVRFU1BBQ0VfQ0hBUlMsXG4gICAgICAgIEtOT1dOX1RMRFNfRlJBR01FTlQsXG4gICAgICAgIExJTktfUkVHRVhQX1RFWFQsXG4gICAgICAgIEtOT1dOX1RMRFNfUkVHRVhQO1xuXG4gICAgV0hJVEVTUEFDRV9DSEFSUyA9IFsnICcsICdcXHQnLCAnXFxuJywgJ1xccicsICdcXHUwMEEwJywgJ1xcdTIwMDAnLCAnXFx1MjAwMScsICdcXHUyMDAyJywgJ1xcdTIwMDMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcdTIwMjgnLCAnXFx1MjAyOSddO1xuICAgIEtOT1dOX1RMRFNfRlJBR01FTlQgPSAnY29tfG5ldHxvcmd8ZWR1fGdvdnxtaWx8YWVyb3xhc2lhfGJpenxjYXR8Y29vcHxpbmZvfGludHxqb2JzfG1vYml8bXVzZXVtfG5hbWV8cG9zdHxwcm98dGVsfHRyYXZlbHwnICtcbiAgICAgICAgJ3h4eHxhY3xhZHxhZXxhZnxhZ3xhaXxhbHxhbXxhbnxhb3xhcXxhcnxhc3xhdHxhdXxhd3xheHxhenxiYXxiYnxiZHxiZXxiZnxiZ3xiaHxiaXxianxibXxibnxib3xicnxic3xidHxidnxid3xieXwnICtcbiAgICAgICAgJ2J6fGNhfGNjfGNkfGNmfGNnfGNofGNpfGNrfGNsfGNtfGNufGNvfGNyfGNzfGN1fGN2fGN4fGN5fGN6fGRkfGRlfGRqfGRrfGRtfGRvfGR6fGVjfGVlfGVnfGVofGVyfGVzfGV0fGV1fGZpfGZqfCcgK1xuICAgICAgICAnZmt8Zm18Zm98ZnJ8Z2F8Z2J8Z2R8Z2V8Z2Z8Z2d8Z2h8Z2l8Z2x8Z218Z258Z3B8Z3F8Z3J8Z3N8Z3R8Z3V8Z3d8Z3l8aGt8aG18aG58aHJ8aHR8aHV8aWR8aWV8aWx8aW18aW58aW98aXF8aXJ8JyArXG4gICAgICAgICdpc3xpdHxqZXxqbXxqb3xqcHxrZXxrZ3xraHxraXxrbXxrbnxrcHxrcnxrd3xreXxrenxsYXxsYnxsY3xsaXxsa3xscnxsc3xsdHxsdXxsdnxseXxtYXxtY3xtZHxtZXxtZ3xtaHxta3xtbHxtbXwnICtcbiAgICAgICAgJ21ufG1vfG1wfG1xfG1yfG1zfG10fG11fG12fG13fG14fG15fG16fG5hfG5jfG5lfG5mfG5nfG5pfG5sfG5vfG5wfG5yfG51fG56fG9tfHBhfHBlfHBmfHBnfHBofHBrfHBsfHBtfHBufHByfHBzfCcgK1xuICAgICAgICAncHR8cHd8cHl8cWF8cmV8cm98cnN8cnV8cnd8c2F8c2J8c2N8c2R8c2V8c2d8c2h8c2l8c2p8amF8c2t8c2x8c218c258c298c3J8c3N8c3R8c3V8c3Z8c3h8c3l8c3p8dGN8dGR8dGZ8dGd8dGh8JyArXG4gICAgICAgICd0anx0a3x0bHx0bXx0bnx0b3x0cHx0cnx0dHx0dnx0d3x0enx1YXx1Z3x1a3x1c3x1eXx1enx2YXx2Y3x2ZXx2Z3x2aXx2bnx2dXx3Znx3c3x5ZXx5dHx5dXx6YXx6bXx6dyc7XG5cbiAgICBMSU5LX1JFR0VYUF9URVhUID1cbiAgICAgICAgJygnICtcbiAgICAgICAgLy8gVmVyc2lvbiBvZiBHcnViZXIgVVJMIFJlZ2V4cCBvcHRpbWl6ZWQgZm9yIEpTOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzczMzY0MFxuICAgICAgICAnKCg/OihodHRwcz86Ly98ZnRwcz86Ly98bm50cDovLyl8d3d3XFxcXGR7MCwzfVsuXXxbYS16MC05LlxcXFwtXStbLl0oJyArIEtOT1dOX1RMRFNfRlJBR01FTlQgKyAnKVxcXFxcXC8pXFxcXFMrKD86W15cXFxcc2AhXFxcXFtcXFxcXXt9OzpcXCdcXFwiLiw/XFx1MDBBQlxcdTAwQkJcXHUyMDFDXFx1MjAxRFxcdTIwMThcXHUyMDE5XSkpJyArXG4gICAgICAgIC8vIEFkZGl0aW9uIHRvIGFib3ZlIFJlZ2V4cCB0byBzdXBwb3J0IGJhcmUgZG9tYWlucy9vbmUgbGV2ZWwgc3ViZG9tYWlucyB3aXRoIGNvbW1vbiBub24taTE4biBUTERzIGFuZCB3aXRob3V0IHd3dyBwcmVmaXg6XG4gICAgICAgICcpfCgoW2EtejAtOVxcXFwtXStcXFxcLik/W2EtejAtOVxcXFwtXStcXFxcLignICsgS05PV05fVExEU19GUkFHTUVOVCArICcpKSc7XG5cbiAgICBLTk9XTl9UTERTX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ14oJyArIEtOT1dOX1RMRFNfRlJBR01FTlQgKyAnKSQnLCAnaScpO1xuXG4gICAgZnVuY3Rpb24gbm9kZUlzTm90SW5zaWRlQW5jaG9yVGFnKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFNZWRpdW1FZGl0b3IudXRpbC5nZXRDbG9zZXN0VGFnKG5vZGUsICdhJyk7XG4gICAgfVxuXG4gICAgdmFyIEF1dG9MaW5rID0gTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5leHRlbmQoe1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUV2ZW50SGFuZGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUtleXByZXNzJywgdGhpcy5vbktleXByZXNzLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlQmx1cicsIHRoaXMub25CbHVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgLy8gTVMgSUUgaGFzIGl0J3Mgb3duIGF1dG8tVVJMIGRldGVjdCBmZWF0dXJlIGJ1dCBvdXJzIGlzIGJldHRlciBpbiBzb21lIHdheXMuIEJlIGNvbnNpc3RlbnQuXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmV4ZWNDb21tYW5kKCdBdXRvVXJsRGV0ZWN0JywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0xhc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUluc3RhbmNlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2luZG93Ll9tZWRpdW1FZGl0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMud2luZG93Ll9tZWRpdW1FZGl0b3JzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IgIT09IG51bGwgJiYgZWRpdG9yLmdldEV4dGVuc2lvbkJ5TmFtZSgnYXV0b0xpbmsnKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVJbnN0YW5jZXMgPT09IDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVHVybiBBdXRvVXJsRGV0ZWN0IGJhY2sgb25cbiAgICAgICAgICAgIGlmICh0aGlzLmRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCgnQXV0b1VybERldGVjdCcpICYmIHRoaXMuaXNMYXN0SW5zdGFuY2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ0F1dG9VcmxEZXRlY3QnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25CbHVyOiBmdW5jdGlvbiAoYmx1ckV2ZW50LCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtTGlua2luZyhlZGl0YWJsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25LZXlwcmVzczogZnVuY3Rpb24gKGtleVByZXNzRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVFdmVudEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoa2V5UHJlc3NFdmVudCwgW01lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuU1BBQ0UsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuRU5URVJdKSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlcmZvcm1MaW5raW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgLy8gU2F2aW5nL3Jlc3RvcmluZyB0aGUgc2VsZWN0aW9uIGluIHRoZSBtaWRkbGUgb2YgYSBrZXlwcmVzcyBkb2Vzbid0IHdvcmsgd2VsbC4uLlxuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybUxpbmtpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsID0gdGhpcy5iYXNlLmV4cG9ydFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVyZm9ybUxpbmtpbmcoa2V5UHJlc3NFdmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB0cnVlIGZvciBmYXZvckxhdGVyU2VsZWN0aW9uQW5jaG9yIC0gdGhpcyBpcyBuZWVkZWQgZm9yIGxpbmtzIGF0IHRoZSBlbmQgb2YgYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBpbiBNUyBJRSwgb3IgTVMgSUUgY2F1c2VzIHRoZSBsaW5rIHRvIGJlIGRlbGV0ZWQgcmlnaHQgYWZ0ZXIgYWRkaW5nIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmFzZS5pbXBvcnRTZWxlY3Rpb24oc2VsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwZXJmb3JtIGxpbmtpbmcnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZUV2ZW50SGFuZGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJmb3JtTGlua2luZzogZnVuY3Rpb24gKGNvbnRlbnRlZGl0YWJsZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIFBlcmZvcm0gbGlua2luZyBvbiBibG9ja0VsZW1lbnQgYmFzaXMsIGJsb2NrRWxlbWVudHMgYXJlIEhUTUwgZWxlbWVudHMgd2l0aCB0ZXh0IGNvbnRlbnQgYW5kIHdpdGhvdXRcbiAgICAgICAgICAgIGNoaWxkIGVsZW1lbnQuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG4gICAgICAgICAgICAtIEhUTUwgY29udGVudFxuICAgICAgICAgICAgPGJsb2NrcXVvdGU+XG4gICAgICAgICAgICAgIDxwPmxpbmsuPC9wPlxuICAgICAgICAgICAgICA8cD5teTwvcD5cbiAgICAgICAgICAgIDwvYmxvY2txdW90ZT5cblxuICAgICAgICAgICAgLSBibG9ja0VsZW1lbnRzXG4gICAgICAgICAgICBbPHA+bGluay48L3A+LCA8cD5teTwvcD5dXG5cbiAgICAgICAgICAgIG90aGVyd2lzZSB0aGUgZGV0ZWN0aW9uIGNhbiB3cm9uZ2x5IGZpbmQgdGhlIGVuZCBvZiBvbmUgcGFyYWdyYXBoIGFuZCB0aGUgYmVnaW5uaW5nIG9mIGFub3RoZXIgcGFyYWdyYXBoXG4gICAgICAgICAgICB0byBjb25zdGl0dXRlIGEgbGluaywgc3VjaCBhcyBhIHBhcmFncmFwaCBlbmRpbmcgXCJsaW5rLlwiIGFuZCB0aGUgbmV4dCBwYXJhZ3JhcGggYmVnaW5uaW5nIHdpdGggXCJteVwiIGlzXG4gICAgICAgICAgICBpbnRlcnByZXRlZCBpbnRvIFwibGluay5teVwiIGFuZCB0aGUgY29kZSB0cmllcyB0byBjcmVhdGUgYSBsaW5rIGFjcm9zcyBibG9ja0VsZW1lbnRzIC0gd2hpY2ggZG9lc24ndCB3b3JrXG4gICAgICAgICAgICBhbmQgaXMgdGVycmlibGUuXG4gICAgICAgICAgICAoTWVkaXVtIGRlbGV0ZXMgdGhlIHNwYWNlcy9yZXR1cm5zIGJldHdlZW4gUCB0YWdzIHNvIHRoZSB0ZXh0Q29udGVudCBlbmRzIHVwIHdpdGhvdXQgcGFyYWdyYXBoIHNwYWNpbmcpXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGJsb2NrRWxlbWVudHMgPSBNZWRpdW1FZGl0b3IudXRpbC5zcGxpdEJ5QmxvY2tFbGVtZW50cyhjb250ZW50ZWRpdGFibGUpLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50TW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChibG9ja0VsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudHMgPSBbY29udGVudGVkaXRhYmxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50TW9kaWZpZWQgPSB0aGlzLnJlbW92ZU9ic29sZXRlQXV0b0xpbmtTcGFucyhibG9ja0VsZW1lbnRzW2ldKSB8fCBkb2N1bWVudE1vZGlmaWVkO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50TW9kaWZpZWQgPSB0aGlzLnBlcmZvcm1MaW5raW5nV2l0aGluRWxlbWVudChibG9ja0VsZW1lbnRzW2ldKSB8fCBkb2N1bWVudE1vZGlmaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXNlLmV2ZW50cy51cGRhdGVJbnB1dChjb250ZW50ZWRpdGFibGUsIHsgdGFyZ2V0OiBjb250ZW50ZWRpdGFibGUsIGN1cnJlbnRUYXJnZXQ6IGNvbnRlbnRlZGl0YWJsZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudE1vZGlmaWVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZU9ic29sZXRlQXV0b0xpbmtTcGFuczogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3BhbnMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW5bZGF0YS1hdXRvLWxpbms9XCJ0cnVlXCJdJyksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRNb2RpZmllZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gc3BhbnNbaV0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRDb250ZW50LmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCA9IE1lZGl1bUVkaXRvci51dGlsLmVuc3VyZVVybEhhc1Byb3RvY29sKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwYW5zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJykgIT09IHRleHRDb250ZW50ICYmIG5vZGVJc05vdEluc2lkZUFuY2hvclRhZyhzcGFuc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmltbWVkVGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJykgPT09IHRyaW1tZWRUZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcnNUcmltbWVkID0gdGV4dENvbnRlbnQubGVuZ3RoIC0gdHJpbW1lZFRleHRDb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlID0gTWVkaXVtRWRpdG9yLnV0aWwuc3BsaXRPZmZET01UcmVlKHNwYW5zW2ldLCB0aGlzLnNwbGl0VGV4dEJlZm9yZUVuZChzcGFuc1tpXSwgY2hhcmFjdGVyc1RyaW1tZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5zW2ldLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN1YnRyZWUsIHNwYW5zW2ldLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgZWRpdGluZyBoYXMgaGFwcGVuZWQgdG8gdGhlIHNwYW4sIHNvIGp1c3QgcmVtb3ZlIGl0IGVudGlyZWx5LiBUaGUgdXNlciBjYW4gcHV0IGl0IGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyb3VuZCBqdXN0IHRoZSBocmVmIGNvbnRlbnQgaWYgdGhleSBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBsaW5raW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC51bndyYXAoc3BhbnNbaV0sIHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50TW9kaWZpZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BsaXRUZXh0QmVmb3JlRW5kOiBmdW5jdGlvbiAoZWxlbWVudCwgY2hhcmFjdGVyQ291bnQpIHtcbiAgICAgICAgICAgIHZhciB0cmVlV2Fsa2VyID0gdGhpcy5kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgbGFzdENoaWxkTm90RXhoYXVzdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRyZWUgd2Fsa2VyIGF0IHRoZSBsYXN0IGRlc2NlbmRhbnQgb2YgdGhlIHNwYW5cbiAgICAgICAgICAgIHdoaWxlIChsYXN0Q2hpbGROb3RFeGhhdXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0Q2hpbGROb3RFeGhhdXN0ZWQgPSB0cmVlV2Fsa2VyLmxhc3RDaGlsZCgpICE9PSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUsXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGVWYWx1ZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGU7XG4gICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyQ291bnQgPiAwICYmIHByZXZpb3VzTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZVZhbHVlID0gY3VycmVudE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZVZhbHVlLmxlbmd0aCA+IGNoYXJhY3RlckNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChjdXJyZW50Tm9kZVZhbHVlLmxlbmd0aCAtIGNoYXJhY3RlckNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHRyZWVXYWxrZXIucHJldmlvdXNOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckNvdW50IC09IGN1cnJlbnROb2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c05vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUxpbmtpbmdXaXRoaW5FbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLmZpbmRMaW5rYWJsZVRleHQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgbGlua0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgbWF0Y2hJbmRleCA9IDA7IG1hdGNoSW5kZXggPCBtYXRjaGVzLmxlbmd0aDsgbWF0Y2hJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nVGV4dE5vZGVzID0gTWVkaXVtRWRpdG9yLnV0aWwuZmluZE9yQ3JlYXRlTWF0Y2hpbmdUZXh0Tm9kZXModGhpcy5kb2N1bWVudCwgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbbWF0Y2hJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZE5vdExpbmsobWF0Y2hpbmdUZXh0Tm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUF1dG9MaW5rKG1hdGNoaW5nVGV4dE5vZGVzLCBtYXRjaGVzW21hdGNoSW5kZXhdLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmtDcmVhdGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3VsZE5vdExpbms6IGZ1bmN0aW9uICh0ZXh0Tm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGROb3RMaW5rID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHROb2Rlcy5sZW5ndGggJiYgc2hvdWxkTm90TGluayA9PT0gZmFsc2U7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBsaW5rIGlmIHRoZSB0ZXh0IG5vZGUgaXMgZWl0aGVyIGluc2lkZSBhbiBhbmNob3Igb3IgaW5zaWRlIHNwYW5bZGF0YS1hdXRvLWxpbmtdXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90TGluayA9ICEhTWVkaXVtRWRpdG9yLnV0aWwudHJhdmVyc2VVcCh0ZXh0Tm9kZXNbaV0sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWF1dG8tbGluaycpID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZE5vdExpbms7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluZExpbmthYmxlVGV4dDogZnVuY3Rpb24gKGNvbnRlbnRlZGl0YWJsZSkge1xuICAgICAgICAgICAgdmFyIGxpbmtSZWdFeHAgPSBuZXcgUmVnRXhwKExJTktfUkVHRVhQX1RFWFQsICdnaScpLFxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50ID0gY29udGVudGVkaXRhYmxlLnRleHRDb250ZW50LFxuICAgICAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gW107XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5rUmVnRXhwLmV4ZWModGV4dENvbnRlbnQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaE9rID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hFbmQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVnZXhwIGRldGVjdGVkIHNvbWV0aGluZyBhcyBhIGxpbmsgdGhhdCBoYXMgdGV4dCBpbW1lZGlhdGVseSBwcmVjZWRpbmcvZm9sbG93aW5nIGl0LCBiYWlsIG91dC5cbiAgICAgICAgICAgICAgICBtYXRjaE9rID0gKG1hdGNoLmluZGV4ID09PSAwIHx8IFdISVRFU1BBQ0VfQ0hBUlMuaW5kZXhPZih0ZXh0Q29udGVudFttYXRjaC5pbmRleCAtIDFdKSAhPT0gLTEpICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEVuZCA9PT0gdGV4dENvbnRlbnQubGVuZ3RoIHx8IFdISVRFU1BBQ0VfQ0hBUlMuaW5kZXhPZih0ZXh0Q29udGVudFttYXRjaEVuZF0pICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlZ2V4cCBkZXRlY3RlZCBhIGJhcmUgZG9tYWluIHRoYXQgZG9lc24ndCB1c2Ugb25lIG9mIG91ciBleHBlY3RlZCBUTERzLCBiYWlsIG91dC5cbiAgICAgICAgICAgICAgICBtYXRjaE9rID0gbWF0Y2hPayAmJiAobWF0Y2hbMF0uaW5kZXhPZignLycpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICBLTk9XTl9UTERTX1JFR0VYUC50ZXN0KG1hdGNoWzBdLnNwbGl0KCcuJykucG9wKCkuc3BsaXQoJz8nKS5zaGlmdCgpKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hPaykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogbWF0Y2hbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoRW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUF1dG9MaW5rOiBmdW5jdGlvbiAodGV4dE5vZGVzLCBocmVmKSB7XG4gICAgICAgICAgICBocmVmID0gTWVkaXVtRWRpdG9yLnV0aWwuZW5zdXJlVXJsSGFzUHJvdG9jb2woaHJlZik7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gTWVkaXVtRWRpdG9yLnV0aWwuY3JlYXRlTGluayh0aGlzLmRvY3VtZW50LCB0ZXh0Tm9kZXMsIGhyZWYsIHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCd0YXJnZXRCbGFuaycpID8gJ19ibGFuaycgOiBudWxsKSxcbiAgICAgICAgICAgICAgICBzcGFuID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnZGF0YS1hdXRvLWxpbmsnLCAndHJ1ZScpO1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgYW5jaG9yLmluc2VydEJlZm9yZShzcGFuLCBhbmNob3IuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB3aGlsZSAoYW5jaG9yLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYW5jaG9yLmNoaWxkTm9kZXNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmF1dG9MaW5rID0gQXV0b0xpbms7XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBDTEFTU19EUkFHX09WRVIgPSAnbWVkaXVtLWVkaXRvci1kcmFnb3Zlcic7XG5cbiAgICBmdW5jdGlvbiBjbGVhckNsYXNzTmFtZXMoZWxlbWVudCkge1xuICAgICAgICB2YXIgZWRpdGFibGUgPSBNZWRpdW1FZGl0b3IudXRpbC5nZXRDb250YWluZXJFZGl0b3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgZXhpc3RpbmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlZGl0YWJsZS5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgQ0xBU1NfRFJBR19PVkVSKSk7XG5cbiAgICAgICAgZXhpc3RpbmcuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfRFJBR19PVkVSKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIEZpbGVEcmFnZ2luZyA9IE1lZGl1bUVkaXRvci5FeHRlbnNpb24uZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogJ2ZpbGVEcmFnZ2luZycsXG5cbiAgICAgICAgYWxsb3dlZFR5cGVzOiBbJ2ltYWdlJ10sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVEcmFnJywgdGhpcy5oYW5kbGVEcmFnLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlRHJvcCcsIHRoaXMuaGFuZGxlRHJvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVEcmFnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5JztcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldC5jbGFzc0xpc3QgPyBldmVudC50YXJnZXQgOiBldmVudC50YXJnZXQucGFyZW50RWxlbWVudDtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjbGFzcyBnZXRzIHJlbW92ZWQgZnJvbSBhbnl0aGluZyB0aGF0IGhhZCBpdCBiZWZvcmVcbiAgICAgICAgICAgIGNsZWFyQ2xhc3NOYW1lcyh0YXJnZXQpO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2RyYWdvdmVyJykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX0RSQUdfT1ZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRHJvcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGZpbGUgZnJvbSBvcGVuaW5nIGluIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBkcm9wcGluZyB0YXJnZXQsIGFuZCBzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95YWJ3ZS9tZWRpdW0tZWRpdG9yL2lzc3Vlcy85ODBcbiAgICAgICAgICAgIHRoaXMuYmFzZS5zZWxlY3RFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5iYXNlLmV4cG9ydFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnN0YXJ0ID0gc2VsZWN0aW9uLmVuZDtcbiAgICAgICAgICAgIHRoaXMuYmFzZS5pbXBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIElFOSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBGaWxlIEFQSSwgc28gcHJldmVudCBmaWxlIGZyb20gb3BlbmluZyBpbiB0aGUgd2luZG93XG4gICAgICAgICAgICAvLyBidXQgYWxzbyBkb24ndCB0cnkgdG8gYWN0dWFsbHkgZ2V0IHRoZSBmaWxlXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWxsb3dlZEZpbGUoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUubWF0Y2goJ2ltYWdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEltYWdlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcmVtb3ZlIG91ciBjbGFzcyBmcm9tIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIGNsZWFyQ2xhc3NOYW1lcyhldmVudC50YXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWxsb3dlZEZpbGU6IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGxvd2VkVHlwZXMuc29tZShmdW5jdGlvbiAoZmlsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFmaWxlLnR5cGUubWF0Y2goZmlsZVR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZXJ0SW1hZ2VGaWxlOiBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBGaWxlUmVhZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXG4gICAgICAgICAgICAvLyBhdHRhY2ggdGhlIG9ubG9hZCBldmVudCBoYW5kbGVyLCBtYWtlcyBpdCBlYXNpZXIgdG8gbGlzdGVuIGluIHdpdGggamFzbWluZVxuICAgICAgICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkSW1hZ2VFbGVtZW50ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICBhZGRJbWFnZUVsZW1lbnQuc3JjID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmluc2VydEhUTUxDb21tYW5kKHRoaXMuZG9jdW1lbnQsIGFkZEltYWdlRWxlbWVudC5vdXRlckhUTUwpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZmlsZURyYWdnaW5nID0gRmlsZURyYWdnaW5nO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgS2V5Ym9hcmRDb21tYW5kcyA9IE1lZGl1bUVkaXRvci5FeHRlbnNpb24uZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogJ2tleWJvYXJkLWNvbW1hbmRzJyxcblxuICAgICAgICAvKiBLZXlib2FyZENvbW1hbmRzIE9wdGlvbnMgKi9cblxuICAgICAgICAvKiBjb21tYW5kczogW0FycmF5XVxuICAgICAgICAgKiBBcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgZWFjaCBjb21tYW5kIGFuZCB0aGUgY29tYmluYXRpb24gb2Yga2V5cyB0aGF0IHdpbGwgdHJpZ2dlciBpdFxuICAgICAgICAgKiBSZXF1aXJlZCBmb3IgZWFjaCBvYmplY3Q6XG4gICAgICAgICAqICAgY29tbWFuZCBbU3RyaW5nXSAoYXJndW1lbnQgcGFzc2VkIHRvIGVkaXRvci5leGVjQWN0aW9uKCkpXG4gICAgICAgICAqICAga2V5IFtTdHJpbmddIChrZXlib2FyZCBjaGFyYWN0ZXIgdGhhdCB0cmlnZ2VycyB0aGlzIGNvbW1hbmQpXG4gICAgICAgICAqICAgbWV0YSBbYm9vbGVhbl0gKHdoZXRoZXIgdGhlIGN0cmwvbWV0YSBrZXkgaGFzIHRvIGJlIGFjdGl2ZSBvciBpbmFjdGl2ZSlcbiAgICAgICAgICogICBzaGlmdCBbYm9vbGVhbl0gKHdoZXRoZXIgdGhlIHNoaWZ0IGtleSBoYXMgdG8gYmUgYWN0aXZlIG9yIGluYWN0aXZlKVxuICAgICAgICAgKiAgIGFsdCBbYm9vbGVhbl0gKHdoZXRoZXIgdGhlIGFsdCBrZXkgaGFzIHRvIGJlIGFjdGl2ZSBvciBpbmFjdGl2ZSlcbiAgICAgICAgICovXG4gICAgICAgIGNvbW1hbmRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGtleTogJ0InLFxuICAgICAgICAgICAgICAgIG1ldGE6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hpZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsdDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAga2V5OiAnSScsXG4gICAgICAgICAgICAgICAgbWV0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaGlmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWx0OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndW5kZXJsaW5lJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdVJyxcbiAgICAgICAgICAgICAgICBtZXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNoaWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbHQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5rZXlzID0ge307XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGNvbW1hbmQua2V5LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmtleXNba2V5Q29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlzW2tleUNvZGVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMua2V5c1trZXlDb2RlXS5wdXNoKGNvbW1hbmQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlS2V5ZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5Q29kZSA9IE1lZGl1bUVkaXRvci51dGlsLmdldEtleUNvZGUoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtleXNba2V5Q29kZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc01ldGEgPSBNZWRpdW1FZGl0b3IudXRpbC5pc01ldGFDdHJsS2V5KGV2ZW50KSxcbiAgICAgICAgICAgICAgICBpc1NoaWZ0ID0gISFldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICBpc0FsdCA9ICEhZXZlbnQuYWx0S2V5O1xuXG4gICAgICAgICAgICB0aGlzLmtleXNba2V5Q29kZV0uZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLm1ldGEgPT09IGlzTWV0YSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNoaWZ0ID09PSBpc1NoaWZ0ICYmXG4gICAgICAgICAgICAgICAgICAgIChkYXRhLmFsdCA9PT0gaXNBbHQgfHxcbiAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gZGF0YS5hbHQpKSB7IC8vIFRPRE8gZGVwcmVjYXRlZDogcmVtb3ZlIGNoZWNrIGZvciB1bmRlZmluZWQgPT09IGRhdGEuYWx0IHdoZW4ganVtcGluZyB0byA2LjAuMFxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb21tYW5kIGNhbiBiZSBmYWxzZSBzbyB0aGUgc2hvcnRjdXQgaXMganVzdCBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsc2UgIT09IGRhdGEuY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjQWN0aW9uKGRhdGEuY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMua2V5Ym9hcmRDb21tYW5kcyA9IEtleWJvYXJkQ29tbWFuZHM7XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBGb250TmFtZUZvcm0gPSBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb3JtLmV4dGVuZCh7XG5cbiAgICAgICAgbmFtZTogJ2ZvbnRuYW1lJyxcbiAgICAgICAgYWN0aW9uOiAnZm9udE5hbWUnLFxuICAgICAgICBhcmlhOiAnY2hhbmdlIGZvbnQgbmFtZScsXG4gICAgICAgIGNvbnRlbnREZWZhdWx0OiAnJiN4QjE7JywgLy8gwrFcbiAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1mb250XCI+PC9pPicsXG5cbiAgICAgICAgZm9udHM6IFsnJywgJ0FyaWFsJywgJ1ZlcmRhbmEnLCAnVGltZXMgTmV3IFJvbWFuJ10sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9ybS5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHRoZSBidXR0b24gdGhlIHRvb2xiYXIgaXMgY2xpY2tlZFxuICAgICAgICAvLyBPdmVycmlkZXMgQnV0dG9uRXh0ZW5zaW9uLmhhbmRsZUNsaWNrXG4gICAgICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgRm9udE5hbWUgb2YgY3VycmVudCBzZWxlY3Rpb24gKGNvbnZlcnQgdG8gc3RyaW5nIHNpbmNlIElFIHJldHVybnMgdGhpcyBhcyBudW1iZXIpXG4gICAgICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gdGhpcy5kb2N1bWVudC5xdWVyeUNvbW1hbmRWYWx1ZSgnZm9udE5hbWUnKSArICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oZm9udE5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGVkIGJ5IG1lZGl1bS1lZGl0b3IgdG8gYXBwZW5kIGZvcm0gdG8gdGhlIHRvb2xiYXJcbiAgICAgICAgZ2V0Rm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0gPSB0aGlzLmNyZWF0ZUZvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVXNlZCBieSBtZWRpdW0tZWRpdG9yIHdoZW4gdGhlIGRlZmF1bHQgdG9vbGJhciBpcyB0byBiZSBkaXNwbGF5ZWRcbiAgICAgICAgaXNEaXNwbGF5ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvcm0oKS5zdHlsZS5kaXNwbGF5ID09PSAnYmxvY2snO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdldEZvcm0oKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3QoKS52YWx1ZSA9ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dGb3JtOiBmdW5jdGlvbiAoZm9udE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3QgPSB0aGlzLmdldFNlbGVjdCgpO1xuXG4gICAgICAgICAgICB0aGlzLmJhc2Uuc2F2ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5oaWRlVG9vbGJhckRlZmF1bHRBY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLmdldEZvcm0oKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuc2V0VG9vbGJhclBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIHNlbGVjdC52YWx1ZSA9IGZvbnROYW1lIHx8ICcnO1xuICAgICAgICAgICAgc2VsZWN0LmZvY3VzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGVkIGJ5IGNvcmUgd2hlbiB0ZWFyaW5nIGRvd24gbWVkaXVtLWVkaXRvciAoZGVzdHJveSlcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZvcm07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gY29yZSBtZXRob2RzXG5cbiAgICAgICAgZG9Gb3JtU2F2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlLnJlc3RvcmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZS5jaGVja1NlbGVjdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRvRm9ybUNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlLnJlc3RvcmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJGb250TmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5iYXNlLmNoZWNrU2VsZWN0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZm9ybSBjcmVhdGlvbiBhbmQgZXZlbnQgaGFuZGxpbmdcbiAgICAgICAgY3JlYXRlRm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZm9ybSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBzZWxlY3QgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgY2xvc2UgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpLFxuICAgICAgICAgICAgICAgIHNhdmUgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpLFxuICAgICAgICAgICAgICAgIG9wdGlvbjtcblxuICAgICAgICAgICAgLy8gRm9udCBOYW1lIEZvcm0gKGRpdilcbiAgICAgICAgICAgIGZvcm0uY2xhc3NOYW1lID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhci1mb3JtJztcbiAgICAgICAgICAgIGZvcm0uaWQgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLWZvcm0tZm9udG5hbWUtJyArIHRoaXMuZ2V0RWRpdG9ySWQoKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGNsaWNrcyBvbiB0aGUgZm9ybSBpdHNlbGZcbiAgICAgICAgICAgIHRoaXMub24oZm9ybSwgJ2NsaWNrJywgdGhpcy5oYW5kbGVGb3JtQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBmb250IG5hbWVzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaTx0aGlzLmZvbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSB0aGlzLmZvbnRzW2ldO1xuICAgICAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHRoaXMuZm9udHNbaV07XG4gICAgICAgICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdC5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLXNlbGVjdCc7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHNlbGVjdCk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0eXBpbmcgaW4gdGhlIHRleHRib3hcbiAgICAgICAgICAgIHRoaXMub24oc2VsZWN0LCAnY2hhbmdlJywgdGhpcy5oYW5kbGVGb250Q2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBBZGQgc2F2ZSBidXRvblxuICAgICAgICAgICAgc2F2ZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xuICAgICAgICAgICAgc2F2ZS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29iYXItc2F2ZSc7XG4gICAgICAgICAgICBzYXZlLmlubmVySFRNTCA9IHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdidXR0b25MYWJlbHMnKSA9PT0gJ2ZvbnRhd2Vzb21lJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrXCI+PC9pPicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiMxMDAwMzsnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChzYXZlKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHNhdmUgYnV0dG9uIGNsaWNrcyAoY2FwdHVyZSlcbiAgICAgICAgICAgIHRoaXMub24oc2F2ZSwgJ2NsaWNrJywgdGhpcy5oYW5kbGVTYXZlQ2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjbG9zZSBidXR0b25cbiAgICAgICAgICAgIGNsb3NlLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XG4gICAgICAgICAgICBjbG9zZS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29iYXItY2xvc2UnO1xuICAgICAgICAgICAgY2xvc2UuaW5uZXJIVE1MID0gdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2J1dHRvbkxhYmVscycpID09PSAnZm9udGF3ZXNvbWUnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9pPicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyZ0aW1lczsnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChjbG9zZSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBjbG9zZSBidXR0b24gY2xpY2tzXG4gICAgICAgICAgICB0aGlzLm9uKGNsb3NlLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsb3NlQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybSgpLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdC5tZWRpdW0tZWRpdG9yLXRvb2xiYXItc2VsZWN0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJGb250TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnRzKHRoaXMuZG9jdW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmb250JyAmJiBlbC5oYXNBdHRyaWJ1dGUoJ2ZhY2UnKSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2ZhY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb250Q2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm9udCA9IHRoaXMuZ2V0U2VsZWN0KCkudmFsdWU7XG4gICAgICAgICAgICBpZiAoZm9udCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRm9udE5hbWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leGVjQWN0aW9uKCdmb250TmFtZScsIHsgbmFtZTogZm9udCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb3JtQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG5vdCB0byBoaWRlIGZvcm0gd2hlbiBjbGlja2luZyBpbnNpZGUgdGhlIGZvcm1cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVNhdmVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGlja2luZyBTYXZlIC0+IGNyZWF0ZSB0aGUgZm9udCBzaXplXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5kb0Zvcm1TYXZlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ2xvc2VDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGljayBDbG9zZSAtPiBjbG9zZSB0aGUgZm9ybVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZG9Gb3JtQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvbnROYW1lID0gRm9udE5hbWVGb3JtO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRm9udFNpemVGb3JtID0gTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9ybS5leHRlbmQoe1xuXG4gICAgICAgIG5hbWU6ICdmb250c2l6ZScsXG4gICAgICAgIGFjdGlvbjogJ2ZvbnRTaXplJyxcbiAgICAgICAgYXJpYTogJ2luY3JlYXNlL2RlY3JlYXNlIGZvbnQgc2l6ZScsXG4gICAgICAgIGNvbnRlbnREZWZhdWx0OiAnJiN4QjE7JywgLy8gwrFcbiAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS10ZXh0LWhlaWdodFwiPjwvaT4nLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0ucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiB0aGUgYnV0dG9uIHRoZSB0b29sYmFyIGlzIGNsaWNrZWRcbiAgICAgICAgLy8gT3ZlcnJpZGVzIEJ1dHRvbkV4dGVuc2lvbi5oYW5kbGVDbGlja1xuICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGZvbnRzaXplIG9mIGN1cnJlbnQgc2VsZWN0aW9uIChjb252ZXJ0IHRvIHN0cmluZyBzaW5jZSBJRSByZXR1cm5zIHRoaXMgYXMgbnVtYmVyKVxuICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZG9jdW1lbnQucXVlcnlDb21tYW5kVmFsdWUoJ2ZvbnRTaXplJykgKyAnJztcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKGZvbnRTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENhbGxlZCBieSBtZWRpdW0tZWRpdG9yIHRvIGFwcGVuZCBmb3JtIHRvIHRoZSB0b29sYmFyXG4gICAgICAgIGdldEZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5jcmVhdGVGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFVzZWQgYnkgbWVkaXVtLWVkaXRvciB3aGVuIHRoZSBkZWZhdWx0IHRvb2xiYXIgaXMgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgIGlzRGlzcGxheWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJztcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlRm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRGb3JtKCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuZ2V0SW5wdXQoKS52YWx1ZSA9ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dGb3JtOiBmdW5jdGlvbiAoZm9udFNpemUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcblxuICAgICAgICAgICAgdGhpcy5iYXNlLnNhdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5nZXRGb3JtKCkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLnNldFRvb2xiYXJQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGZvbnRTaXplIHx8ICcnO1xuICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgYnkgY29yZSB3aGVuIHRlYXJpbmcgZG93biBtZWRpdW0tZWRpdG9yIChkZXN0cm95KVxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZm9ybTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjb3JlIG1ldGhvZHNcblxuICAgICAgICBkb0Zvcm1TYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5iYXNlLmNoZWNrU2VsZWN0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9Gb3JtQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckZvbnRTaXplKCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY2hlY2tTZWxlY3Rpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3JtIGNyZWF0aW9uIGFuZCBldmVudCBoYW5kbGluZ1xuICAgICAgICBjcmVhdGVGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmb3JtID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGlucHV0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JyksXG4gICAgICAgICAgICAgICAgY2xvc2UgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpLFxuICAgICAgICAgICAgICAgIHNhdmUgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgICAgICAvLyBGb250IFNpemUgRm9ybSAoZGl2KVxuICAgICAgICAgICAgZm9ybS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLWZvcm0nO1xuICAgICAgICAgICAgZm9ybS5pZCA9ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItZm9ybS1mb250c2l6ZS0nICsgdGhpcy5nZXRFZGl0b3JJZCgpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIHRoZSBmb3JtIGl0c2VsZlxuICAgICAgICAgICAgdGhpcy5vbihmb3JtLCAnY2xpY2snLCB0aGlzLmhhbmRsZUZvcm1DbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gQWRkIGZvbnQgc2l6ZSBzbGlkZXJcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdtaW4nLCAnMScpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdtYXgnLCAnNycpO1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NOYW1lID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhci1pbnB1dCc7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHR5cGluZyBpbiB0aGUgdGV4dGJveFxuICAgICAgICAgICAgdGhpcy5vbihpbnB1dCwgJ2NoYW5nZScsIHRoaXMuaGFuZGxlU2xpZGVyQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBBZGQgc2F2ZSBidXRvblxuICAgICAgICAgICAgc2F2ZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xuICAgICAgICAgICAgc2F2ZS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29iYXItc2F2ZSc7XG4gICAgICAgICAgICBzYXZlLmlubmVySFRNTCA9IHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdidXR0b25MYWJlbHMnKSA9PT0gJ2ZvbnRhd2Vzb21lJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrXCI+PC9pPicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiMxMDAwMzsnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChzYXZlKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHNhdmUgYnV0dG9uIGNsaWNrcyAoY2FwdHVyZSlcbiAgICAgICAgICAgIHRoaXMub24oc2F2ZSwgJ2NsaWNrJywgdGhpcy5oYW5kbGVTYXZlQ2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjbG9zZSBidXR0b25cbiAgICAgICAgICAgIGNsb3NlLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XG4gICAgICAgICAgICBjbG9zZS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29iYXItY2xvc2UnO1xuICAgICAgICAgICAgY2xvc2UuaW5uZXJIVE1MID0gdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2J1dHRvbkxhYmVscycpID09PSAnZm9udGF3ZXNvbWUnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9pPicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyZ0aW1lczsnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChjbG9zZSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBjbG9zZSBidXR0b24gY2xpY2tzXG4gICAgICAgICAgICB0aGlzLm9uKGNsb3NlLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsb3NlQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldElucHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkucXVlcnlTZWxlY3RvcignaW5wdXQubWVkaXVtLWVkaXRvci10b29sYmFyLWlucHV0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJGb250U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnRzKHRoaXMuZG9jdW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmb250JyAmJiBlbC5oYXNBdHRyaWJ1dGUoJ3NpemUnKSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NpemUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVTbGlkZXJDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRJbnB1dCgpLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHNpemUgPT09ICc0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGb250U2l6ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWNBY3Rpb24oJ2ZvbnRTaXplJywgeyBzaXplOiBzaXplIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUZvcm1DbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgbm90IHRvIGhpZGUgZm9ybSB3aGVuIGNsaWNraW5nIGluc2lkZSB0aGUgZm9ybVxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlU2F2ZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIENsaWNraW5nIFNhdmUgLT4gY3JlYXRlIHRoZSBmb250IHNpemVcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmRvRm9ybVNhdmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVDbG9zZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIENsaWNrIENsb3NlIC0+IGNsb3NlIHRoZSBmb3JtXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5kb0Zvcm1DYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9udFNpemUgPSBGb250U2l6ZUZvcm07XG59KCkpO1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLypqc2xpbnQgcmVnZXhwOiB0cnVlKi9cbiAgICAvKlxuICAgICAgICBqc2xpbnQgZG9lcyBub3QgYWxsb3cgY2hhcmFjdGVyIG5lZ2F0aW9uLCBiZWNhdXNlIHRoZSBuZWdhdGlvblxuICAgICAgICB3aWxsIG5vdCBtYXRjaCBhbnkgdW5pY29kZSBjaGFyYWN0ZXJzLiBJbiB0aGUgcmVnZXhlcyBpbiB0aGlzXG4gICAgICAgIGJsb2NrLCBuZWdhdGlvbiBpcyB1c2VkIHNwZWNpZmljYWxseSB0byBtYXRjaCB0aGUgZW5kIG9mIGFuIGh0bWxcbiAgICAgICAgdGFnLCBhbmQgaW4gZmFjdCB1bmljb2RlIGNoYXJhY3RlcnMgKnNob3VsZCogYmUgYWxsb3dlZC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcGxhY2VtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdHdvIGJvZ3VzIHRhZ3MgdGhhdCBiZWdpbiBwYXN0ZXMgZnJvbSBnb29nbGUgZG9jc1xuICAgICAgICAgICAgW25ldyBSZWdFeHAoLzxbXj5dKmRvY3MtaW50ZXJuYWwtZ3VpZFtePl0qPi9naSksICcnXSxcbiAgICAgICAgICAgIFtuZXcgUmVnRXhwKC88XFwvYj4oPGJyW14+XSo+KT8kL2dpKSwgJyddLFxuXG4gICAgICAgICAgICAgLy8gdW4taHRtbCBzcGFjZXMgYW5kIG5ld2xpbmVzIGluc2VydGVkIGJ5IE9TIFhcbiAgICAgICAgICAgIFtuZXcgUmVnRXhwKC88c3BhbiBjbGFzcz1cIkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiPlxccys8XFwvc3Bhbj4vZyksICcgJ10sXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPGJyIGNsYXNzPVwiQXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiPi9nKSwgJzxicj4nXSxcblxuICAgICAgICAgICAgLy8gcmVwbGFjZSBnb29nbGUgZG9jcyBpdGFsaWNzK2JvbGQgd2l0aCBhIHNwYW4gdG8gYmUgcmVwbGFjZWQgb25jZSB0aGUgaHRtbCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgW25ldyBSZWdFeHAoLzxzcGFuW14+XSooZm9udC1zdHlsZTppdGFsaWM7Zm9udC13ZWlnaHQ6Ym9sZHxmb250LXdlaWdodDpib2xkO2ZvbnQtc3R5bGU6aXRhbGljKVtePl0qPi9naSksICc8c3BhbiBjbGFzcz1cInJlcGxhY2Utd2l0aCBpdGFsaWMgYm9sZFwiPiddLFxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIGdvb2dsZSBkb2NzIGl0YWxpY3Mgd2l0aCBhIHNwYW4gdG8gYmUgcmVwbGFjZWQgb25jZSB0aGUgaHRtbCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgW25ldyBSZWdFeHAoLzxzcGFuW14+XSpmb250LXN0eWxlOml0YWxpY1tePl0qPi9naSksICc8c3BhbiBjbGFzcz1cInJlcGxhY2Utd2l0aCBpdGFsaWNcIj4nXSxcblxuICAgICAgICAgICAgLy9bcmVwbGFjZSBnb29nbGUgZG9jcyBib2xkcyB3aXRoIGEgc3BhbiB0byBiZSByZXBsYWNlZCBvbmNlIHRoZSBodG1sIGlzIGluc2VydGVkXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPHNwYW5bXj5dKmZvbnQtd2VpZ2h0OmJvbGRbXj5dKj4vZ2kpLCAnPHNwYW4gY2xhc3M9XCJyZXBsYWNlLXdpdGggYm9sZFwiPiddLFxuXG4gICAgICAgICAgICAgLy8gcmVwbGFjZSBtYW51YWxseSBlbnRlcmVkIGIvaS9hIHRhZ3Mgd2l0aCByZWFsIG9uZXNcbiAgICAgICAgICAgIFtuZXcgUmVnRXhwKC8mbHQ7KFxcLz8pKGl8YnxhKSZndDsvZ2kpLCAnPCQxJDI+J10sXG5cbiAgICAgICAgICAgICAvLyByZXBsYWNlIG1hbnVhbGx5IGEgdGFncyB3aXRoIHJlYWwgb25lcywgY29udmVydGluZyBzbWFydC1xdW90ZXMgZnJvbSBnb29nbGUgZG9jc1xuICAgICAgICAgICAgW25ldyBSZWdFeHAoLyZsdDthKD86KD8haHJlZikuKStocmVmPSg/OiZxdW90O3wmcmRxdW87fCZsZHF1bzt8XCJ84oCcfOKAnSkoKCg/ISZxdW90O3wmcmRxdW87fCZsZHF1bzt8XCJ84oCcfOKAnSkuKSopKD86JnF1b3Q7fCZyZHF1bzt8JmxkcXVvO3xcInzigJx84oCdKSg/Oig/ISZndDspLikqJmd0Oy9naSksICc8YSBocmVmPVwiJDFcIj4nXSxcblxuICAgICAgICAgICAgLy8gTmV3bGluZXMgYmV0d2VlbiBwYXJhZ3JhcGhzIGluIGh0bWwgaGF2ZSBubyBzeW50YWN0aWMgdmFsdWUsXG4gICAgICAgICAgICAvLyBidXQgdGhlbiBoYXZlIGEgdGVuZGVuY3kgdG8gYWNjaWRlbnRhbGx5IGJlY29tZSBhZGRpdGlvbmFsIHBhcmFncmFwaHMgZG93biB0aGUgbGluZVxuICAgICAgICAgICAgW25ldyBSZWdFeHAoLzxcXC9wPlxcbisvZ2kpLCAnPC9wPiddLFxuICAgICAgICAgICAgW25ldyBSZWdFeHAoL1xcbis8cC9naSksICc8cCddLFxuXG4gICAgICAgICAgICAvLyBNaWNyb3NvZnQgV29yZCBtYWtlcyB0aGVzZSBvZGQgdGFncywgbGlrZSA8bzpwPjwvbzpwPlxuICAgICAgICAgICAgW25ldyBSZWdFeHAoLzxcXC8/bzpbYS16XSo+L2dpKSwgJyddLFxuXG4gICAgICAgICAgICAvLyBjbGVhbnVwIGNvbW1lbnRzIGFkZGVkIGJ5IENocm9tZSB3aGVuIHBhc3RpbmcgaHRtbFxuICAgICAgICAgICAgWyc8IS0tRW5kRnJhZ21lbnQtLT4nLCAnJ10sXG4gICAgICAgICAgICBbJzwhLS1TdGFydEZyYWdtZW50LS0+JywgJyddXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qanNsaW50IHJlZ2V4cDogZmFsc2UqL1xuXG4gICAgdmFyIFBhc3RlSGFuZGxlciA9IE1lZGl1bUVkaXRvci5FeHRlbnNpb24uZXh0ZW5kKHtcbiAgICAgICAgLyogUGFzdGUgT3B0aW9ucyAqL1xuXG4gICAgICAgIC8qIGZvcmNlUGxhaW5UZXh0OiBbYm9vbGVhbl1cbiAgICAgICAgICogRm9yY2VzIHBhc3RpbmcgYXMgcGxhaW4gdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGZvcmNlUGxhaW5UZXh0OiB0cnVlLFxuXG4gICAgICAgIC8qIGNsZWFuUGFzdGVkSFRNTDogW2Jvb2xlYW5dXG4gICAgICAgICAqIGNsZWFucyBwYXN0ZWQgY29udGVudCBmcm9tIGRpZmZlcmVudCBzb3VyY2VzLCBsaWtlIGdvb2dsZSBkb2NzIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFuUGFzdGVkSFRNTDogZmFsc2UsXG5cbiAgICAgICAgLyogcHJlQ2xlYW5SZXBsYWNlbWVudHM6IFtBcnJheV1cbiAgICAgICAgICogY3VzdG9tIHBhaXJzICgyIGVsZW1lbnQgYXJyYXlzKSBvZiBSZWdFeHAgYW5kIHJlcGxhY2VtZW50IHRleHQgdG8gdXNlIGR1cmluZyBwYXN0IHdoZW5cbiAgICAgICAgICogX19mb3JjZVBsYWluVGV4dF9fIG9yIF9fY2xlYW5QYXN0ZWRIVE1MX18gYXJlIGB0cnVlYCBPUiB3aGVuIGNhbGxpbmcgYGNsZWFuUGFzdGUodGV4dClgIGhlbHBlciBtZXRob2QuXG4gICAgICAgICAqIFRoZXNlIHJlcGxhY2VtZW50cyBhcmUgZXhlY3V0ZWQgYmVmb3JlIGFueSBtZWRpdW0gZWRpdG9yIGRlZmluZWQgcmVwbGFjZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcHJlQ2xlYW5SZXBsYWNlbWVudHM6IFtdLFxuXG4gICAgICAgIC8qIGNsZWFuUmVwbGFjZW1lbnRzOiBbQXJyYXldXG4gICAgICAgICAqIGN1c3RvbSBwYWlycyAoMiBlbGVtZW50IGFycmF5cykgb2YgUmVnRXhwIGFuZCByZXBsYWNlbWVudCB0ZXh0IHRvIHVzZSBkdXJpbmcgcGFzdGUgd2hlblxuICAgICAgICAgKiBfX2ZvcmNlUGxhaW5UZXh0X18gb3IgX19jbGVhblBhc3RlZEhUTUxfXyBhcmUgYHRydWVgIE9SIHdoZW4gY2FsbGluZyBgY2xlYW5QYXN0ZSh0ZXh0KWAgaGVscGVyIG1ldGhvZC5cbiAgICAgICAgICogVGhlc2UgcmVwbGFjZW1lbnRzIGFyZSBleGVjdXRlZCBhZnRlciBhbnkgbWVkaXVtIGVkaXRvciBkZWZpbmVkIHJlcGxhY2VtZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFuUmVwbGFjZW1lbnRzOiBbXSxcblxuICAgICAgICAvKiBjbGVhbkF0dHJzOjogW0FycmF5XVxuICAgICAgICAgKiBsaXN0IG9mIGVsZW1lbnQgYXR0cmlidXRlcyB0byByZW1vdmUgZHVyaW5nIHBhc3RlIHdoZW4gX19jbGVhblBhc3RlZEhUTUxfXyBpcyBgdHJ1ZWAgb3Igd2hlblxuICAgICAgICAgKiBjYWxsaW5nIGBjbGVhblBhc3RlKHRleHQpYCBvciBgcGFzdGVIVE1MKGh0bWwsIG9wdGlvbnMpYCBoZWxwZXIgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFuQXR0cnM6IFsnY2xhc3MnLCAnc3R5bGUnLCAnZGlyJ10sXG5cbiAgICAgICAgLyogY2xlYW5UYWdzOiBbQXJyYXldXG4gICAgICAgICAqIGxpc3Qgb2YgZWxlbWVudCB0YWcgbmFtZXMgdG8gcmVtb3ZlIGR1cmluZyBwYXN0ZSB3aGVuIF9fY2xlYW5QYXN0ZWRIVE1MX18gaXMgYHRydWVgIG9yIHdoZW5cbiAgICAgICAgICogY2FsbGluZyBgY2xlYW5QYXN0ZSh0ZXh0KWAgb3IgYHBhc3RlSFRNTChodG1sLCBvcHRpb25zKWAgaGVscGVyIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhblRhZ3M6IFsnbWV0YSddLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5FeHRlbnNpb24ucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZm9yY2VQbGFpblRleHQgfHwgdGhpcy5jbGVhblBhc3RlZEhUTUwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVQYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlUGFzdGU6IGZ1bmN0aW9uIChldmVudCwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHBhcmFncmFwaHMsXG4gICAgICAgICAgICAgICAgaHRtbCA9ICcnLFxuICAgICAgICAgICAgICAgIHAsXG4gICAgICAgICAgICAgICAgZGF0YUZvcm1hdEhUTUwgPSAndGV4dC9odG1sJyxcbiAgICAgICAgICAgICAgICBkYXRhRm9ybWF0UGxhaW4gPSAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICAgICAgcGFzdGVkSFRNTCxcbiAgICAgICAgICAgICAgICBwYXN0ZWRQbGFpbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMud2luZG93LmNsaXBib2FyZERhdGEgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YSA9IHRoaXMud2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2luZG93LmNsaXBib2FyZERhdGEgZXhpc3RzLCBidXQgZXZlbnQuY2xpcGJvYXJkRGF0YSBkb2Vzbid0IGV4aXN0LFxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHByb2JhYmx5IGluIElFLiBJRSBvbmx5IGhhcyB0d28gcG9zc2liaWxpdGllcyBmb3IgY2xpcGJvYXJkXG4gICAgICAgICAgICAgICAgLy8gZGF0YSBmb3JtYXQ6ICdUZXh0JyBhbmQgJ1VSTCcuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBPZiB0aGUgdHdvLCB3ZSB3YW50ICdUZXh0JzpcbiAgICAgICAgICAgICAgICBkYXRhRm9ybWF0SFRNTCA9ICdUZXh0JztcbiAgICAgICAgICAgICAgICBkYXRhRm9ybWF0UGxhaW4gPSAnVGV4dCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldmVudC5jbGlwYm9hcmREYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBwYXN0ZWRIVE1MID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKGRhdGFGb3JtYXRIVE1MKTtcbiAgICAgICAgICAgICAgICBwYXN0ZWRQbGFpbiA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YShkYXRhRm9ybWF0UGxhaW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW5QYXN0ZWRIVE1MICYmIHBhc3RlZEhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYW5QYXN0ZShwYXN0ZWRIVE1MKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLmdldEVkaXRvck9wdGlvbignZGlzYWJsZVJldHVybicpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGUtcmV0dXJuJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaHMgPSBwYXN0ZWRQbGFpbi5zcGxpdCgvW1xcclxcbl0rL2cpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gXFxyXFxuIGluIGRhdGEsIGRvbid0IHdyYXAgaW4gPHA+XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhZ3JhcGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBwYXJhZ3JhcGhzLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFncmFwaHNbcF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxwPicgKyBNZWRpdW1FZGl0b3IudXRpbC5odG1sRW50aXRpZXMocGFyYWdyYXBoc1twXSkgKyAnPC9wPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IE1lZGl1bUVkaXRvci51dGlsLmh0bWxFbnRpdGllcyhwYXJhZ3JhcGhzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBNZWRpdW1FZGl0b3IudXRpbC5odG1sRW50aXRpZXMocGFzdGVkUGxhaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5pbnNlcnRIVE1MQ29tbWFuZCh0aGlzLmRvY3VtZW50LCBodG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhblBhc3RlOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIGksIGVsTGlzdCwgdG1wLCB3b3JrRWwsXG4gICAgICAgICAgICAgICAgbXVsdGlsaW5lID0gLzxwfDxicnw8ZGl2Ly50ZXN0KHRleHQpLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50cyA9IFtdLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVDbGVhblJlcGxhY2VtZW50cyB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVwbGFjZW1lbnRzKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5SZXBsYWNlbWVudHMgfHwgW10pO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwbGFjZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZXBsYWNlbWVudHNbaV1bMF0sIHJlcGxhY2VtZW50c1tpXVsxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFzdGVIVE1MKHRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSB0ZW1wb3JhcnkgZGl2IHRvIGNsZWFudXAgYmxvY2sgZWxlbWVudHNcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIC8vIGRvdWJsZSBicidzIGFyZW4ndCBjb252ZXJ0ZWQgdG8gcCB0YWdzLCBidXQgd2Ugd2FudCBwYXJhZ3JhcGhzLlxuICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9ICc8cD4nICsgdGV4dC5zcGxpdCgnPGJyPjxicj4nKS5qb2luKCc8L3A+PHA+JykgKyAnPC9wPic7XG5cbiAgICAgICAgICAgIC8vIGJsb2NrIGVsZW1lbnQgY2xlYW51cFxuICAgICAgICAgICAgZWxMaXN0ID0gdG1wLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EscCxkaXYsYnInKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbExpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB3b3JrRWwgPSBlbExpc3RbaV07XG5cbiAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgV29yZCByZXBsYWNlcyBzb21lIHNwYWNlcyB3aXRoIG5ld2xpbmVzLlxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIG5ld2xpbmVzIGJldHdlZW4gYmxvY2sgZWxlbWVudHMgYXJlIG1lYW5pbmdsZXNzLCBuZXdsaW5lcyB3aXRoaW5cbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyBhcmUgc29tZXRpbWVzIGFjdHVhbGx5IHNwYWNlcy5cbiAgICAgICAgICAgICAgICB3b3JrRWwuaW5uZXJIVE1MID0gd29ya0VsLmlubmVySFRNTC5yZXBsYWNlKC9cXG4vZ2ksICcgJyk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtFbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDb21tb25CbG9ja3Mod29ya0VsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckxpbmVCcmVhayh3b3JrRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhc3RlSFRNTCh0bXAuaW5uZXJIVE1MKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXN0ZUhUTUw6IGZ1bmN0aW9uIChodG1sLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gTWVkaXVtRWRpdG9yLnV0aWwuZGVmYXVsdHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjbGVhbkF0dHJzOiB0aGlzLmNsZWFuQXR0cnMsXG4gICAgICAgICAgICAgICAgY2xlYW5UYWdzOiB0aGlzLmNsZWFuVGFnc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBlbExpc3QsIHdvcmtFbCwgaSwgZnJhZ21lbnRCb2R5LCBwYXN0ZUJsb2NrID0gdGhpcy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgICAgIHBhc3RlQmxvY2suYXBwZW5kQ2hpbGQodGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5JykpO1xuXG4gICAgICAgICAgICBmcmFnbWVudEJvZHkgPSBwYXN0ZUJsb2NrLnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgICAgICAgICAgIGZyYWdtZW50Qm9keS5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFudXBTcGFucyhmcmFnbWVudEJvZHkpO1xuXG4gICAgICAgICAgICBlbExpc3QgPSBmcmFnbWVudEJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHdvcmtFbCA9IGVsTGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIGlmICgnYScgPT09IHdvcmtFbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCd0YXJnZXRCbGFuaycpKSB7XG4gICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLnNldFRhcmdldEJsYW5rKHdvcmtFbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuY2xlYW51cEF0dHJzKHdvcmtFbCwgb3B0aW9ucy5jbGVhbkF0dHJzKTtcbiAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5jbGVhbnVwVGFncyh3b3JrRWwsIG9wdGlvbnMuY2xlYW5UYWdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuaW5zZXJ0SFRNTENvbW1hbmQodGhpcy5kb2N1bWVudCwgZnJhZ21lbnRCb2R5LmlubmVySFRNTC5yZXBsYWNlKC8mbmJzcDsvZywgJyAnKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNDb21tb25CbG9jazogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGVsICYmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncCcgfHwgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RpdicpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXJDb21tb25CbG9ja3M6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKC9eXFxzKiQvLnRlc3QoZWwudGV4dENvbnRlbnQpICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXJMaW5lQnJlYWs6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21tb25CbG9jayhlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzdHJheSBicidzIGZvbGxvd2luZyBjb21tb24gYmxvY2sgZWxlbWVudHNcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVdpdGhQYXJlbnQoZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQ29tbW9uQmxvY2soZWwucGFyZW50Tm9kZSkgJiYgKGVsLnBhcmVudE5vZGUuZmlyc3RDaGlsZCA9PT0gZWwgfHwgZWwucGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT09IGVsKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBicidzIGp1c3QgaW5zaWRlIG9wZW4gb3IgY2xvc2UgdGFncyBvZiBhIGRpdi9wXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVXaXRoUGFyZW50KGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLmNoaWxkRWxlbWVudENvdW50ID09PSAxICYmIGVsLnBhcmVudE5vZGUudGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gYW5kIGJyJ3MgdGhhdCBhcmUgdGhlIG9ubHkgY2hpbGQgb2YgZWxlbWVudHMgb3RoZXIgdGhhbiBkaXYvcFxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2l0aFBhcmVudChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVtb3ZlIGFuIGVsZW1lbnQsIGluY2x1ZGluZyBpdHMgcGFyZW50LCBpZiBpdCBpcyB0aGUgb25seSBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG4gICAgICAgIHJlbW92ZVdpdGhQYXJlbnQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZS5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuY2hpbGRFbGVtZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbnVwU3BhbnM6IGZ1bmN0aW9uIChjb250YWluZXJFbCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgbmV3RWwsXG4gICAgICAgICAgICAgICAgc3BhbnMgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcucmVwbGFjZS13aXRoJyksXG4gICAgICAgICAgICAgICAgaXNDRUYgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbCAmJiBlbC5ub2RlTmFtZSAhPT0gJyN0ZXh0JyAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHNwYW5zW2ldO1xuICAgICAgICAgICAgICAgIG5ld0VsID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsLmNsYXNzTGlzdC5jb250YWlucygnYm9sZCcpID8gJ2InIDogJ2knKTtcblxuICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2JvbGQnKSAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2l0YWxpYycpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhbiBpIHRhZyBhcyB3ZWxsIGlmIHRoaXMgaGFzIGJvdGggaXRhbGljcyBhbmQgYm9sZFxuICAgICAgICAgICAgICAgICAgICBuZXdFbC5pbm5lckhUTUwgPSAnPGk+JyArIGVsLmlubmVySFRNTCArICc8L2k+JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdFbC5pbm5lckhUTUwgPSBlbC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0VsLCBlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNwYW5zID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnc3BhbicpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBzcGFuc1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIGJhaWwgaWYgc3BhbiBpcyBpbiBjb250ZW50ZWRpdGFibGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC50cmF2ZXJzZVVwKGVsLCBpc0NFRikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSBzcGFucywgcmVwbGFjZSBvdGhlcnMgd2l0aCB0aGVpciBjb250ZW50c1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLnVud3JhcChlbCwgdGhpcy5kb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLnBhc3RlID0gUGFzdGVIYW5kbGVyO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUGxhY2Vob2xkZXIgPSBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLmV4dGVuZCh7XG4gICAgICAgIG5hbWU6ICdwbGFjZWhvbGRlcicsXG5cbiAgICAgICAgLyogUGxhY2Vob2xkZXIgT3B0aW9ucyAqL1xuXG4gICAgICAgIC8qIHRleHQ6IFtzdHJpbmddXG4gICAgICAgICAqIFRleHQgdG8gZGlzcGxheSBpbiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6ICdUeXBlIHlvdXIgdGV4dCcsXG5cbiAgICAgICAgLyogaGlkZU9uQ2xpY2s6IFtib29sZWFuXVxuICAgICAgICAgKiBTaG91bGQgd2UgaGlkZSB0aGUgcGxhY2Vob2xkZXIgb24gY2xpY2sgKHRydWUpIG9yIHdoZW4gdXNlciBzdGFydHMgdHlwaW5nIChmYWxzZSlcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVPbkNsaWNrOiB0cnVlLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5FeHRlbnNpb24ucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5pbml0UGxhY2Vob2xkZXJzKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0UGxhY2Vob2xkZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdldEVkaXRvckVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicsIHRoaXMudGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGxhY2Vob2xkZXIoZWwpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRFZGl0b3JFbGVtZW50cygpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicpID09PSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXBsYWNlaG9sZGVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd1BsYWNlaG9sZGVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ21lZGl1bS1lZGl0b3ItcGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci1wbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyOiBmdW5jdGlvbiAoZWwsIGRvbnRTaG93KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBoYXMgY29udGVudCwgaGlkZSB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yKCdpbWcsIGJsb2NrcXVvdGUsIHVsLCBvbCcpIHx8IChlbC50ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVQbGFjZWhvbGRlcihlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZG9udFNob3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dQbGFjZWhvbGRlcihlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoRXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZU9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhlICdoaWRlT25DbGljaycgb3B0aW9uLCB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGFsd2F5cyBiZSBoaWRkZW4gb24gZm9jdXNcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZWRpdG9yIGhhcyBjb250ZW50LCBpdCBzaG91bGQgYWx3YXlzIGhpZGUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVJbnB1dCcsIHRoaXMuaGFuZGxlSW5wdXQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGVkaXRvciBsb3NlcyBmb2N1cywgY2hlY2sgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSB2aXNpYmxlXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnYmx1cicsIHRoaXMuaGFuZGxlQmx1ci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVJbnB1dDogZnVuY3Rpb24gKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIGhpZGRlbiBvbiBmb2N1cyBhbmQgdGhlXG4gICAgICAgICAgICAvLyBlbGVtZW50IGhhcyBmb2N1cywgZG9uJ3Qgc2hvdyB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHZhciBkb250U2hvdyA9IHRoaXMuaGlkZU9uQ2xpY2sgJiYgKGVsZW1lbnQgPT09IHRoaXMuYmFzZS5nZXRGb2N1c2VkRWxlbWVudCgpKTtcblxuICAgICAgICAgICAgLy8gRWRpdG9yJ3MgY29udGVudCBoYXMgY2hhbmdlZCwgY2hlY2sgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSBoaWRkZW5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGxhY2Vob2xkZXIoZWxlbWVudCwgZG9udFNob3cpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUZvY3VzOiBmdW5jdGlvbiAoZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEVkaXRvciBoYXMgZm9jdXMsIGhpZGUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB0aGlzLmhpZGVQbGFjZWhvbGRlcihlbGVtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVCbHVyOiBmdW5jdGlvbiAoZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEVkaXRvciBoYXMgbG9zdCBmb2N1cywgY2hlY2sgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSBzaG93blxuICAgICAgICAgICAgdGhpcy51cGRhdGVQbGFjZWhvbGRlcihlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMucGxhY2Vob2xkZXIgPSBQbGFjZWhvbGRlcjtcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFRvb2xiYXIgPSBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLmV4dGVuZCh7XG4gICAgICAgIG5hbWU6ICd0b29sYmFyJyxcblxuICAgICAgICAvKiBUb29sYmFyIE9wdGlvbnMgKi9cblxuICAgICAgICAvKiBhbGlnbjogWydsZWZ0J3wnY2VudGVyJ3wncmlnaHQnXVxuICAgICAgICAgKiBXaGVuIHRoZSBfX3N0YXRpY19fIG9wdGlvbiBpcyB0cnVlLCB0aGlzIGFsaWducyB0aGUgc3RhdGljIHRvb2xiYXJcbiAgICAgICAgICogcmVsYXRpdmUgdG8gdGhlIG1lZGl1bS1lZGl0b3IgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiAnY2VudGVyJyxcblxuICAgICAgICAvKiBhbGxvd011bHRpUGFyYWdyYXBoU2VsZWN0aW9uOiBbYm9vbGVhbl1cbiAgICAgICAgICogZW5hYmxlcy9kaXNhYmxlcyB3aGV0aGVyIHRoZSB0b29sYmFyIHNob3VsZCBiZSBkaXNwbGF5ZWQgd2hlblxuICAgICAgICAgKiBzZWxlY3RpbmcgbXVsdGlwbGUgcGFyYWdyYXBocy9ibG9jayBlbGVtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgYWxsb3dNdWx0aVBhcmFncmFwaFNlbGVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAvKiBidXR0b25zOiBbQXJyYXldXG4gICAgICAgICAqIHRoZSBuYW1lcyBvZiB0aGUgc2V0IG9mIGJ1dHRvbnMgdG8gZGlzcGxheSBvbiB0aGUgdG9vbGJhci5cbiAgICAgICAgICovXG4gICAgICAgIGJ1dHRvbnM6IFsnYm9sZCcsICdpdGFsaWMnLCAndW5kZXJsaW5lJywgJ2FuY2hvcicsICdoMicsICdoMycsICdxdW90ZSddLFxuXG4gICAgICAgIC8qIGRpZmZMZWZ0OiBbTnVtYmVyXVxuICAgICAgICAgKiB2YWx1ZSBpbiBwaXhlbHMgdG8gYmUgYWRkZWQgdG8gdGhlIFggYXhpcyBwb3NpdGlvbmluZyBvZiB0aGUgdG9vbGJhci5cbiAgICAgICAgICovXG4gICAgICAgIGRpZmZMZWZ0OiAwLFxuXG4gICAgICAgIC8qIGRpZmZUb3A6IFtOdW1iZXJdXG4gICAgICAgICAqIHZhbHVlIGluIHBpeGVscyB0byBiZSBhZGRlZCB0byB0aGUgWSBheGlzIHBvc2l0aW9uaW5nIG9mIHRoZSB0b29sYmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlmZlRvcDogLTEwLFxuXG4gICAgICAgIC8qIGZpcnN0QnV0dG9uQ2xhc3M6IFtzdHJpbmddXG4gICAgICAgICAqIENTUyBjbGFzcyBhZGRlZCB0byB0aGUgZmlyc3QgYnV0dG9uIGluIHRoZSB0b29sYmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlyc3RCdXR0b25DbGFzczogJ21lZGl1bS1lZGl0b3ItYnV0dG9uLWZpcnN0JyxcblxuICAgICAgICAvKiBsYXN0QnV0dG9uQ2xhc3M6IFtzdHJpbmddXG4gICAgICAgICAqIENTUyBjbGFzcyBhZGRlZCB0byB0aGUgbGFzdCBidXR0b24gaW4gdGhlIHRvb2xiYXIuXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0QnV0dG9uQ2xhc3M6ICdtZWRpdW0tZWRpdG9yLWJ1dHRvbi1sYXN0JyxcblxuICAgICAgICAvKiBzdGFuZGFyZGl6ZVNlbGVjdGlvblN0YXJ0OiBbYm9vbGVhbl1cbiAgICAgICAgICogZW5hYmxlcy9kaXNhYmxlcyBzdGFuZGFyZGl6aW5nIGhvdyB0aGUgYmVnaW5uaW5nIG9mIGEgcmFuZ2UgaXMgZGVjaWRlZFxuICAgICAgICAgKiBiZXR3ZWVuIGJyb3dzZXJzIHdoZW5ldmVyIHRoZSBzZWxlY3RlZCB0ZXh0IGlzIGFuYWx5emVkIGZvciB1cGRhdGluZyB0b29sYmFyIGJ1dHRvbnMgc3RhdHVzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhbmRhcmRpemVTZWxlY3Rpb25TdGFydDogZmFsc2UsXG5cbiAgICAgICAgLyogc3RhdGljOiBbYm9vbGVhbl1cbiAgICAgICAgICogZW5hYmxlL2Rpc2FibGUgdGhlIHRvb2xiYXIgYWx3YXlzIGRpc3BsYXlpbmcgaW4gdGhlIHNhbWUgbG9jYXRpb25cbiAgICAgICAgICogcmVsYXRpdmUgdG8gdGhlIG1lZGl1bS1lZGl0b3IgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYzogZmFsc2UsXG5cbiAgICAgICAgLyogc3RpY2t5OiBbYm9vbGVhbl1cbiAgICAgICAgICogV2hlbiB0aGUgX19zdGF0aWNfXyBvcHRpb24gaXMgdHJ1ZSwgdGhpcyBlbmFibGVzL2Rpc2FibGVzIHRoZSB0b29sYmFyXG4gICAgICAgICAqIFwic3RpY2tpbmdcIiB0byB0aGUgdmlld3BvcnQgYW5kIHN0YXlpbmcgdmlzaWJsZSBvbiB0aGUgc2NyZWVuIHdoaWxlXG4gICAgICAgICAqIHRoZSBwYWdlIHNjcm9sbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGlja3k6IGZhbHNlLFxuXG4gICAgICAgIC8qIHN0aWNreVRvcE9mZnNldDogW051bWJlcl1cbiAgICAgICAgICogVmFsdWUgaW4gcGl4ZWwgb2YgdGhlIHRvcCBvZmZzZXQgYWJvdmUgdGhlIHRvb2xiYXJcbiAgICAgICAgICovXG4gICAgICAgIHN0aWNreVRvcE9mZnNldDogMCxcblxuICAgICAgICAvKiB1cGRhdGVPbkVtcHR5U2VsZWN0aW9uOiBbYm9vbGVhbl1cbiAgICAgICAgICogV2hlbiB0aGUgX19zdGF0aWNfXyBvcHRpb24gaXMgdHJ1ZSwgdGhpcyBlbmFibGVzL2Rpc2FibGVzIHVwZGF0aW5nXG4gICAgICAgICAqIHRoZSBzdGF0ZSBvZiB0aGUgdG9vbGJhciBidXR0b25zIGV2ZW4gd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZFxuICAgICAgICAgKiAodGhlcmUgaXMgbm8gc2VsZWN0aW9uLCBqdXN0IGEgY3Vyc29yKS5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZU9uRW1wdHlTZWxlY3Rpb246IGZhbHNlLFxuXG4gICAgICAgIC8qIHJlbGF0aXZlQ29udGFpbmVyOiBbbm9kZV1cbiAgICAgICAgICogYXBwZW5kaW5nIHRoZSB0b29sYmFyIHRvIGEgZ2l2ZW4gbm9kZSBpbnN0ZWFkIG9mIGJvZHlcbiAgICAgICAgICovXG4gICAgICAgIHJlbGF0aXZlQ29udGFpbmVyOiBudWxsLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5FeHRlbnNpb24ucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5pbml0VGhyb3R0bGVkTWV0aG9kcygpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVkaXRvck9wdGlvbignZWxlbWVudHNDb250YWluZXInKS5hcHBlbmRDaGlsZCh0aGlzLmdldFRvb2xiYXJFbGVtZW50KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSGVscGVyIG1ldGhvZCB0byBleGVjdXRlIG1ldGhvZCBmb3IgZXZlcnkgZXh0ZW5zaW9uLCBidXQgaWdub3JpbmcgdGhlIHRvb2xiYXIgZXh0ZW5zaW9uXG4gICAgICAgIGZvckVhY2hFeHRlbnNpb246IGZ1bmN0aW9uIChpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZS5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvci5hcHBseShjb250ZXh0IHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUb29sYmFyIGNyZWF0aW9uL2RlbGV0aW9uXG5cbiAgICAgICAgY3JlYXRlVG9vbGJhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICB0b29sYmFyLmlkID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhci0nICsgdGhpcy5nZXRFZGl0b3JJZCgpO1xuICAgICAgICAgICAgdG9vbGJhci5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyJztcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhci5jbGFzc05hbWUgKz0gJyBzdGF0aWMtdG9vbGJhcic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXRpdmVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0b29sYmFyLmNsYXNzTmFtZSArPSAnIG1lZGl1bS1lZGl0b3ItcmVsYXRpdmUtdG9vbGJhcic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvb2xiYXIuY2xhc3NOYW1lICs9ICcgbWVkaXVtLWVkaXRvci1zdGFsa2VyLXRvb2xiYXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlVG9vbGJhckJ1dHRvbnMoKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhbnkgZm9ybXMgdGhhdCBleHRlbnNpb25zIG1heSBoYXZlXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hFeHRlbnNpb24oZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24uaGFzRm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKGV4dGVuc2lvbi5nZXRGb3JtKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50SGFuZGxlcnMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVG9vbGJhckJ1dHRvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1bCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSxcbiAgICAgICAgICAgICAgICBsaSxcbiAgICAgICAgICAgICAgICBidG4sXG4gICAgICAgICAgICAgICAgYnV0dG9ucyxcbiAgICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgYnV0dG9uTmFtZSxcbiAgICAgICAgICAgICAgICBidXR0b25PcHRzO1xuXG4gICAgICAgICAgICB1bC5pZCA9ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItYWN0aW9ucycgKyB0aGlzLmdldEVkaXRvcklkKCk7XG4gICAgICAgICAgICB1bC5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLWFjdGlvbnMnO1xuICAgICAgICAgICAgdWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICAgIHRoaXMuYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJ1dHRvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uTmFtZSA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uT3B0cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uTmFtZSA9IGJ1dHRvbi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBidXR0b25PcHRzID0gYnV0dG9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBidXR0b24gYWxyZWFkeSBleGlzdHMgYXMgYW4gZXh0ZW5zaW9uLCBpdCdsbCBiZSByZXR1cm5lZFxuICAgICAgICAgICAgICAgIC8vIG90aHdlcmlzZSBpdCdsbCBjcmVhdGUgdGhlIGRlZmF1bHQgYnVpbHQtaW4gYnV0dG9uXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gdGhpcy5iYXNlLmFkZEJ1aWx0SW5FeHRlbnNpb24oYnV0dG9uTmFtZSwgYnV0dG9uT3B0cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIHR5cGVvZiBleHRlbnNpb24uZ2V0QnV0dG9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ0biA9IGV4dGVuc2lvbi5nZXRCdXR0b24odGhpcy5iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgbGkgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0VsZW1lbnQoYnRuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYnRuKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpLmlubmVySFRNTCA9IGJ0bjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bC5hcHBlbmRDaGlsZChsaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGJ1dHRvbnMgPSB1bC5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKTtcbiAgICAgICAgICAgIGlmIChidXR0b25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBidXR0b25zWzBdLmNsYXNzTGlzdC5hZGQodGhpcy5maXJzdEJ1dHRvbkNsYXNzKTtcbiAgICAgICAgICAgICAgICBidXR0b25zW2J1dHRvbnMubGVuZ3RoIC0gMV0uY2xhc3NMaXN0LmFkZCh0aGlzLmxhc3RCdXR0b25DbGFzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1bDtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b29sYmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudG9vbGJhcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRvb2xiYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVG9vbGJhciBhY2Nlc3NvcnNcblxuICAgICAgICBnZXRUb29sYmFyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2xiYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUb29sYmFyQWN0aW9uc0VsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRvb2xiYXJFbGVtZW50KCkucXVlcnlTZWxlY3RvcignLm1lZGl1bS1lZGl0b3ItdG9vbGJhci1hY3Rpb25zJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVG9vbGJhciBldmVudCBoYW5kbGVyc1xuXG4gICAgICAgIGluaXRUaHJvdHRsZWRNZXRob2RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0aHJvdHRsZWRQb3NpdGlvblRvb2xiYXIgaXMgdGhyb3R0bGVkIGJlY2F1c2U6XG4gICAgICAgICAgICAvLyAtIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgaXMgcmVzaXppbmcsIHdoaWNoIGNhbiBmaXJlIG1hbnkgdGltZXMgdmVyeSBxdWlja2x5XG4gICAgICAgICAgICAvLyAtIEZvciBzb21lIGV2ZW50IChsaWtlIHJlc2l6ZSkgYSBzbGlnaHQgbGFnIGluIFVJIHJlc3BvbnNpdmVuZXNzIGlzIE9LIGFuZCBwcm92aWRlcyBwZXJmb3JtYW5jZSBiZW5lZml0c1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWRQb3NpdGlvblRvb2xiYXIgPSBNZWRpdW1FZGl0b3IudXRpbC50aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFzZS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uVG9vbGJhcklmU2hvd24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaEV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE1lZGl1bUVkaXRvciBjdXN0b20gZXZlbnRzIGZvciB3aGVuIHVzZXIgYmVpbmdzIGFuZCBlbmRzIGludGVyYWN0aW9uIHdpdGggYSBjb250ZW50ZWRpdGFibGUgYW5kIGl0cyBlbGVtZW50c1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIHRvb2xiYXIgYXMgdGhpbmdzIGNoYW5nZVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlQ2xpY2snLCB0aGlzLmhhbmRsZUVkaXRhYmxlQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXl1cCcsIHRoaXMuaGFuZGxlRWRpdGFibGVLZXl1cC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIG1vdXNldXAgb24gZG9jdW1lbnQgZm9yIHVwZGF0aW5nIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNldXAuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIHNjcm9sbCBldmVudCBmb3Igc3RpY2t5IHRvb2xiYXJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRpYyAmJiB0aGlzLnN0aWNreSkge1xuICAgICAgICAgICAgICAgIC8vIE9uIHNjcm9sbCAoY2FwdHVyZSksIHJlLXBvc2l0aW9uIHRoZSB0b29sYmFyXG4gICAgICAgICAgICAgICAgdGhpcy5vbih0aGlzLndpbmRvdywgJ3Njcm9sbCcsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbiByZXNpemUsIHJlLXBvc2l0aW9uIHRoZSB0b29sYmFyXG4gICAgICAgICAgICB0aGlzLm9uKHRoaXMud2luZG93LCAncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlV2luZG93U2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uVG9vbGJhcklmU2hvd24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkUG9zaXRpb25Ub29sYmFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRG9jdW1lbnRNb3VzZXVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGNoZWNrU3RhdGUgd2hlbiBtb3VzZXVwIGZpcmVzIG92ZXIgdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIGlmIChldmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKSwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUVkaXRhYmxlQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERlbGF5IHRoZSBjYWxsIHRvIGNoZWNrU3RhdGUgdG8gaGFuZGxlIGJ1ZyB3aGVyZSBzZWxlY3Rpb24gaXMgZW1wdHlcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyIGNsaWNraW5nIGluc2lkZSBhIHByZS1leGlzdGluZyBzZWxlY3Rpb25cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0ZSgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVFZGl0YWJsZUtleXVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU3RhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVCbHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBLaWxsIGFueSBwcmV2aW91c2x5IGRlbGF5ZWQgY2FsbHMgdG8gaGlkZSB0aGUgdG9vbGJhclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBCbHVyIG1heSBmaXJlIGV2ZW4gaWYgd2UgaGF2ZSBhIHNlbGVjdGlvbiwgc28gd2Ugd2FudCB0byBwcmV2ZW50IGFueSBkZWxheWVkIHNob3dUb29sYmFyXG4gICAgICAgICAgICAvLyBjYWxscyBmcm9tIGhhcHBlbmluZyBpbiB0aGlzIHNwZWNpZmljIGNhc2VcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5U2hvd1RpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgY2FsbCB0byBoaWRlVG9vbGJhciB0byBoYW5kbGUgYnVnIHdpdGggbXVsdGlwbGUgZWRpdG9ycyBvbiB0aGUgcGFnZSBhdCBvbmNlXG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlVG9vbGJhcigpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb2N1czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1N0YXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSGlkaW5nL3Nob3dpbmcgdG9vbGJhclxuXG4gICAgICAgIGlzRGlzcGxheWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbWVkaXVtLWVkaXRvci10b29sYmFyLWFjdGl2ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dUb29sYmFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZW91dCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tZWRpdG9yLXRvb2xiYXItYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93VG9vbGJhcicsIHt9LCB0aGlzLmJhc2UuZ2V0Rm9jdXNlZEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRvb2xiYXJFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci10b29sYmFyLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaGlkZVRvb2xiYXInLCB7fSwgdGhpcy5iYXNlLmdldEZvY3VzZWRFbGVtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzVG9vbGJhckRlZmF1bHRBY3Rpb25zRGlzcGxheWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb29sYmFyQWN0aW9uc0VsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID09PSAnYmxvY2snO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVUb29sYmFyRGVmYXVsdEFjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG9vbGJhckRlZmF1bHRBY3Rpb25zRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRvb2xiYXJBY3Rpb25zRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd1Rvb2xiYXJEZWZhdWx0QWN0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlRXh0ZW5zaW9uRm9ybXMoKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9vbGJhckRlZmF1bHRBY3Rpb25zRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRvb2xiYXJBY3Rpb25zRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2luZyBzZXRUaW1lb3V0ICsgb3B0aW9ucy5kZWxheSBiZWNhdXNlOlxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBhY3R1YWxseSBiZSBkaXNwbGF5aW5nIHRoZSB0b29sYmFyLCB3aGljaCBzaG91bGQgYmUgY29udHJvbGxlZCBieSBvcHRpb25zLmRlbGF5XG4gICAgICAgICAgICB0aGlzLmRlbGF5U2hvd1RpbWVvdXQgPSB0aGlzLmJhc2UuZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xiYXIoKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUV4dGVuc2lvbkZvcm1zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBIaWRlIGFsbCBleHRlbnNpb24gZm9ybXNcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEV4dGVuc2lvbihmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5oYXNGb3JtICYmIGV4dGVuc2lvbi5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5oaWRlRm9ybSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJlc3BvbmRpbmcgdG8gY2hhbmdlcyBpbiB1c2VyIHNlbGVjdGlvblxuXG4gICAgICAgIC8vIENoZWNrcyBmb3IgZXhpc3RhbmNlIG9mIG11bHRpcGxlIGJsb2NrIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICBtdWx0aXBsZUJsb2NrRWxlbWVudHNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4RW1wdHlIVE1MVGFncyA9IC88W15cXC8+XVtePl0qPjxcXC9bXj5dKz4vZ2ltLCAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMxMjk3MzgvcmVtb3ZlLWVtcHR5LXRhZ3MtdXNpbmctcmVnZXhcbiAgICAgICAgICAgICAgICByZWdleEJsb2NrRWxlbWVudHMgPSBuZXcgUmVnRXhwKCc8KCcgKyBNZWRpdW1FZGl0b3IudXRpbC5ibG9ja0NvbnRhaW5lckVsZW1lbnROYW1lcy5qb2luKCd8JykgKyAnKVtePl0qPicsICdnJyksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSFRNTCA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSHRtbCh0aGlzLmRvY3VtZW50KS5yZXBsYWNlKHJlZ2V4RW1wdHlIVE1MVGFncywgJycpLCAvLyBGaWx0ZXIgb3V0IGVtcHR5IGJsb2NrcyBmcm9tIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGhhc011bHRpUGFyYWdyYXBocyA9IHNlbGVjdGlvbkhUTUwubWF0Y2gocmVnZXhCbG9ja0VsZW1lbnRzKTsgLy8gRmluZCBob3cgbWFueSBibG9jayBlbGVtZW50cyBhcmUgd2l0aGluIHRoZSBodG1sXG5cbiAgICAgICAgICAgIHJldHVybiAhIWhhc011bHRpUGFyYWdyYXBocyAmJiBoYXNNdWx0aVBhcmFncmFwaHMubGVuZ3RoID4gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb2RpZnlTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLndpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiBJbiBmaXJlZm94LCB0aGVyZSBhcmUgY2FzZXMgKGllIGRvdWJsZWNsaWNrIG9mIGEgd29yZCkgd2hlcmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0XG4gICAgICAgICAgICAqIHdpbGwgYmUgYXQgdGhlIHZlcnkgZW5kIG9mIGFuIGVsZW1lbnQuICBJbiBvdGhlciBicm93c2VycywgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0XG4gICAgICAgICAgICAqIHdvdWxkIGluc3RlYWQgYmUgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGFuIGVsZW1lbnQgdGhhdCBhY3R1YWxseSBoYXMgY29udGVudC5cbiAgICAgICAgICAgICogZXhhbXBsZTpcbiAgICAgICAgICAgICogICA8c3Bhbj5mb288L3NwYW4+PHNwYW4+YmFyPC9zcGFuPlxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBJZiB0aGUgdGV4dCAnYmFyJyBpcyBzZWxlY3RlZCwgbW9zdCBicm93c2VycyB3aWxsIGhhdmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICogb2YgdGhlICdiYXInIHNwYW4uICBIb3dldmVyLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgZmlyZWZveCB3aWxsIGhhdmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0XG4gICAgICAgICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlICdmb28nIHNwYW4uICBUaGUgY29udGVudGVkaXRhYmxlIGJlaGF2aW9yIHdpbGwgYmUgb2ssIGJ1dCBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgICAgICAqIHByb3BlcnRpZXMgb24gdGhlICdiYXInIHNwYW4sIHRoZXkgd29uJ3QgYmUgcmVmbGVjdGVkIGFjY3VyYXRlbHkgaW4gdGhlIHRvb2xiYXJcbiAgICAgICAgICAgICogKGllICdCb2xkJyBidXR0b24gd291bGRuJ3QgYmUgYWN0aXZlKVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBTbywgZm9yIGNhc2VzIHdoZXJlIHRoZSBzZWxlY3Rpb25SYW5nZSBzdGFydCBpcyBhdCB0aGUgZW5kIG9mIGFuIGVsZW1lbnQvbm9kZSwgZmluZCB0aGUgbmV4dFxuICAgICAgICAgICAgKiBhZGphY2VudCB0ZXh0IG5vZGUgdGhhdCBhY3R1YWxseSBoYXMgY29udGVudCBpbiBpdCwgYW5kIG1vdmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0IHRoZXJlLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YW5kYXJkaXplU2VsZWN0aW9uU3RhcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb25SYW5nZS5zdGFydE9mZnNldCA9PT0gc2VsZWN0aW9uUmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRqYWNlbnROb2RlID0gTWVkaXVtRWRpdG9yLnV0aWwuZmluZEFkamFjZW50VGV4dE5vZGVXaXRoQ29udGVudChNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkVsZW1lbnQodGhpcy53aW5kb3cpLCBzZWxlY3Rpb25SYW5nZS5zdGFydENvbnRhaW5lciwgdGhpcy5kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFkamFjZW50Tm9kZS5ub2RlVmFsdWUuc3Vic3RyKG9mZnNldCwgMSkudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KHRoaXMuZG9jdW1lbnQsIGFkamFjZW50Tm9kZSwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UuZW5kQ29udGFpbmVyLCBzZWxlY3Rpb25SYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjaGVja1N0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlLnByZXZlbnRTZWxlY3Rpb25VcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBlZGl0YWJsZSBoYXMgZm9jdXMgT1Igc2VsZWN0aW9uIGlzIGluc2lkZSBjb250ZW50ZWRpdGFibGUgPSBmYWxzZVxuICAgICAgICAgICAgLy8gaGlkZSB0b29sYmFyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYmFzZS5nZXRGb2N1c2VkRWxlbWVudCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uc2VsZWN0aW9uSW5Db250ZW50RWRpdGFibGVGYWxzZSh0aGlzLndpbmRvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHNlbGVjdGlvbiBlbGVtZW50LCBzZWxlY3Rpb24gZWxlbWVudCBkb2Vzbid0IGJlbG9uZyB0byB0aGlzIGVkaXRvclxuICAgICAgICAgICAgLy8gb3IgdG9vbGJhciBpcyBkaXNhYmxlZCBmb3IgdGhpcyBzZWxlY3Rpb24gZWxlbWVudFxuICAgICAgICAgICAgLy8gaGlkZSB0b29sYmFyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRWxlbWVudCA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uRWxlbWVudCh0aGlzLndpbmRvdyk7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbkVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFZGl0b3JFbGVtZW50cygpLmluZGV4T2Yoc2VsZWN0aW9uRWxlbWVudCkgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGUtdG9vbGJhcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZVRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHdlIGtub3cgdGhlcmUncyBhIGZvY3VzZWQgZWRpdGFibGUgd2l0aCBhIHNlbGVjdGlvblxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXBkYXRlT25FbXB0eVNlbGVjdGlvbiBvcHRpb24gaXMgdHJ1ZSwgc2hvdyB0aGUgdG9vbGJhclxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlT25FbXB0eVNlbGVjdGlvbiAmJiB0aGlzLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dBbmRVcGRhdGVUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSAndmFsaWQnIHNlbGVjdGlvbiAtPiBoaWRlIHRvb2xiYXJcbiAgICAgICAgICAgIGlmICghTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5zZWxlY3Rpb25Db250YWluc0NvbnRlbnQodGhpcy5kb2N1bWVudCkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5hbGxvd011bHRpUGFyYWdyYXBoU2VsZWN0aW9uID09PSBmYWxzZSAmJiB0aGlzLm11bHRpcGxlQmxvY2tFbGVtZW50c1NlbGVjdGVkKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZVRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zaG93QW5kVXBkYXRlVG9vbGJhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFVwZGF0aW5nIHRoZSB0b29sYmFyXG5cbiAgICAgICAgc2hvd0FuZFVwZGF0ZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNldFRvb2xiYXJCdXR0b25TdGF0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncG9zaXRpb25Ub29sYmFyJywge30sIHRoaXMuYmFzZS5nZXRGb2N1c2VkRWxlbWVudCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZXRUb29sYmFyUG9zaXRpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRUb29sYmFyQnV0dG9uU3RhdGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hFeHRlbnNpb24oZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmlzQWN0aXZlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBleHRlbnNpb24uc2V0SW5hY3RpdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLnNldEluYWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tBY3RpdmVCdXR0b25zKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hlY2tBY3RpdmVCdXR0b25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFudWFsU3RhdGVDaGVja3MgPSBbXSxcbiAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gbnVsbCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5kb2N1bWVudCksXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICB1cGRhdGVFeHRlbnNpb25TdGF0ZSA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24uY2hlY2tTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmNoZWNrU3RhdGUocGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4dGVuc2lvbi5pc0FjdGl2ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBleHRlbnNpb24uaXNBbHJlYWR5QXBwbGllZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBleHRlbnNpb24uc2V0QWN0aXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dGVuc2lvbi5pc0FjdGl2ZSgpICYmIGV4dGVuc2lvbi5pc0FscmVhZHlBcHBsaWVkKHBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLnNldEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBleHRlbnNpb25zXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hFeHRlbnNpb24oZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIEZvciB0aG9zZSBleHRlbnNpb25zIHdoZXJlIHdlIGNhbiB1c2UgZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUoKSwgZG8gc29cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbi5xdWVyeUNvbW1hbmRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gZXh0ZW5zaW9uLnF1ZXJ5Q29tbWFuZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHF1ZXJ5Q29tbWFuZFN0YXRlIHJldHVybnMgYSB2YWxpZCB2YWx1ZSwgd2UgY2FuIHRydXN0IHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkb24ndCBuZWVkIHRvIGRvIG91ciBtYW51YWwgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlTdGF0ZSAmJiB0eXBlb2YgZXh0ZW5zaW9uLnNldEFjdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5zZXRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgcXVlcnlDb21tYW5kU3RhdGUgZm9yIHRoaXMgZXh0ZW5zaW9uLCBzbyBhZGQgdG8gbWFudWFsU3RhdGVDaGVja3NcbiAgICAgICAgICAgICAgICBtYW51YWxTdGF0ZUNoZWNrcy5wdXNoKGV4dGVuc2lvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWRQYXJlbnRFbGVtZW50KHNlbGVjdGlvblJhbmdlKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gcGFyZW50IGlzbid0IG91dHNpZGUgb2YgdGhlIGNvbnRlbnRlZGl0YWJsZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldEVkaXRvckVsZW1lbnRzKCkuc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KGVsZW1lbnQsIHBhcmVudE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGltYiB1cCB0aGUgRE9NIGFuZCBkbyBtYW51YWwgY2hlY2tzIGZvciB3aGV0aGVyIGEgY2VydGFpbiBleHRlbnNpb24gaXMgY3VycmVudGx5IGVuYWJsZWQgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBtYW51YWxTdGF0ZUNoZWNrcy5mb3JFYWNoKHVwZGF0ZUV4dGVuc2lvblN0YXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBhYm9ydCB0aGUgc2VhcmNoIHVwd2FyZHMgaWYgd2UgbGVhdmUgdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQb3NpdGlvbmluZyB0b29sYmFyXG5cbiAgICAgICAgcG9zaXRpb25Ub29sYmFySWZTaG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VG9vbGJhclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0VG9vbGJhclBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5iYXNlLmdldEZvY3VzZWRFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy53aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgYW5jaG9yUHJldmlldztcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXNuJ3QgYSB2YWxpZCBzZWxlY3Rpb24sIGJhaWxcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRpYyAmJiAhdGhpcy5yZWxhdGl2ZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xiYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uU3RhdGljVG9vbGJhcihjb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93VG9vbGJhcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCBhbnkgYWJzb2x1dGUgcG9zaXRpb25pbmcgaWYgcmVsYXRpdmVDb250YWluZXIgaXMgc2V0XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25Ub29sYmFyKHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmNob3JQcmV2aWV3ID0gdGhpcy5iYXNlLmdldEV4dGVuc2lvbkJ5TmFtZSgnYW5jaG9yLXByZXZpZXcnKTtcblxuICAgICAgICAgICAgaWYgKGFuY2hvclByZXZpZXcgJiYgdHlwZW9mIGFuY2hvclByZXZpZXcuaGlkZVByZXZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhbmNob3JQcmV2aWV3LmhpZGVQcmV2aWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb25TdGF0aWNUb29sYmFyOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgdG9vbGJhciBhdCBsZWZ0IDAsIHNvIHdlIGNhbiBnZXQgdGhlIHJlYWwgd2lkdGggb2YgdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKS5zdHlsZS5sZWZ0ID0gJzAnO1xuXG4gICAgICAgICAgICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgZm9yIElFIDlcbiAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSAodGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fCB0aGlzLmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gdGhpcy53aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudCA9IHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclRvcCA9IGNvbnRhaW5lclJlY3QudG9wICsgc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckNlbnRlciA9IChjb250YWluZXJSZWN0LmxlZnQgKyAoY29udGFpbmVyUmVjdC53aWR0aCAvIDIpKSxcbiAgICAgICAgICAgICAgICB0b29sYmFySGVpZ2h0ID0gdG9vbGJhckVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvb2xiYXJXaWR0aCA9IHRvb2xiYXJFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgIGhhbGZPZmZzZXRXaWR0aCA9IHRvb2xiYXJXaWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBiZXlvbmQgdGhlIGhlaWdodCBvZiB0aGUgZWRpdG9yLCBwb3NpdGlvbiBpdCBhdCB0aGUgYm90dG9tIG9mIHRoZSBlZGl0b3JcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVG9wID4gKGNvbnRhaW5lclRvcCArIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0b29sYmFySGVpZ2h0IC0gdGhpcy5zdGlja3lUb3BPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IChjb250YWluZXJUb3AgKyBjb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gdG9vbGJhckhlaWdodCkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tZWRpdG9yLXN0aWNreS10b29sYmFyJyk7XG4gICAgICAgICAgICAgICAgLy8gU3RpY2sgdGhlIHRvb2xiYXIgdG8gdGhlIHRvcCBvZiB0aGUgd2luZG93XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AgPiAoY29udGFpbmVyVG9wIC0gdG9vbGJhckhlaWdodCAtIHRoaXMuc3RpY2t5VG9wT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tZWRpdG9yLXN0aWNreS10b29sYmFyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IHRoaXMuc3RpY2t5VG9wT2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgc3RhdGljIHRvb2xiYXIgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tZWRpdG9yLXN0aWNreS10b29sYmFyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IGNvbnRhaW5lclRvcCAtIHRvb2xiYXJIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUudG9wID0gY29udGFpbmVyVG9wIC0gdG9vbGJhckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gY29udGFpbmVyUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IGNvbnRhaW5lclJlY3QucmlnaHQgLSB0b29sYmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IGNvbnRhaW5lckNlbnRlciAtIGhhbGZPZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRMZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodGFyZ2V0TGVmdCArIHRvb2xiYXJXaWR0aCkgPiB3aW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAod2luZG93V2lkdGggLSBNYXRoLmNlaWwodG9vbGJhcldpZHRoKSAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b29sYmFyRWxlbWVudC5zdHlsZS5sZWZ0ID0gdGFyZ2V0TGVmdCArICdweCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb25Ub29sYmFyOiBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgdG9vbGJhciBhdCBsZWZ0IDAsIHNvIHdlIGNhbiBnZXQgdGhlIHJlYWwgd2lkdGggb2YgdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKS5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICAgICAgdGhpcy5nZXRUb29sYmFyRWxlbWVudCgpLnN0eWxlLnJpZ2h0ID0gJ2luaXRpYWwnO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2VsZWN0aW9ucyB3aXRoIGp1c3QgaW1hZ2VzXG4gICAgICAgICAgICBpZiAoIWJvdW5kYXJ5IHx8ICgoYm91bmRhcnkuaGVpZ2h0ID09PSAwICYmIGJvdW5kYXJ5LndpZHRoID09PSAwKSAmJiByYW5nZS5zdGFydENvbnRhaW5lciA9PT0gcmFuZ2UuZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBuZXN0ZWQgaW1hZ2UsIHVzZSB0aGF0IGZvciB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIucXVlcnlTZWxlY3RvcignaW1nJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkgPSByYW5nZS5zdGFydENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHRoaXMud2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgbWlkZGxlQm91bmRhcnkgPSAoYm91bmRhcnkubGVmdCArIGJvdW5kYXJ5LnJpZ2h0KSAvIDIsXG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQgPSB0aGlzLmdldFRvb2xiYXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgdG9vbGJhckhlaWdodCA9IHRvb2xiYXJFbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICB0b29sYmFyV2lkdGggPSB0b29sYmFyRWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBoYWxmT2Zmc2V0V2lkdGggPSB0b29sYmFyV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIGJ1dHRvbkhlaWdodCA9IDUwLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMZWZ0ID0gdGhpcy5kaWZmTGVmdCAtIGhhbGZPZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgaWYgKGJvdW5kYXJ5LnRvcCA8IGJ1dHRvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21lZGl1bS10b29sYmFyLWFycm93LW92ZXInKTtcbiAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tdG9vbGJhci1hcnJvdy11bmRlcicpO1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IGJ1dHRvbkhlaWdodCArIGJvdW5kYXJ5LmJvdHRvbSAtIHRoaXMuZGlmZlRvcCArIHRoaXMud2luZG93LnBhZ2VZT2Zmc2V0IC0gdG9vbGJhckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21lZGl1bS10b29sYmFyLWFycm93LXVuZGVyJyk7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLXRvb2xiYXItYXJyb3ctb3ZlcicpO1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IGJvdW5kYXJ5LnRvcCArIHRoaXMuZGlmZlRvcCArIHRoaXMud2luZG93LnBhZ2VZT2Zmc2V0IC0gdG9vbGJhckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaWRkbGVCb3VuZGFyeSA8IGhhbGZPZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLmxlZnQgPSBkZWZhdWx0TGVmdCArIGhhbGZPZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUucmlnaHQgPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh3aW5kb3dXaWR0aCAtIG1pZGRsZUJvdW5kYXJ5KSA8IGhhbGZPZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUucmlnaHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5zdHlsZS5sZWZ0ID0gZGVmYXVsdExlZnQgKyBtaWRkbGVCb3VuZGFyeSArICdweCc7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUucmlnaHQgPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLnRvb2xiYXIgPSBUb29sYmFyO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgSW1hZ2VEcmFnZ2luZyA9IE1lZGl1bUVkaXRvci5FeHRlbnNpb24uZXh0ZW5kKHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVEcmFnJywgdGhpcy5oYW5kbGVEcmFnLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlRHJvcCcsIHRoaXMuaGFuZGxlRHJvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVEcmFnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci1kcmFnb3Zlcic7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG5cbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnZHJhZ292ZXInKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2RyYWdsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZURyb3A6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtZWRpdW0tZWRpdG9yLWRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICBmaWxlcztcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gSUU5IGRvZXMgbm90IHN1cHBvcnQgdGhlIEZpbGUgQVBJLCBzbyBwcmV2ZW50IGZpbGUgZnJvbSBvcGVuaW5nIGluIGEgbmV3IHdpbmRvd1xuICAgICAgICAgICAgLy8gYnV0IGFsc28gZG9uJ3QgdHJ5IHRvIGFjdHVhbGx5IGdldCB0aGUgZmlsZVxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcykge1xuICAgICAgICAgICAgICAgIGZpbGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzLCAwKTtcbiAgICAgICAgICAgICAgICBmaWxlcy5zb21lKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUubWF0Y2goJ2ltYWdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlUmVhZGVyLCBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9ICdtZWRpdW0taW1nLScgKyAoK25ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuaW5zZXJ0SFRNTENvbW1hbmQodGhpcy5kb2N1bWVudCwgJzxpbWcgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLWltYWdlLWxvYWRpbmdcIiBpZD1cIicgKyBpZCArICdcIiAvPicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmltYWdlRHJhZ2dpbmcgPSBJbWFnZURyYWdnaW5nO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBFdmVudCBoYW5kbGVycyB0aGF0IHNob3VsZG4ndCBiZSBleHBvc2VkIGV4dGVybmFsbHlcblxuICAgIGZ1bmN0aW9uIGhhbmRsZURpc2FibGVFeHRyYVNwYWNlcyhldmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50LFxuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldENhcmV0T2Zmc2V0cyhub2RlKTtcblxuICAgICAgICBpZiAoKHRleHRDb250ZW50W2NhcmV0UG9zaXRpb25zLmxlZnQgLSAxXSA9PT0gdW5kZWZpbmVkKSB8fCAodGV4dENvbnRlbnRbY2FyZXRQb3NpdGlvbnMubGVmdCAtIDFdLnRyaW0oKSA9PT0gJycpIHx8ICh0ZXh0Q29udGVudFtjYXJldFBvc2l0aW9ucy5sZWZ0XSAhPT0gdW5kZWZpbmVkICYmIHRleHRDb250ZW50W2NhcmV0UG9zaXRpb25zLmxlZnRdLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRGlzYWJsZWRFbnRlcktleWRvd24oZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlUmV0dXJuIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGUtcmV0dXJuJykpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVEb3VibGVSZXR1cm4gfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1kb3VibGUtcmV0dXJuJykpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25TdGFydCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gaXMgZW1wdHkgT1IgcHJldmlvdXMgc2libGluZyB0ZXh0IGlzIGVtcHR5IE9SIGl0IGlzIG5vdCBhIGxpc3RcbiAgICAgICAgICAgIGlmICgobm9kZSAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gJycgJiYgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnbGknKSB8fFxuICAgICAgICAgICAgICAgIChub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdicicgJiZcbiAgICAgICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50LnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRhYktleWRvd24oZXZlbnQpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGFiIG9ubHkgZm9yIHByZSBub2Rlc1xuICAgICAgICB2YXIgbm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgICAgdGFnID0gbm9kZSAmJiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHRhZyA9PT0gJ3ByZScpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5pbnNlcnRIVE1MQ29tbWFuZCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCwgJyAgICAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhYiB0byBpbmRlbnQgbGlzdCBzdHJ1Y3R1cmVzIVxuICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNMaXN0SXRlbShub2RlKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gSWYgU2hpZnQgaXMgZG93biwgb3V0ZGVudCwgb3RoZXJ3aXNlIGluZGVudFxuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQoJ291dGRlbnQnLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbmRlbnQnLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVCbG9ja0RlbGV0ZUtleWRvd25zKGV2ZW50KSB7XG4gICAgICAgIHZhciBwLCBub2RlID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25TdGFydCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgICB0YWdOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgaXNFbXB0eSA9IC9eKFxccyt8PGJyXFwvPz4pPyQvaSxcbiAgICAgICAgICAgIGlzSGVhZGVyID0gL2hcXGQvaTtcblxuICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIFtNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLkJBQ0tTUEFDRSwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5FTlRFUl0pICYmXG4gICAgICAgICAgICAgICAgLy8gaGFzIGEgcHJlY2VlZGluZyBzaWJsaW5nXG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgLy8gaW4gYSBoZWFkZXJcbiAgICAgICAgICAgICAgICBpc0hlYWRlci50ZXN0KHRhZ05hbWUpICYmXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBibG9ja1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0Q2FyZXRPZmZzZXRzKG5vZGUpLmxlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5CQUNLU1BBQ0UpICYmIGlzRW1wdHkudGVzdChub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoZSBiZWdpbmluZyBvZiBhIGhlYWRlciBpbnRvIGFuIGVtcHR5IHByZXZpb3VzIGVsZW1lbnQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgdGFnTmFtZSBvZiB0aGUgY3VycmVudCBub2RlIHRvIHByZXZlbnQgb25lXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBkZWxldGUgcHJldmlvdXMgbm9kZSBhbmQgY2FuY2VsIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICBub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZURvdWJsZVJldHVybiAmJiBNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5FTlRFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBoaXR0aW5nIHJldHVybiBpbiB0aGUgYmVnaW5pbmcgb2YgYSBoZWFkZXIgd2lsbCBjcmVhdGUgZW1wdHkgaGVhZGVyIGVsZW1lbnRzIGJlZm9yZSB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLCBtYWtlIFwiPHA+PGJyPjwvcD5cIiBlbGVtZW50LCB3aGljaCBhcmUgd2hhdCBoYXBwZW5zIGlmIHlvdSBoaXQgcmV0dXJuIGluIGFuIGVtcHR5IHBhcmFncmFwaFxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICAgICAgcC5pbm5lckhUTUwgPSAnPGJyPic7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHAsIG5vZGUpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuREVMRVRFKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucHJldmlvdXNFbGVtZW50U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgaW4gYSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgIWlzSGVhZGVyLnRlc3QodGFnTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYW4gZW1wdHkgdGFnXG4gICAgICAgICAgICAgICAgICAgIGlzRW1wdHkudGVzdChub2RlLmlubmVySFRNTCkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgbmV4dCB0YWcgKmlzKiBhIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBpc0hlYWRlci50ZXN0KG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAvLyBoaXR0aW5nIGRlbGV0ZSBpbiBhbiBlbXB0eSBlbGVtZW50IHByZWNlZGluZyBhIGhlYWRlciwgZXg6XG4gICAgICAgICAgICAvLyAgPHA+W0NVUlNPUl08L3A+PGgxPkhlYWRlcjwvaDE+XG4gICAgICAgICAgICAvLyBXaWxsIGNhdXNlIHRoZSBoMSB0byBiZWNvbWUgYSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAvLyBJbnN0ZWFkLCBkZWxldGUgdGhlIHBhcmFncmFwaCBub2RlIGFuZCBtb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGJlZ2luaW5nIG9mIHRoZSBoMVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgbm9kZSBhbmQgbW92ZSBjdXJzb3IgdG8gc3RhcnQgb2YgaGVhZGVyXG4gICAgICAgICAgICBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLm1vdmVDdXJzb3IodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKTtcblxuICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuQkFDS1NQQUNFKSAmJlxuICAgICAgICAgICAgICAgIHRhZ05hbWUgPT09ICdsaScgJiZcbiAgICAgICAgICAgICAgICAvLyBoaXR0aW5nIGJhY2tzcGFjZSBpbnNpZGUgYW4gZW1wdHkgbGlcbiAgICAgICAgICAgICAgICBpc0VtcHR5LnRlc3Qobm9kZS5pbm5lckhUTUwpICYmXG4gICAgICAgICAgICAgICAgLy8gaXMgZmlyc3QgZWxlbWVudCAobm8gcHJlY2VlZGluZyBzaWJsaW5ncylcbiAgICAgICAgICAgICAgICAhbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGFsc28gZG9lcyBub3QgaGF2ZSBhIHNpYmxpbmdcbiAgICAgICAgICAgICAgICAhbm9kZS5wYXJlbnRFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIG9ubHkgbGkgaW4gYSBsaXN0XG4gICAgICAgICAgICAgICAgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICBub2RlLm5leHRFbGVtZW50U2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGknKSB7XG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBpbiBhbiBlbXB0eSBmaXJzdCBsaXN0IGVsZW1lbnQgaW4gdGhlIGZpcnN0IGxpc3QgKHdpdGggbW9yZSBlbGVtZW50cykgZXg6XG4gICAgICAgICAgICAvLyAgPHVsPjxsaT5bQ1VSU09SXTwvbGk+PGxpPkxpc3QgSXRlbSAyPC9saT48L3VsPlxuICAgICAgICAgICAgLy8gd2lsbCByZW1vdmUgdGhlIGZpcnN0IDxsaT4gYnV0IGFkZCBzb21lIGV4dHJhIGVsZW1lbnQgYmVmb3JlICh2YXJpZXMgYmFzZWQgb24gYnJvd3NlcilcbiAgICAgICAgICAgIC8vIEluc3RlYWQsIHRoaXMgd2lsbDpcbiAgICAgICAgICAgIC8vIDEpIHJlbW92ZSB0aGUgbGlzdCBlbGVtZW50XG4gICAgICAgICAgICAvLyAyKSBjcmVhdGUgYSBwYXJhZ3JhcGggYmVmb3JlIHRoZSBsaXN0XG4gICAgICAgICAgICAvLyAzKSBtb3ZlIHRoZSBjdXJzb3IgaW50byB0aGUgcGFyYWdyYXBoXG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHBhcmFncmFwaCBiZWZvcmUgdGhlIGxpc3RcbiAgICAgICAgICAgIHAgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICBwLmlubmVySFRNTCA9ICc8YnI+JztcbiAgICAgICAgICAgIG5vZGUucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShwLCBub2RlLnBhcmVudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgaW50byB0aGUgbmV3IHBhcmFncmFwaFxuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LCBwKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0IGVsZW1lbnRcbiAgICAgICAgICAgIG5vZGUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChub2RlKTtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5CQUNLU1BBQ0UpICYmXG4gICAgICAgICAgICAgICAgKE1lZGl1bUVkaXRvci51dGlsLmdldENsb3Nlc3RUYWcobm9kZSwgJ2Jsb2NrcXVvdGUnKSAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRDYXJldE9mZnNldHMobm9kZSkubGVmdCA9PT0gMCkge1xuXG4gICAgICAgICAgICAvLyB3aGVuIGN1cnNvciBpcyBhdCB0aGUgYmVnaW5pbmcgb2YgdGhlIGVsZW1lbnQgYW5kIHRoZSBlbGVtZW50IGlzIDxibG9ja3F1b3RlPlxuICAgICAgICAgICAgLy8gdGhlbiBwcmVzc2luZyBiYWNrc3BhY2Uga2V5IHNob3VsZCBjaGFuZ2UgdGhlIDxibG9ja3F1b3RlPiB0byBhIDxwPiB0YWdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5leGVjRm9ybWF0QmxvY2sodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsICdwJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXl1cChldmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgICAgdGFnTmFtZTtcblxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc01lZGl1bUVkaXRvckVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdmb3JtYXRCbG9jaycsIGZhbHNlLCAncCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3lhYndlL21lZGl1bS1lZGl0b3IvaXNzdWVzLzgzNFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20veWFid2UvbWVkaXVtLWVkaXRvci9wdWxsLzM4MlxuICAgICAgICAvLyBEb24ndCBjYWxsIGZvcm1hdCBibG9jayBpZiB0aGlzIGlzIGEgYmxvY2sgZWxlbWVudCAoaWUgaDEsIGZpZ0NhcHRpb24sIGV0Yy4pXG4gICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5FTlRFUikgJiZcbiAgICAgICAgICAgICFNZWRpdW1FZGl0b3IudXRpbC5pc0xpc3RJdGVtKG5vZGUpICYmXG4gICAgICAgICAgICAhTWVkaXVtRWRpdG9yLnV0aWwuaXNCbG9ja0NvbnRhaW5lcihub2RlKSkge1xuXG4gICAgICAgICAgICB0YWdOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gRm9yIGFuY2hvciB0YWdzLCB1bmxpbmtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZCgndW5saW5rJywgZmFsc2UsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgIWV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZCgnZm9ybWF0QmxvY2snLCBmYWxzZSwgJ3AnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEludGVybmFsIGhlbHBlciBtZXRob2RzIHdoaWNoIHNob3VsZG4ndCBiZSBleHBvc2VkIGV4dGVybmFsbHlcblxuICAgIGZ1bmN0aW9uIGFkZFRvRWRpdG9ycyh3aW4pIHtcbiAgICAgICAgaWYgKCF3aW4uX21lZGl1bUVkaXRvcnMpIHtcbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIGJyZWFraW5nIHVzZXJzIHdobyBhcmUgYXNzdW1pbmcgdGhhdCB0aGUgdW5pcXVlIGlkIG9uXG4gICAgICAgICAgICAvLyBtZWRpdW0tZWRpdG9yIGVsZW1lbnRzIHdpbGwgc3RhcnQgYXQgMSwgaW5zZXJ0aW5nIGEgJ251bGwnIGluIHRoZVxuICAgICAgICAgICAgLy8gYXJyYXkgc28gdGhlIHVuaXF1ZS1pZCBjYW4gYWx3YXlzIG1hcCB0byB0aGUgaW5kZXggb2YgdGhlIGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgd2luLl9tZWRpdW1FZGl0b3JzID0gW251bGxdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBhbHJlYWR5IGhhcyBhIHVuaXF1ZSBpZCwgcmUtdXNlIGl0XG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHdpbi5fbWVkaXVtRWRpdG9ycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB3aW4uX21lZGl1bUVkaXRvcnNbdGhpcy5pZF0gPSB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZyb21FZGl0b3JzKHdpbikge1xuICAgICAgICBpZiAoIXdpbi5fbWVkaXVtRWRpdG9ycyB8fCAhd2luLl9tZWRpdW1FZGl0b3JzW3RoaXMuaWRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvKiBTZXR0aW5nIHRoZSBpbnN0YW5jZSB0byBudWxsIGluIHRoZSBhcnJheSBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0IGFsbG93czpcbiAgICAgICAgICogMSkgRWFjaCBpbnN0YW5jZSB0byBwcmVzZXJ2ZSBpdHMgb3duIHVuaXF1ZS1pZCwgZXZlbiBhZnRlciBiZWluZyBkZXN0cm95ZWRcbiAgICAgICAgICogICAgYW5kIGluaXRpYWxpemVkIGFnYWluXG4gICAgICAgICAqIDIpIFRoZSB1bmlxdWUtaWQgdG8gYWx3YXlzIGNvcnJlc3BvbmQgdG8gYW4gaW5kZXggaW4gdGhlIGFycmF5IG9mIG1lZGl1bS1lZGl0b3JcbiAgICAgICAgICogICAgaW5zdGFuY2VzLiBUaHVzLCB3ZSB3aWxsIGJlIGFibGUgdG8gbG9vayBhdCBhIGNvbnRlbnRlZGl0YWJsZSwgYW5kIGRldGVybWluZVxuICAgICAgICAgKiAgICB3aGljaCBpbnN0YW5jZSBpdCBiZWxvbmdzIHRvLCBieSBpbmRleGluZyBpbnRvIHRoZSBnbG9iYWwgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICB3aW4uX21lZGl1bUVkaXRvcnNbdGhpcy5pZF0gPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzQXJyYXkoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzdHJpbmcsIHVzZSBhcyBxdWVyeSBzZWxlY3RvclxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBlbGVtZW50LCBwdXQgaW50byBhcnJheVxuICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNFbGVtZW50KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBbc2VsZWN0b3JdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgTm9kZUxpc3QgKG9yIG90aGVyIGFycmF5IGxpa2Ugb2JqZWN0KSBpbnRvIGFuIGFycmF5XG4gICAgICAgIHZhciBlbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShzZWxlY3Rvcik7XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVsZW1lbnRzIGFuZCBjb252ZXJ0IHRleHRhcmVhJ3MgaW50byBkaXZzXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2goY3JlYXRlQ29udGVudEVkaXRhYmxlLmNhbGwodGhpcywgZWxlbWVudCwgaW5kZXgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRFeHRlbnNpb25EZWZhdWx0cyhleHRlbnNpb24sIGRlZmF1bHRzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25bcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEV4dGVuc2lvbihleHRlbnNpb24sIG5hbWUsIGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBleHRlbnNpb25EZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICd3aW5kb3cnOiBpbnN0YW5jZS5vcHRpb25zLmNvbnRlbnRXaW5kb3csXG4gICAgICAgICAgICAnZG9jdW1lbnQnOiBpbnN0YW5jZS5vcHRpb25zLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAnYmFzZSc6IGluc3RhbmNlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIGRlZmF1bHQgb3B0aW9ucyBpbnRvIHRoZSBleHRlbnNpb25cbiAgICAgICAgZXh0ZW5zaW9uID0gc2V0RXh0ZW5zaW9uRGVmYXVsdHMoZXh0ZW5zaW9uLCBleHRlbnNpb25EZWZhdWx0cyk7XG5cbiAgICAgICAgLy8gQ2FsbCBpbml0IG9uIHRoZSBleHRlbnNpb25cbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24uaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLmluaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBleHRlbnNpb24gbmFtZSAoaWYgbm90IGFscmVhZHkgc2V0KVxuICAgICAgICBpZiAoIWV4dGVuc2lvbi5uYW1lKSB7XG4gICAgICAgICAgICBleHRlbnNpb24ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Rvb2xiYXJFbmFibGVkKCkge1xuICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGRvbid0IGhhdmUgdGhlIHRvb2xiYXIgZGlzYWJsZWRcbiAgICAgICAgLy8gV2UgbmVlZCBhIHRvb2xiYXJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNhYmxlLXRvb2xiYXInKTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRvb2xiYXIgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQW5jaG9yUHJldmlld0VuYWJsZWQoKSB7XG4gICAgICAgIC8vIElmIHRvb2xiYXIgaXMgZGlzYWJsZWQsIGRvbid0IGFkZFxuICAgICAgICBpZiAoIWlzVG9vbGJhckVuYWJsZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hbmNob3JQcmV2aWV3ICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BsYWNlaG9sZGVyRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlciAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBdXRvTGlua0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b0xpbmsgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1hZ2VEcmFnZ2luZ0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW1hZ2VEcmFnZ2luZyAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNLZXlib2FyZENvbW1hbmRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5rZXlib2FyZENvbW1hbmRzICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRVc2VGaWxlRHJhZ2dpbmdFeHRlbnNpb24oKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZSBmaWxlLWRyYWdnaW5nIGV4dGVuc2lvbiByZXBsYWNlcyB0aGUgaW1hZ2UtZHJhZ2dpbmcgZXh0ZW5zaW9uLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSB1c2VyIHBhc3NlZCBhbiBvdmVycmlkZWQgaW1hZ2UtZHJhZ2dpbmcgZXh0ZW5zaW9uLlxuICAgICAgICAvLyBJZiB0aGV5IGhhdmUsIHRvIGF2b2lkIGJyZWFraW5nIHVzZXJzLCB3ZSB3b24ndCB1c2UgZmlsZS1kcmFnZ2luZyBleHRlbnNpb24uXG4gICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25zLmV4dGVuc2lvbnNbJ2ltYWdlRHJhZ2dpbmcnXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZW50RWRpdGFibGUodGV4dGFyZWEsIGlkKSB7XG4gICAgICAgIHZhciBkaXYgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICB1bmlxdWVJZCA9ICdtZWRpdW0tZWRpdG9yLScgKyBub3cgKyAnLScgKyBpZCxcbiAgICAgICAgICAgIGF0dHMgPSB0ZXh0YXJlYS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgY2FuIG1vdmUgcHJldHR5IGZhc3QsIHNpbmNlIHdlJ3JlIHVzaW5nIGEgdGltZXN0YW1wXG4gICAgICAgIC8vIHRvIG1ha2UgYSB1bmlxdWUtaWQsIGVuc3VyZSB0aGF0IHRoZSBpZCBpcyBhY3R1YWxseSB1bmlxdWUgb24gdGhlIHBhZ2VcbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVuaXF1ZUlkKSkge1xuICAgICAgICAgICAgbm93Kys7XG4gICAgICAgICAgICB1bmlxdWVJZCA9ICdtZWRpdW0tZWRpdG9yLScgKyBub3cgKyAnLScgKyBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSB0ZXh0YXJlYS5jbGFzc05hbWU7XG4gICAgICAgIGRpdi5pZCA9IHVuaXF1ZUlkO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGV4dGFyZWEudmFsdWU7XG5cbiAgICAgICAgdGV4dGFyZWEuc2V0QXR0cmlidXRlKCdtZWRpdW0tZWRpdG9yLXRleHRhcmVhLWlkJywgdW5pcXVlSWQpO1xuXG4gICAgICAgIC8vIHJlLWNyZWF0ZSBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSB0ZXh0ZWFyZWEgdG8gdGhlIG5ldyBjcmVhdGVkIGRpdlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGF0dHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgcmUtY3JlYXRlIGV4aXN0aW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmICghZGl2Lmhhc0F0dHJpYnV0ZShhdHRzW2ldLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoYXR0c1tpXS5ub2RlTmFtZSwgYXR0c1tpXS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dGFyZWEuY2xhc3NMaXN0LmFkZCgnbWVkaXVtLWVkaXRvci1oaWRkZW4nKTtcbiAgICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICBkaXYsXG4gICAgICAgICAgICB0ZXh0YXJlYVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEVsZW1lbnRzKCkge1xuICAgICAgICB2YXIgaXNUZXh0YXJlYVVzZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlRWRpdGluZyAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1lZGl0aW5nJykpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudEVkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCB0aGlzLm9wdGlvbnMuc3BlbGxjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZWRpdW0tZWRpdG9yLWVsZW1lbnQnLCB0cnVlKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RleHRib3gnKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW11bHRpbGluZScsIHRydWUpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnLCBpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZCcpKSB7XG4gICAgICAgICAgICAgICAgaXNUZXh0YXJlYVVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoaXNUZXh0YXJlYVVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUlucHV0JywgZnVuY3Rpb24gKGV2ZW50LCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYSA9IGVkaXRhYmxlLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcigndGV4dGFyZWFbbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZD1cIicgKyBlZGl0YWJsZS5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItdGV4dGFyZWEtaWQnKSArICdcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dGFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWEudmFsdWUgPSB0aGlzLnNlcmlhbGl6ZSgpW2VkaXRhYmxlLmlkXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoSGFuZGxlcnMoKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIC8vIGF0dGFjaCB0byB0YWJzXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUtleWRvd25UYWInLCBoYW5kbGVUYWJLZXlkb3duLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIEJpbmQga2V5cyB3aGljaCBjYW4gY3JlYXRlIG9yIGRlc3Ryb3kgYSBibG9jayBlbGVtZW50OiBiYWNrc3BhY2UsIGRlbGV0ZSwgcmV0dXJuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUtleWRvd25EZWxldGUnLCBoYW5kbGVCbG9ja0RlbGV0ZUtleWRvd25zLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duRW50ZXInLCBoYW5kbGVCbG9ja0RlbGV0ZUtleWRvd25zLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIEJpbmQgZG91YmxlIHNwYWNlIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUV4dHJhU3BhY2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duU3BhY2UnLCBoYW5kbGVEaXNhYmxlRXh0cmFTcGFjZXMuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkaXNhYmxpbmcgcmV0dXJuIG9yIGRvdWJsZSByZXR1cm5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlUmV0dXJuIHx8IHRoaXMub3B0aW9ucy5kaXNhYmxlRG91YmxlUmV0dXJuKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duRW50ZXInLCBoYW5kbGVEaXNhYmxlZEVudGVyS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGUtcmV0dXJuJykgfHwgdGhpcy5lbGVtZW50c1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1kb3VibGUtcmV0dXJuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlS2V5ZG93bkVudGVyJywgaGFuZGxlRGlzYWJsZWRFbnRlcktleWRvd24uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBkaXNhYmxpbmcgcmV0dXJuLCBhZGQgYSBoYW5kbGVyIHRvIGhlbHAgaGFuZGxlIGNsZWFudXBcbiAgICAgICAgLy8gZm9yIGNlcnRhaW4gY2FzZXMgd2hlbiBlbnRlciBpcyBwcmVzc2VkXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVSZXR1cm4pIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1yZXR1cm4nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKGVsZW1lbnQsICdrZXl1cCcsIGhhbmRsZUtleXVwLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEV4dGVuc2lvbnMoKSB7XG5cbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gW107XG5cbiAgICAgICAgLy8gUGFzc2VkIGluIGV4dGVuc2lvbnNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzYXZlIHRoZSB0b29sYmFyIGV4dGVuc2lvbiBmb3IgbGFzdFxuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICd0b29sYmFyJyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5wdXNoKGluaXRFeHRlbnNpb24odGhpcy5vcHRpb25zLmV4dGVuc2lvbnNbbmFtZV0sIG5hbWUsIHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gNCBDYXNlcyBmb3IgaW1hZ2VEcmFnZ2luZyArIGZpbGVEcmFnZ2luZyBleHRlbnNvbnM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIEltYWdlRHJhZ2dpbmcgT04gKyBObyBDdXN0b20gSW1hZ2UgRHJhZ2dpbmcgRXh0ZW5zaW9uOlxuICAgICAgICAvLyAgICAqIFVzZSBmaWxlRHJhZ2dpbmcgZXh0ZW5zaW9uIChkZWZhdWx0IG9wdGlvbnMpXG4gICAgICAgIC8vIDIuIEltYWdlRHJhZ2dpbmcgT0ZGICsgTm8gQ3VzdG9tIEltYWdlIERyYWdnaW5nIEV4dGVuc2lvbjpcbiAgICAgICAgLy8gICAgKiBVc2UgZmlsZURyYWdnaW5nIGV4dGVuc2lvbiB3LyBpbWFnZXMgdHVybmVkIG9mZlxuICAgICAgICAvLyAzLiBJbWFnZURyYWdnaW5nIE9OICsgQ3VzdG9tIEltYWdlIERyYWdnaW5nIEV4dGVuc2lvbjpcbiAgICAgICAgLy8gICAgKiBEb24ndCB1c2UgZmlsZURyYWdnaW5nIChjb3VsZCBpbnRlcmZlcmUgd2l0aCBjdXN0b20gaW1hZ2UgZHJhZ2dpbmcgZXh0ZW5zaW9uKVxuICAgICAgICAvLyA0LiBJbWFnZURyYWdnaW5nIE9GRiArIEN1c3RvbSBJbWFnZSBEcmFnZ2luZzpcbiAgICAgICAgLy8gICAgKiBEb24ndCB1c2UgZmlsZURyYWdnaW5nIChjb3VsZCBpbnRlcmZlcmUgd2l0aCBjdXN0b20gaW1hZ2UgZHJhZ2dpbmcgZXh0ZW5zaW9uKVxuICAgICAgICBpZiAoc2hvdWxkVXNlRmlsZURyYWdnaW5nRXh0ZW5zaW9uLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLmZpbGVEcmFnZ2luZztcbiAgICAgICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgICAgIG9wdHMgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIEltYWdlIGlzIGluIHRoZSAnYWxsb3dlZFR5cGVzJyBsaXN0IGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgLy8gSWYgaW1hZ2VEcmFnZ2luZyBpcyBvZmYgb3ZlcnJpZGUgdGhlICdhbGxvd2VkVHlwZXMnIGxpc3Qgd2l0aCBhbiBlbXB0eSBvbmVcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW1hZ2VEcmFnZ2luZ0VuYWJsZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmFsbG93ZWRUeXBlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQnVpbHRJbkV4dGVuc2lvbignZmlsZURyYWdnaW5nJywgb3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsdC1pbiBleHRlbnNpb25zXG4gICAgICAgIHZhciBidWlsdElucyA9IHtcbiAgICAgICAgICAgIHBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgJ2FuY2hvci1wcmV2aWV3JzogaXNBbmNob3JQcmV2aWV3RW5hYmxlZC5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgYXV0b0xpbms6IGlzQXV0b0xpbmtFbmFibGVkLmNhbGwodGhpcyksXG4gICAgICAgICAgICBrZXlib2FyZENvbW1hbmRzOiBpc0tleWJvYXJkQ29tbWFuZHNFbmFibGVkLmNhbGwodGhpcyksXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogaXNQbGFjZWhvbGRlckVuYWJsZWQuY2FsbCh0aGlzKVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhidWlsdElucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGJ1aWx0SW5zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCdWlsdEluRXh0ZW5zaW9uKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBVc2VycyBjYW4gcGFzcyBpbiBhIGN1c3RvbSB0b29sYmFyIGV4dGVuc2lvblxuICAgICAgICAvLyBzbyBjaGVjayBmb3IgdGhhdCBmaXJzdCBhbmQgaWYgaXQncyBub3QgcHJlc2VudFxuICAgICAgICAvLyBqdXN0IGNyZWF0ZSB0aGUgZGVmYXVsdCB0b29sYmFyXG4gICAgICAgIHZhciB0b29sYmFyRXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnNbJ3Rvb2xiYXInXTtcbiAgICAgICAgaWYgKCF0b29sYmFyRXh0ZW5zaW9uICYmIGlzVG9vbGJhckVuYWJsZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGFiaWxpdHlcbiAgICAgICAgICAgIHZhciB0b29sYmFyT3B0aW9ucyA9IE1lZGl1bUVkaXRvci51dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLnRvb2xiYXIsIHtcbiAgICAgICAgICAgICAgICBhbGxvd011bHRpUGFyYWdyYXBoU2VsZWN0aW9uOiB0aGlzLm9wdGlvbnMuYWxsb3dNdWx0aVBhcmFncmFwaFNlbGVjdGlvbiAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvb2xiYXJFeHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMudG9vbGJhcih0b29sYmFyT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdG9vbGJhciBpcyBub3QgZGlzYWJsZWQsIHNvIHdlIGFjdHVhbGx5IGhhdmUgYW4gZXh0ZW5zaW9uXG4gICAgICAgIC8vIGluaXRpYWxpemUgaXQgYW5kIGFkZCBpdCB0byB0aGUgZXh0ZW5zaW9ucyBhcnJheVxuICAgICAgICBpZiAodG9vbGJhckV4dGVuc2lvbikge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLnB1c2goaW5pdEV4dGVuc2lvbih0b29sYmFyRXh0ZW5zaW9uLCAndG9vbGJhcicsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVwcmVjYXRlZFByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICBbJ2FsbG93TXVsdGlQYXJhZ3JhcGhTZWxlY3Rpb24nLCAndG9vbGJhci5hbGxvd011bHRpUGFyYWdyYXBoU2VsZWN0aW9uJ11cbiAgICAgICAgXTtcbiAgICAgICAgLy8gd2FybiBhYm91dCB1c2luZyBkZXByZWNhdGVkIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWRQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYWlyWzBdKSAmJiBvcHRpb25zW3BhaXJbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuZGVwcmVjYXRlZChwYWlyWzBdLCBwYWlyWzFdLCAndjYuMC4wJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLnV0aWwuZGVmYXVsdHMoe30sIG9wdGlvbnMsIGRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjQWN0aW9uSW50ZXJuYWwoYWN0aW9uLCBvcHRzKSB7XG4gICAgICAgIC8qanNsaW50IHJlZ2V4cDogdHJ1ZSovXG4gICAgICAgIHZhciBhcHBlbmRBY3Rpb24gPSAvXmFwcGVuZC0oLispJC9naSxcbiAgICAgICAgICAgIGp1c3RpZnlBY3Rpb24gPSAvanVzdGlmeShbQS1aYS16XSopJC9nLCAvKiBEZXRlY3RpbmcgaWYgaXMganVzdGlmeUNlbnRlcnxSaWdodHxMZWZ0ICovXG4gICAgICAgICAgICBtYXRjaDtcbiAgICAgICAgLypqc2xpbnQgcmVnZXhwOiBmYWxzZSovXG5cbiAgICAgICAgLy8gQWN0aW9ucyBzdGFydGluZyB3aXRoICdhcHBlbmQtJyBzaG91bGQgYXR0ZW1wdCB0byBmb3JtYXQgYSBibG9jayBvZiB0ZXh0ICgnZm9ybWF0QmxvY2snKSB1c2luZyBhIHNwZWNpZmljXG4gICAgICAgIC8vIHR5cGUgb2YgYmxvY2sgZWxlbWVudCAoaWUgYXBwZW5kLWJsb2NrcXVvdGUsIGFwcGVuZC1oMSwgYXBwZW5kLXByZSwgZXRjLilcbiAgICAgICAgbWF0Y2ggPSBhcHBlbmRBY3Rpb24uZXhlYyhhY3Rpb24pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBNZWRpdW1FZGl0b3IudXRpbC5leGVjRm9ybWF0QmxvY2sodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsIG1hdGNoWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdmb250U2l6ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZCgnZm9udFNpemUnLCBmYWxzZSwgb3B0cy5zaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdmb250TmFtZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZCgnZm9udE5hbWUnLCBmYWxzZSwgb3B0cy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdjcmVhdGVMaW5rJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGluayhvcHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHZhciBzcmMgPSB0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0SW1hZ2UnLCBmYWxzZSwgc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIElzc3VlOiBodHRwczovL2dpdGh1Yi5jb20veWFid2UvbWVkaXVtLWVkaXRvci9pc3N1ZXMvNTk1XG4gICAgICAgICAqIElmIHRoZSBhY3Rpb24gaXMgdG8ganVzdGlmeSB0aGUgdGV4dCAqL1xuICAgICAgICBpZiAoanVzdGlmeUFjdGlvbi5leGVjKGFjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZChhY3Rpb24sIGZhbHNlLCBudWxsKSxcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQoTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25SYW5nZSh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCkpO1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwSnVzdGlmeURpdkZyYWdtZW50cy5jYWxsKHRoaXMsIE1lZGl1bUVkaXRvci51dGlsLmdldFRvcEJsb2NrQ29udGFpbmVyKHBhcmVudE5vZGUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZChhY3Rpb24sIGZhbHNlLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKiBJZiB3ZSd2ZSBqdXN0IGp1c3RpZmllZCB0ZXh0IHdpdGhpbiBhIGNvbnRhaW5lciBibG9ja1xuICAgICAqIENocm9tZSBtYXkgaGF2ZSByZW1vdmVkIDxicj4gZWxlbWVudHMgYW5kIGluc3RlYWQgd3JhcHBlZCBsaW5lcyBpbiA8ZGl2PiBlbGVtZW50c1xuICAgICAqIHdpdGggYSB0ZXh0LWFsaWduIHByb3BlcnR5LiAgSWYgc28sIHdlIHdhbnQgdG8gZml4IHRoaXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhbnVwSnVzdGlmeURpdkZyYWdtZW50cyhibG9ja0NvbnRhaW5lcikge1xuICAgICAgICBpZiAoIWJsb2NrQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dEFsaWduLFxuICAgICAgICAgICAgY2hpbGREaXZzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmxvY2tDb250YWluZXIuY2hpbGROb2RlcykuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRGl2ID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2JztcbiAgICAgICAgICAgICAgICBpZiAoaXNEaXYgJiYgIXRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBlbGVtZW50LnN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGl2O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLyogSWYgd2UgZm91bmQgY2hpbGQgPGRpdj4gZWxlbWVudHMgd2l0aCB0ZXh0LWFsaWduIHN0eWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICogd2Ugc2hvdWxkIGZpeCB0aGlzIGJ5OlxuICAgICAgICAgKlxuICAgICAgICAgKiAxKSBVbndyYXBwaW5nIGVhY2ggPGRpdj4gd2hpY2ggaGFzIGEgdGV4dC1hbGlnbiBzdHlsZVxuICAgICAgICAgKiAyKSBJbnNlcnQgYSA8YnI+IGVsZW1lbnQgYWZ0ZXIgZWFjaCBzZXQgb2YgJ3Vud3JhcHBlZCcgZGl2IGNoaWxkcmVuXG4gICAgICAgICAqIDMpIFNldCB0aGUgdGV4dC1hbGlnbiBzdHlsZSBvZiB0aGUgcGFyZW50IGJsb2NrIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChjaGlsZERpdnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSdyZSBtdWNraW5nIHdpdGggdGhlIEhUTUwsIHByZXNlcnZlIHNlbGVjdGlvblxuICAgICAgICAgICAgdGhpcy5zYXZlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBjaGlsZERpdnMuZm9yRWFjaChmdW5jdGlvbiAoZGl2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdi5zdHlsZS50ZXh0QWxpZ24gPT09IHRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENoaWxkID0gZGl2Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBhIGRpdiwgZXh0cmFjdCB0aGUgY2hpbGQgZWxlbWVudHMgYW5kIGFkZCBhIDxicj5cbiAgICAgICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLnVud3JhcChkaXYsIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiciA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0JSJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYnIsIGxhc3RDaGlsZC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIGJsb2NrQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUsIHNvIHJlc3RvcmUgc2VsZWN0aW9uXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIE1lZGl1bUVkaXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8vIE5PVCBET0NVTUVOVEVEIC0gZXhwb3NlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHlcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMuY2FsbCh0aGlzLCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ0VsZW1lbnRzID0gZWxlbWVudHM7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVsZW1lbnRzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVsZW1lbnRzQ29udGFpbmVyID0gdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXAoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnRzQXJyYXkuY2FsbCh0aGlzLCB0aGlzLm9yaWdFbGVtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBhZGRUb0VkaXRvcnMuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IE1lZGl1bUVkaXRvci5FdmVudHModGhpcyk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgaW5pdGlhbGl6YXRpb24gaGVscGVyc1xuICAgICAgICAgICAgaW5pdEVsZW1lbnRzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpbml0RXh0ZW5zaW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgYXR0YWNoSGFuZGxlcnMuY2FsbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBlbGVtZW50cyBjb250ZW50LCBmaXggZm9yIGlzc3VlIHdoZXJlIGFmdGVyIGVkaXRvciBkZXN0cm95ZWQgdGhlIHJlZCB1bmRlcmxpbmVzIG9uIHNwZWxsaW5nIGVycm9ycyBhcmUgbGVmdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3BlbGxjaGVjaykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgZXh0cmEgYWRkZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdjb250ZW50RWRpdGFibGUnKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3BlbGxjaGVjaycpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1lZGl1bS1lZGl0b3ItZWxlbWVudCcpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbXVsdGlsaW5lJyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZWxlbWVudHMgY3JlYXRlZCBmb3IgdGV4dGFyZWFzXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdtZWRpdW0tZWRpdG9yLXRleHRhcmVhLWlkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhID0gZWxlbWVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhW21lZGl1bS1lZGl0b3ItdGV4dGFyZWEtaWQ9XCInICsgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItdGV4dGFyZWEtaWQnKSArICdcIl0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRhcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1oaWRlIHRoZSB0ZXh0YXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWEuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgcmVtb3ZlRnJvbUVkaXRvcnMuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuYXR0YWNoRE9NRXZlbnQodGFyZ2V0LCBldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kZXRhY2hET01FdmVudCh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5hdHRhY2hDdXN0b21FdmVudChldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kZXRhY2hDdXN0b21FdmVudChldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChuYW1lLCBkYXRhLCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlckN1c3RvbUV2ZW50KG5hbWUsIGRhdGEsIGVkaXRhYmxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxheTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgZWxlbWVudGlkLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudGlkID0gKHRoaXMuZWxlbWVudHNbaV0uaWQgIT09ICcnKSA/IHRoaXMuZWxlbWVudHNbaV0uaWQgOiAnZWxlbWVudC0nICsgaTtcbiAgICAgICAgICAgICAgICBjb250ZW50W2VsZW1lbnRpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmVsZW1lbnRzW2ldLmlubmVySFRNTC50cmltKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RXh0ZW5zaW9uQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbnMgJiYgdGhpcy5leHRlbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOT1QgRE9DVU1FTlRFRCAtIGV4cG9zZWQgYXMgYSBoZWxwZXIgZm9yIG90aGVyIGV4dGVuc2lvbnMgdG8gdXNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRCdWlsdEluRXh0ZW5zaW9uOiBmdW5jdGlvbiAobmFtZSwgb3B0cykge1xuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHRoaXMuZ2V0RXh0ZW5zaW9uQnlOYW1lKG5hbWUpLFxuICAgICAgICAgICAgICAgIG1lcmdlZDtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgICAgICBtZXJnZWQgPSBNZWRpdW1FZGl0b3IudXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucy5hbmNob3IsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuYW5jaG9yKG1lcmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvci1wcmV2aWV3JzpcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gbmV3IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmFuY2hvclByZXZpZXcodGhpcy5vcHRpb25zLmFuY2hvclByZXZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRvTGluayc6XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5hdXRvTGluaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxlRHJhZ2dpbmcnOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZmlsZURyYWdnaW5nKG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmb250bmFtZSc6XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb250TmFtZSh0aGlzLm9wdGlvbnMuZm9udE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmb250c2l6ZSc6XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb250U2l6ZShvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAna2V5Ym9hcmRDb21tYW5kcyc6XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5rZXlib2FyZENvbW1hbmRzKHRoaXMub3B0aW9ucy5rZXlib2FyZENvbW1hbmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGFzdGUnOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMucGFzdGUodGhpcy5vcHRpb25zLnBhc3RlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGxhY2Vob2xkZXInOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMucGxhY2Vob2xkZXIodGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG9mIHRoZSBidWlsdC1pbiBidXR0b25zIGZvciBNZWRpdW1FZGl0b3IgYXJlIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gY2hlY2sgdG8gc2VlIGlmIHRoZSBleHRlbnNpb24gd2UncmUgY3JlYXRpbmcgaXMgYSBidWlsdC1pbiBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbi5pc0J1aWx0SW5CdXR0b24obmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkID0gTWVkaXVtRWRpdG9yLnV0aWwuZGVmYXVsdHMoe30sIG9wdHMsIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbi5wcm90b3R5cGUuZGVmYXVsdHNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24obWVyZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gbmV3IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLnB1c2goaW5pdEV4dGVuc2lvbihleHRlbnNpb24sIG5hbWUsIHRoaXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wU2VsZWN0aW9uVXBkYXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50U2VsZWN0aW9uVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnRTZWxlY3Rpb25VcGRhdGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hlY2tTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b29sYmFyID0gdGhpcy5nZXRFeHRlbnNpb25CeU5hbWUoJ3Rvb2xiYXInKTtcbiAgICAgICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhci5jaGVja1N0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXcmFwcGVyIGFyb3VuZCBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBhY3Rpb24gaGFzIGFscmVhZHlcbiAgICAgICAgLy8gYmVlbiBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICBxdWVyeUNvbW1hbmRTdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgdmFyIGZ1bGxBY3Rpb24gPSAvXmZ1bGwtKC4rKSQvZ2ksXG4gICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgcXVlcnlTdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIEFjdGlvbnMgc3RhcnRpbmcgd2l0aCAnZnVsbC0nIG5lZWQgdG8gYmUgbW9kaWZpZWQgc2luY2UgdGhpcyBpcyBhIG1lZGl1bS1lZGl0b3IgY29uY2VwdFxuICAgICAgICAgICAgbWF0Y2ggPSBmdWxsQWN0aW9uLmV4ZWMoYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5U3RhdGUgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZShhY3Rpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBxdWVyeVN0YXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4ZWNBY3Rpb246IGZ1bmN0aW9uIChhY3Rpb24sIG9wdHMpIHtcbiAgICAgICAgICAgIC8qanNsaW50IHJlZ2V4cDogdHJ1ZSovXG4gICAgICAgICAgICB2YXIgZnVsbEFjdGlvbiA9IC9eZnVsbC0oLispJC9naSxcbiAgICAgICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAvKmpzbGludCByZWdleHA6IGZhbHNlKi9cblxuICAgICAgICAgICAgLy8gQWN0aW9ucyBzdGFydGluZyB3aXRoICdmdWxsLScgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdG8gdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgZWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgLy8gKGllIGZ1bGwtYm9sZCwgZnVsbC1hcHBlbmQtcHJlLCBldGMuKVxuICAgICAgICAgICAgbWF0Y2ggPSBmdWxsQWN0aW9uLmV4ZWMoYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byBiZSByZXN0b3JlZCBhZnRlciBhcHBseWluZyB0aGUgYWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IGFsbCBvZiB0aGUgY29udGVudHMgYmVmb3JlIGNhbGxpbmcgdGhlIGFjdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsQ29udGVudHMoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleGVjQWN0aW9uSW50ZXJuYWwuY2FsbCh0aGlzLCBtYXRjaFsxXSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4ZWNBY3Rpb25JbnRlcm5hbC5jYWxsKHRoaXMsIGFjdGlvbiwgb3B0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIHNvbWUgRE9NIGNsZWFuLXVwIGZvciBrbm93biBicm93c2VyIGlzc3VlcyBhZnRlciB0aGUgYWN0aW9uXG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnaW5zZXJ0dW5vcmRlcmVkbGlzdCcgfHwgYWN0aW9uID09PSAnaW5zZXJ0b3JkZXJlZGxpc3QnKSB7XG4gICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuY2xlYW5MaXN0RE9NKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LCB0aGlzLmdldFNlbGVjdGVkUGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jaGVja1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQ6IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQocmFuZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbGVjdEFsbENvbnRlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3Vyck5vZGUgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkVsZW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnRXaW5kb3cpO1xuXG4gICAgICAgICAgICBpZiAoY3Vyck5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBsb3dlc3QgZGVzY2VuZGFudCBub2RlIHRoYXQgc3RpbGwgc2VsZWN0cyBhbGwgb2YgdGhlIGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJOb2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyTm9kZSA9IGN1cnJOb2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudChjdXJyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsZWN0RWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uc2VsZWN0Tm9kZShlbGVtZW50LCB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgICAgIHZhciBzZWxFbGVtZW50ID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25FbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93KTtcbiAgICAgICAgICAgIGlmIChzZWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZm9jdXNFbGVtZW50KHNlbEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEZvY3VzZWRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm9jdXNlZDtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGVsZW1lbnQgdGhhdCBoYXMgZm9jdXNcbiAgICAgICAgICAgICAgICBpZiAoIWZvY3VzZWQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWVkaXVtLWZvY3VzZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBiYWlsIGlmIHdlIGZvdW5kIHRoZSBlbGVtZW50IHRoYXQgaGFkIGZvY3VzXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhZm9jdXNlZDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFeHBvcnQgdGhlIHN0YXRlIG9mIHRoZSBzZWxlY3Rpb24gaW4gcmVzcGVjdCB0byBvbmUgb2YgdGhpc1xuICAgICAgICAvLyBpbnN0YW5jZSBvZiBNZWRpdW1FZGl0b3IncyBlbGVtZW50c1xuICAgICAgICBleHBvcnRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbGVtZW50ID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25FbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93KSxcbiAgICAgICAgICAgICAgICBlZGl0YWJsZUVsZW1lbnRJbmRleCA9IHRoaXMuZWxlbWVudHMuaW5kZXhPZihzZWxlY3Rpb25FbGVtZW50KSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChlZGl0YWJsZUVsZW1lbnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhdGUgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmV4cG9ydFNlbGVjdGlvbihzZWxlY3Rpb25FbGVtZW50LCB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGF0ZSAhPT0gbnVsbCAmJiBlZGl0YWJsZUVsZW1lbnRJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLmVkaXRhYmxlRWxlbWVudEluZGV4ID0gZWRpdGFibGVFbGVtZW50SW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlID0gdGhpcy5leHBvcnRTZWxlY3Rpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZXN0b3JlIGEgc2VsZWN0aW9uIGJhc2VkIG9uIGEgc2VsZWN0aW9uU3RhdGUgcmV0dXJuZWQgYnkgYSBjYWxsXG4gICAgICAgIC8vIHRvIE1lZGl1bUVkaXRvci5leHBvcnRTZWxlY3Rpb25cbiAgICAgICAgaW1wb3J0U2VsZWN0aW9uOiBmdW5jdGlvbiAoc2VsZWN0aW9uU3RhdGUsIGZhdm9yTGF0ZXJTZWxlY3Rpb25BbmNob3IpIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlZGl0YWJsZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3NlbGVjdGlvblN0YXRlLmVkaXRhYmxlRWxlbWVudEluZGV4IHx8IDBdO1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5pbXBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uU3RhdGUsIGVkaXRhYmxlRWxlbWVudCwgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsIGZhdm9yTGF0ZXJTZWxlY3Rpb25BbmNob3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0U2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uU3RhdGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUxpbms6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEVkaXRvciA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uRWxlbWVudCh0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyksXG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQgPSB7fTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIGFuIGVsZW1lbnQgdGhpcyBlZGl0b3IgaXMgdHJhY2tpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmluZGV4T2YoY3VycmVudEVkaXRvcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc2FibGVDdXN0b21FdmVudCgnZWRpdGFibGVJbnB1dCcpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnVybCAmJiBvcHRzLnVybC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJSYW5nZSA9IGN1cnJlbnRTZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IGN1cnJSYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbnRhaW5lclBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyUGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgY29udGFpbmVkIHdpdGhpbiBhIHNpbmdsZSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgc2VsZWN0aW9uIHN0YXJ0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNU0lFIHN0aWxsIHNheXMgdGhlIHN0YXJ0Q29udGFpbmVyIGlzIHRoZSBwYXJlbnQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgY29udGFpbmVkIHdpdGhpbiBhIHNpbmdsZSB0ZXh0IG5vZGUsIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIGp1c3QgdXNlIHRoZSBkZWZhdWx0IGJyb3dzZXIgJ2NyZWF0ZUxpbmsnLCBzbyB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhY2NvdW50IGZvciB0aGlzIGNhc2UgYW5kIGFkanVzdCB0aGUgY29tbW9uQW5jZXN0b3JDb250YWluZXIgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyUmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlID09PSAzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSAzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclJhbmdlLnN0YXJ0T2Zmc2V0ID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclJhbmdlLnN0YXJ0Q29udGFpbmVyLmZpcnN0Q2hpbGQgPT09IGN1cnJSYW5nZS5lbmRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IGN1cnJSYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyUGFyZW50RWxlbWVudCA9IE1lZGl1bUVkaXRvci51dGlsLmdldENsb3Nlc3RCbG9ja0NvbnRhaW5lcihjdXJyUmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyUGFyZW50RWxlbWVudCA9IE1lZGl1bUVkaXRvci51dGlsLmdldENsb3Nlc3RCbG9ja0NvbnRhaW5lcihjdXJyUmFuZ2UuZW5kQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgY29udGFpbmVkIHdpdGhpbiBhIHNpbmdsZSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgc2VsZWN0aW9uIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHNhbWUgYmxvY2sgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgY3JlYXRlIGEgc2luZ2xlIGxpbmssIGFuZCBub3QgbXVsdGlwbGUgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGNhbiBoYXBwZW4gd2l0aCB0aGUgYnVpbHQgaW4gYnJvd3NlciBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbW9uQW5jZXN0b3JDb250YWluZXIubm9kZVR5cGUgIT09IDMgJiYgY29tbW9uQW5jZXN0b3JDb250YWluZXIudGV4dENvbnRlbnQubGVuZ3RoICE9PSAwICYmIHN0YXJ0Q29udGFpbmVyUGFyZW50RWxlbWVudCA9PT0gZW5kQ29udGFpbmVyUGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gKHN0YXJ0Q29udGFpbmVyUGFyZW50RWxlbWVudCB8fCBjdXJyZW50RWRpdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGEgbGluayBmcm9tIGFuIGV4dHJhY3RlZCB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHN1cmUgdGhhdCBpZiB3ZSBhcmUgdXBkYXRpbmcgYSBsaW5rLCB3ZSB3b24ndCBsZXQgYW4gZW1wdHkgbGluayBiZWhpbmQgKHNlZSAjNzU0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChXb3JrYXJvdW5nIGZvciBDaHJvbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjQWN0aW9uKCd1bmxpbmsnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkU2VsZWN0aW9uID0gdGhpcy5leHBvcnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChwYXJlbnRFbGVtZW50LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVkaXRvciA9PT0gcGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGF2b2lkIHRoZSBlZGl0b3IgaXRzZWxmIGJlaW5nIHdpcGVkIG91dCB3aGVuIGl0J3MgdGhlIG9ubHkgYmxvY2sgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgb3VyIHJlZmVyZW5jZSBpbnNpZGUgdGhpcy5lbGVtZW50cyBnZXRzIGRldGFjaGVkIGZyb20gdGhlIHBhZ2Ugd2hlbiBpbnNlcnRIVE1MIHJ1bnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGp1c3QgdXNlIFtwYXJlbnRFbGVtZW50LCAwXSBhbmQgW3BhcmVudEVsZW1lbnQsIHBhcmVudEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSByYW5nZSBib3VuZGFyaWVzLCB0aGlzIGhhcHBlbnMgd2hlbmV2ZXIgcGFyZW50RWxlbWVudCA9PT0gY3VycmVudEVkaXRvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYWRlb2ZmIHRvIHRoaXMgd29ya2Fyb3VuZCBpcyB0aGF0IGEgb3JwaGFuZWQgdGFnIGNhbiBzb21ldGltZXMgYmUgbGVmdCBiZWhpbmQgYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgZWRpdG9yJ3MgY29udGVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gR2Vja286XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIGFuIGVtcHR5IDxzdHJvbmc+PC9zdHJvbmc+IGlmIHBhcmVudEVsZW1lbnQubGFzdENoaWxkIGlzIGEgPHN0cm9uZz4gdGFnLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBXZWJLaXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIGludmVudGVkIDxiciAvPiB0YWcgYXQgdGhlIGVuZCBpbiB0aGUgc2FtZSBzaXR1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50Lmxhc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQubGFzdENoaWxkLm5vZGVUeXBlID09PSAzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQubGFzdENoaWxkLm5vZGVWYWx1ZS5sZW5ndGggOiBwYXJlbnRFbGVtZW50Lmxhc3RDaGlsZC5jaGlsZE5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkRXhwb3J0ZWRTZWxlY3Rpb24gPSB0aGlzLmV4cG9ydFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gTWVkaXVtRWRpdG9yLnV0aWwuZmluZE9yQ3JlYXRlTWF0Y2hpbmdUZXh0Tm9kZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGV4cG9ydGVkU2VsZWN0aW9uLnN0YXJ0IC0gbW9kaWZpZWRFeHBvcnRlZFNlbGVjdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZXhwb3J0ZWRTZWxlY3Rpb24uZW5kIC0gbW9kaWZpZWRFeHBvcnRlZFNlbGVjdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlRWxlbWVudEluZGV4OiBleHBvcnRlZFNlbGVjdGlvbi5lZGl0YWJsZUVsZW1lbnRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0ZXh0Tm9kZXMgYXJlIG5vdCBwcmVzZW50LCB3aGVuIGNoYW5naW5nIGxpbmsgb24gaW1hZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXg6IDxhPjxpbWcgc3JjPVwiaHR0cDovL2ltYWdlLnRlc3QuY29tXCI+PC9hPiwgY2hhbmdlIGZyYWdtZW50IHRvIGN1cnJSYW5nZS5zdGFydENvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzZXQgdGV4dE5vZGVzIGFycmF5IHRvIFtpbWFnZUVsZW1lbnQsIGltYWdlRWxlbWVudF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY29tbW9uQW5jZXN0b3JDb250YWluZXIuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gW2ZyYWdtZW50LmZpcnN0Q2hpbGQuZmlyc3RDaGlsZCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5sYXN0Q2hpbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZXMgdGhlIGxpbmsgaW4gdGhlIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuY3JlYXRlTGluayh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCwgdGV4dE5vZGVzLCBvcHRzLnVybC50cmltKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIHRyaW1zIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VzIHdoZW4gaW5zZXJ0aW5nIEhUTUwsIHdoaWNoIG1lc3NlcyB1cCByZXN0b3JpbmcgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2VzQ291bnQgPSAoZnJhZ21lbnQuZmlyc3RDaGlsZC5pbm5lckhUTUwubWF0Y2goL15cXHMrLykgfHwgWycnXSlbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm93IG1vdmUgdGhlIGNyZWF0ZWQgbGluayBiYWNrIGludG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50IGluIGEgd2F5IHRvIHByZXNlcnZlIHVuZG8vcmVkbyBoaXN0b3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuaW5zZXJ0SFRNTENvbW1hbmQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsIGZyYWdtZW50LmZpcnN0Q2hpbGQuaW5uZXJIVE1MLnJlcGxhY2UoL15cXHMrLywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFNlbGVjdGlvbi5zdGFydCAtPSBsZWFkaW5nV2hpdGVzcGFjZXNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFNlbGVjdGlvbi5lbmQgLT0gbGVhZGluZ1doaXRlc3BhY2VzQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFNlbGVjdGlvbihleHBvcnRlZFNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdjcmVhdGVMaW5rJywgZmFsc2UsIG9wdHMudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXRCbGFuayB8fCBvcHRzLnRhcmdldCA9PT0gJ19ibGFuaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5zZXRUYXJnZXRCbGFuayhNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvblN0YXJ0KHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50KSwgb3B0cy51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5yZW1vdmVUYXJnZXRCbGFuayhNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvblN0YXJ0KHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50KSwgb3B0cy51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5idXR0b25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmFkZENsYXNzVG9BbmNob3JzKE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLCBvcHRzLmJ1dHRvbkNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaXJlIGlucHV0IGV2ZW50IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBpZiBhbnlvbmUgd2FzIGxpc3RlbmluZyBkaXJlY3RseSB0byB0aGUgRE9NIGlucHV0IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXRCbGFuayB8fCBvcHRzLnRhcmdldCA9PT0gJ19ibGFuaycgfHwgb3B0cy5idXR0b25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21FdmVudCA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmluaXRFdmVudCgnaW5wdXQnLCB0cnVlLCB0cnVlLCB0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW5hYmxlQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlSW5wdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcmUgb3VyIGN1c3RvbSBlZGl0YWJsZUlucHV0IGV2ZW50XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlSW5wdXQnLCBjdXN0b21FdmVudCwgY3VycmVudEVkaXRvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYW5QYXN0ZTogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uQnlOYW1lKCdwYXN0ZScpLmNsZWFuUGFzdGUodGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFzdGVIVE1MOiBmdW5jdGlvbiAoaHRtbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb25CeU5hbWUoJ3Bhc3RlJykucGFzdGVIVE1MKGh0bWwsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChodG1sLCBpbmRleCkge1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5lbGVtZW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMudXBkYXRlSW5wdXQodGFyZ2V0LCB7IHRhcmdldDogdGFyZ2V0LCBjdXJyZW50VGFyZ2V0OiB0YXJnZXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzdW1tYXJ5OiBUaGUgZGVmYXVsdCBvcHRpb25zIGhhc2ggdXNlZCBieSB0aGUgRWRpdG9yXG5cbiAgICBNZWRpdW1FZGl0b3IucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICAgICAgICBhY3RpdmVCdXR0b25DbGFzczogJ21lZGl1bS1lZGl0b3ItYnV0dG9uLWFjdGl2ZScsXG4gICAgICAgIGJ1dHRvbkxhYmVsczogZmFsc2UsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBkaXNhYmxlUmV0dXJuOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZURvdWJsZVJldHVybjogZmFsc2UsXG4gICAgICAgIGRpc2FibGVFeHRyYVNwYWNlczogZmFsc2UsXG4gICAgICAgIGRpc2FibGVFZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgYXV0b0xpbms6IGZhbHNlLFxuICAgICAgICBlbGVtZW50c0NvbnRhaW5lcjogZmFsc2UsXG4gICAgICAgIGNvbnRlbnRXaW5kb3c6IHdpbmRvdyxcbiAgICAgICAgb3duZXJEb2N1bWVudDogZG9jdW1lbnQsXG4gICAgICAgIHRhcmdldEJsYW5rOiBmYWxzZSxcbiAgICAgICAgZXh0ZW5zaW9uczoge30sXG4gICAgICAgIHNwZWxsY2hlY2s6IHRydWVcbiAgICB9O1xufSkoKTtcblxuTWVkaXVtRWRpdG9yLnBhcnNlVmVyc2lvblN0cmluZyA9IGZ1bmN0aW9uIChyZWxlYXNlKSB7XG4gICAgdmFyIHNwbGl0ID0gcmVsZWFzZS5zcGxpdCgnLScpLFxuICAgICAgICB2ZXJzaW9uID0gc3BsaXRbMF0uc3BsaXQoJy4nKSxcbiAgICAgICAgcHJlUmVsZWFzZSA9IChzcGxpdC5sZW5ndGggPiAxKSA/IHNwbGl0WzFdIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFqb3I6IHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSxcbiAgICAgICAgbWlub3I6IHBhcnNlSW50KHZlcnNpb25bMV0sIDEwKSxcbiAgICAgICAgcmV2aXNpb246IHBhcnNlSW50KHZlcnNpb25bMl0sIDEwKSxcbiAgICAgICAgcHJlUmVsZWFzZTogcHJlUmVsZWFzZSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmVyc2lvblswXSwgdmVyc2lvblsxXSwgdmVyc2lvblsyXV0uam9pbignLicpICsgKHByZVJlbGVhc2UgPyAnLScgKyBwcmVSZWxlYXNlIDogJycpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbk1lZGl1bUVkaXRvci52ZXJzaW9uID0gTWVkaXVtRWRpdG9yLnBhcnNlVmVyc2lvblN0cmluZy5jYWxsKHRoaXMsICh7XG4gICAgLy8gZ3J1bnQtYnVtcCBsb29rcyBmb3IgdGhpczpcbiAgICAndmVyc2lvbic6ICc1LjE1LjAnXG59KS52ZXJzaW9uKTtcblxuICAgIHJldHVybiBNZWRpdW1FZGl0b3I7XG59KCkpKTtcbiIsIi8qKlxuICogQ2xhc3MgQXBwbGllciBtb2R1bGUgZm9yIFJhbmd5LlxuICogQWRkcywgcmVtb3ZlcyBhbmQgdG9nZ2xlcyBjbGFzc2VzIG9uIFJhbmdlcyBhbmQgU2VsZWN0aW9uc1xuICpcbiAqIFBhcnQgb2YgUmFuZ3ksIGEgY3Jvc3MtYnJvd3NlciBKYXZhU2NyaXB0IHJhbmdlIGFuZCBzZWxlY3Rpb24gbGlicmFyeVxuICogaHR0cHM6Ly9naXRodWIuY29tL3RpbWRvd24vcmFuZ3lcbiAqXG4gKiBEZXBlbmRzIG9uIFJhbmd5IGNvcmUuXG4gKlxuICogQ29weXJpZ2h0IDIwMTUsIFRpbSBEb3duXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBWZXJzaW9uOiAxLjMuMFxuICogQnVpbGQgZGF0ZTogMTAgTWF5IDIwMTVcbiAqL1xuKGZ1bmN0aW9uKGZhY3RvcnksIHJvb3QpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUgd2l0aCBhIGRlcGVuZGVuY3kgb24gUmFuZ3kuXG4gICAgICAgIGRlZmluZShbXCIuL3Jhbmd5LWNvcmVcIl0sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gTm9kZS9Db21tb25KUyBzdHlsZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoXCJyYW5neVwiKSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIEFNRCBvciBDb21tb25KUyBzdXBwb3J0IHNvIHdlIHVzZSB0aGUgcmFuZ3kgcHJvcGVydHkgb2Ygcm9vdCAocHJvYmFibHkgdGhlIGdsb2JhbCB2YXJpYWJsZSlcbiAgICAgICAgZmFjdG9yeShyb290LnJhbmd5KTtcbiAgICB9XG59KShmdW5jdGlvbihyYW5neSkge1xuICAgIHJhbmd5LmNyZWF0ZU1vZHVsZShcIkNsYXNzQXBwbGllclwiLCBbXCJXcmFwcGVkU2VsZWN0aW9uXCJdLCBmdW5jdGlvbihhcGksIG1vZHVsZSkge1xuICAgICAgICB2YXIgZG9tID0gYXBpLmRvbTtcbiAgICAgICAgdmFyIERvbVBvc2l0aW9uID0gZG9tLkRvbVBvc2l0aW9uO1xuICAgICAgICB2YXIgY29udGFpbnMgPSBkb20uYXJyYXlDb250YWlucztcbiAgICAgICAgdmFyIHV0aWwgPSBhcGkudXRpbDtcbiAgICAgICAgdmFyIGZvckVhY2ggPSB1dGlsLmZvckVhY2g7XG5cblxuICAgICAgICB2YXIgZGVmYXVsdFRhZ05hbWUgPSBcInNwYW5cIjtcbiAgICAgICAgdmFyIGNyZWF0ZUVsZW1lbnROU1N1cHBvcnRlZCA9IHV0aWwuaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImNyZWF0ZUVsZW1lbnROU1wiKTtcblxuICAgICAgICBmdW5jdGlvbiBlYWNoKG9iaiwgZnVuYykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jKGksIG9ialtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHNcXHMqLywgXCJcIikucmVwbGFjZSgvXFxzXFxzKiQvLCBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzTmFtZUNvbnRhaW5zQ2xhc3MoZnVsbENsYXNzTmFtZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gISFmdWxsQ2xhc3NOYW1lICYmIG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiICsgY2xhc3NOYW1lICsgXCIoPzpcXFxcc3wkKVwiKS50ZXN0KGZ1bGxDbGFzc05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5lZmZpY2llbnQsIGluZWxlZ2FudCBub25zZW5zZSBmb3IgSUUncyBzdmcgZWxlbWVudCwgd2hpY2ggaGFzIG5vIGNsYXNzTGlzdCBhbmQgbm9uLUhUTUwgY2xhc3NOYW1lIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVTdXBwb3J0ZWQgPSAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PSBcInN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgZWxDbGFzcyA9IGNsYXNzTmFtZVN1cHBvcnRlZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWVDb250YWluc0NsYXNzKGVsQ2xhc3MsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lU3VwcG9ydGVkID0gKHR5cGVvZiBlbC5jbGFzc05hbWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgdmFyIGVsQ2xhc3MgPSBjbGFzc05hbWVTdXBwb3J0ZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsYXNzTmFtZUNvbnRhaW5zQ2xhc3MoZWxDbGFzcywgY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxDbGFzcyArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsQ2xhc3MgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWVTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gZWxDbGFzcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBlbENsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtb3ZlQ2xhc3MgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXBsYWNlcihtYXRjaGVkLCB3aGl0ZVNwYWNlQmVmb3JlLCB3aGl0ZVNwYWNlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHdoaXRlU3BhY2VCZWZvcmUgJiYgd2hpdGVTcGFjZUFmdGVyKSA/IFwiIFwiIDogXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lU3VwcG9ydGVkID0gKHR5cGVvZiBlbC5jbGFzc05hbWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbENsYXNzID0gY2xhc3NOYW1lU3VwcG9ydGVkID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsQ2xhc3MgPSBlbENsYXNzLnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIiksIHJlcGxhY2VyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gZWxDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGVsQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZVN1cHBvcnRlZCA9ICh0eXBlb2YgZWwuY2xhc3NOYW1lID09IFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZVN1cHBvcnRlZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc29ydENsYXNzTmFtZShjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWUgJiYgY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuc29ydCgpLmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0U29ydGVkQ2xhc3NOYW1lKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydENsYXNzTmFtZSggZ2V0Q2xhc3MoZWwpICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYXZlU2FtZUNsYXNzZXMoZWwxLCBlbDIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTb3J0ZWRDbGFzc05hbWUoZWwxKSA9PSBnZXRTb3J0ZWRDbGFzc05hbWUoZWwyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhc0FsbENsYXNzZXMoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNDbGFzcyhlbCwgdHJpbShjbGFzc2VzW2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FuVGV4dEJlU3R5bGVkKHRleHROb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmICEvXih0ZXh0YXJlYXxzdHlsZXxzY3JpcHR8c2VsZWN0fGlmcmFtZSkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdmVQb3NpdGlvbihwb3NpdGlvbiwgb2xkUGFyZW50LCBvbGRJbmRleCwgbmV3UGFyZW50LCBuZXdJbmRleCkge1xuICAgICAgICAgICAgdmFyIHBvc05vZGUgPSBwb3NpdGlvbi5ub2RlLCBwb3NPZmZzZXQgPSBwb3NpdGlvbi5vZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHBvc05vZGUsIG5ld09mZnNldCA9IHBvc09mZnNldDtcblxuICAgICAgICAgICAgaWYgKHBvc05vZGUgPT0gbmV3UGFyZW50ICYmIHBvc09mZnNldCA+IG5ld0luZGV4KSB7XG4gICAgICAgICAgICAgICAgKytuZXdPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NOb2RlID09IG9sZFBhcmVudCAmJiAocG9zT2Zmc2V0ID09IG9sZEluZGV4ICB8fCBwb3NPZmZzZXQgPT0gb2xkSW5kZXggKyAxKSkge1xuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbmV3T2Zmc2V0ICs9IG5ld0luZGV4IC0gb2xkSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NOb2RlID09IG9sZFBhcmVudCAmJiBwb3NPZmZzZXQgPiBvbGRJbmRleCArIDEpIHtcbiAgICAgICAgICAgICAgICAtLW5ld09mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24ubm9kZSA9IG5ld05vZGU7XG4gICAgICAgICAgICBwb3NpdGlvbi5vZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3ZlUG9zaXRpb25XaGVuUmVtb3ZpbmdOb2RlKHBvc2l0aW9uLCBwYXJlbnROb2RlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uLm5vZGUgPT0gcGFyZW50Tm9kZSAmJiBwb3NpdGlvbi5vZmZzZXQgPiBpbmRleCkge1xuICAgICAgICAgICAgICAgIC0tcG9zaXRpb24ub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW92ZVByZXNlcnZpbmdQb3NpdGlvbnMobm9kZSwgbmV3UGFyZW50LCBuZXdJbmRleCwgcG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgLy8gRm9yIGNvbnZlbmllbmNlLCBhbGxvdyBuZXdJbmRleCB0byBiZSAtMSB0byBtZWFuIFwiaW5zZXJ0IGF0IHRoZSBlbmRcIi5cbiAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gbmV3UGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2xkUGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIG9sZEluZGV4ID0gZG9tLmdldE5vZGVJbmRleChub2RlKTtcblxuICAgICAgICAgICAgZm9yRWFjaChwb3NpdGlvbnNUb1ByZXNlcnZlLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbihwb3NpdGlvbiwgb2xkUGFyZW50LCBvbGRJbmRleCwgbmV3UGFyZW50LCBuZXdJbmRleCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTm93IGFjdHVhbGx5IG1vdmUgdGhlIG5vZGUuXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID09IG5ld0luZGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5ld1BhcmVudC5jaGlsZE5vZGVzW25ld0luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVQcmVzZXJ2aW5nUG9zaXRpb25zKG5vZGUsIHBvc2l0aW9uc1RvUHJlc2VydmUpIHtcblxuICAgICAgICAgICAgdmFyIG9sZFBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciBvbGRJbmRleCA9IGRvbS5nZXROb2RlSW5kZXgobm9kZSk7XG5cbiAgICAgICAgICAgIGZvckVhY2gocG9zaXRpb25zVG9QcmVzZXJ2ZSwgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBtb3ZlUG9zaXRpb25XaGVuUmVtb3ZpbmdOb2RlKHBvc2l0aW9uLCBvbGRQYXJlbnQsIG9sZEluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb20ucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdmVDaGlsZHJlblByZXNlcnZpbmdQb3NpdGlvbnMobm9kZSwgbmV3UGFyZW50LCBuZXdJbmRleCwgcmVtb3ZlTm9kZSwgcG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkLCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKCAoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQpICkge1xuICAgICAgICAgICAgICAgIG1vdmVQcmVzZXJ2aW5nUG9zaXRpb25zKGNoaWxkLCBuZXdQYXJlbnQsIG5ld0luZGV4KyssIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbW92ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVQcmVzZXJ2aW5nUG9zaXRpb25zKG5vZGUsIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZVdpdGhPd25DaGlsZHJlblByZXNlcnZpbmdQb3NpdGlvbnMoZWxlbWVudCwgcG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVDaGlsZHJlblByZXNlcnZpbmdQb3NpdGlvbnMoZWxlbWVudCwgZWxlbWVudC5wYXJlbnROb2RlLCBkb20uZ2V0Tm9kZUluZGV4KGVsZW1lbnQpLCB0cnVlLCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmdlU2VsZWN0c0FueVRleHQocmFuZ2UsIHRleHROb2RlKSB7XG4gICAgICAgICAgICB2YXIgdGV4dE5vZGVSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgIHRleHROb2RlUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRleHROb2RlKTtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvblJhbmdlID0gdGV4dE5vZGVSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBpbnRlcnNlY3Rpb25SYW5nZSA/IGludGVyc2VjdGlvblJhbmdlLnRvU3RyaW5nKCkgOiBcIlwiO1xuXG4gICAgICAgICAgICByZXR1cm4gdGV4dCAhPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RWZmZWN0aXZlVGV4dE5vZGVzKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSByYW5nZS5nZXROb2RlcyhbM10pO1xuXG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gYXMgcGVyIGlzc3VlIDE0NVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgbm9uLWludGVyc2VjdGluZyB0ZXh0IG5vZGVzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSByYW5nZVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMCwgbm9kZTtcbiAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSBub2Rlc1tzdGFydF0pICYmICFyYW5nZVNlbGVjdHNBbnlUZXh0KHJhbmdlLCBub2RlKSApIHtcbiAgICAgICAgICAgICAgICArK3N0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgbm9uLWludGVyc2VjdGluZyB0ZXh0IG5vZGVzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSByYW5nZVxuICAgICAgICAgICAgdmFyIGVuZCA9IG5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIChub2RlID0gbm9kZXNbZW5kXSkgJiYgIXJhbmdlU2VsZWN0c0FueVRleHQocmFuZ2UsIG5vZGUpICkge1xuICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZXMuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWxlbWVudHNIYXZlU2FtZU5vbkNsYXNzQXR0cmlidXRlcyhlbDEsIGVsMikge1xuICAgICAgICAgICAgaWYgKGVsMS5hdHRyaWJ1dGVzLmxlbmd0aCAhPSBlbDIuYXR0cmlidXRlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbDEuYXR0cmlidXRlcy5sZW5ndGgsIGF0dHIxLCBhdHRyMiwgbmFtZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgYXR0cjEgPSBlbDEuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYXR0cjEubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cjIgPSBlbDIuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKGF0dHIxID09PSBudWxsKSAhPSAoYXR0cjIgPT09IG51bGwpICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cjEuc3BlY2lmaWVkICE9IGF0dHIyLnNwZWNpZmllZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cjEuc3BlY2lmaWVkICYmIGF0dHIxLm5vZGVWYWx1ZSAhPT0gYXR0cjIubm9kZVZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbGVtZW50SGFzTm9uQ2xhc3NBdHRyaWJ1dGVzKGVsLCBleGNlcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWwuYXR0cmlidXRlcy5sZW5ndGgsIGF0dHJOYW1lOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IGVsLmF0dHJpYnV0ZXNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoICEoZXhjZXB0aW9ucyAmJiBjb250YWlucyhleGNlcHRpb25zLCBhdHRyTmFtZSkpICYmIGVsLmF0dHJpYnV0ZXNbaV0uc3BlY2lmaWVkICYmIGF0dHJOYW1lICE9IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5ID0gZG9tLmdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eTtcbiAgICAgICAgdmFyIGlzRWRpdGFibGVFbGVtZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRlc3RFbC5pc0NvbnRlbnRFZGl0YWJsZSA9PSBcImJvb2xlYW5cIiA/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuaXNDb250ZW50RWRpdGFibGU7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT0gMSB8fCBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJ0cnVlXCIgfHwgaXNFZGl0YWJsZUVsZW1lbnQobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzRWRpdGluZ0hvc3Qobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudDtcbiAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgICAgICgoIChwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUpICYmIHBhcmVudC5ub2RlVHlwZSA9PSA5ICYmIHBhcmVudC5kZXNpZ25Nb2RlID09IFwib25cIikgfHxcbiAgICAgICAgICAgICAgICAoaXNFZGl0YWJsZUVsZW1lbnQobm9kZSkgJiYgIWlzRWRpdGFibGVFbGVtZW50KG5vZGUucGFyZW50Tm9kZSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzRWRpdGFibGUobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc0VkaXRhYmxlRWxlbWVudChub2RlKSB8fCAobm9kZS5ub2RlVHlwZSAhPSAxICYmIGlzRWRpdGFibGVFbGVtZW50KG5vZGUucGFyZW50Tm9kZSkpKSAmJiAhaXNFZGl0aW5nSG9zdChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmxpbmVEaXNwbGF5UmVnZXggPSAvXmlubGluZSgtYmxvY2t8LXRhYmxlKT8kL2k7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNOb25JbmxpbmVFbGVtZW50KG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhaW5saW5lRGlzcGxheVJlZ2V4LnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5KG5vZGUsIFwiZGlzcGxheVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGl0ZSBzcGFjZSBjaGFyYWN0ZXJzIGFzIGRlZmluZWQgYnkgSFRNTCA0IChodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNDAxL3N0cnVjdC90ZXh0Lmh0bWwpXG4gICAgICAgIHZhciBodG1sTm9uV2hpdGVTcGFjZVJlZ2V4ID0gL1teXFxyXFxuXFx0XFxmIFxcdTIwMEJdLztcblxuICAgICAgICBmdW5jdGlvbiBpc1VucmVuZGVyZWRXaGl0ZVNwYWNlTm9kZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHRtbE5vbldoaXRlU3BhY2VSZWdleC50ZXN0KG5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3NzV2hpdGVTcGFjZSA9IGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eShub2RlLnBhcmVudE5vZGUsIFwid2hpdGVTcGFjZVwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY3NzV2hpdGVTcGFjZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJlLXdyYXBcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiLW1vei1wcmUtd3JhcFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FzZSBcInByZS1saW5lXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICgvW1xcclxcbl0vLnRlc3Qobm9kZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIG5vdyBoYXZlIGEgd2hpdGVzcGFjZS1vbmx5IHRleHQgbm9kZSB0aGF0IG1heSBiZSByZW5kZXJlZCBkZXBlbmRpbmcgb24gaXRzIGNvbnRleHQuIElmIGl0IGlzIGFkamFjZW50IHRvIGFcbiAgICAgICAgICAgIC8vIG5vbi1pbmxpbmUgZWxlbWVudCwgaXQgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFRoaXMgc2VlbXMgdG8gYmUgYSBnb29kIGVub3VnaCBkZWZpbml0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIGlzTm9uSW5saW5lRWxlbWVudChub2RlLnByZXZpb3VzU2libGluZykgfHwgaXNOb25JbmxpbmVFbGVtZW50KG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmFuZ2VCb3VuZGFyaWVzKHJhbmdlcykge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdLCBpLCByYW5nZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHJhbmdlID0gcmFuZ2VzW2krK107ICkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBuZXcgRG9tUG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IERvbVBvc2l0aW9uKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUmFuZ2VzRnJvbUJvdW5kYXJpZXMocmFuZ2VzLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByYW5nZSwgc3RhcnQsIGVuZCwgbGVuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwb3NpdGlvbnNbaSAqIDJdO1xuICAgICAgICAgICAgICAgIGVuZCA9IHBvc2l0aW9uc1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QW5kRW5kKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm5vZGUsIGVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNTcGxpdFBvaW50KG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIW5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09IG5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIW5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0ID4gMCAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3BsaXROb2RlQXQobm9kZSwgZGVzY2VuZGFudE5vZGUsIGRlc2NlbmRhbnRPZmZzZXQsIHBvc2l0aW9uc1RvUHJlc2VydmUpIHtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlLCBwYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIHNwbGl0QXRTdGFydCA9IChkZXNjZW5kYW50T2Zmc2V0ID09IDApO1xuXG4gICAgICAgICAgICBpZiAoZG9tLmlzQW5jZXN0b3JPZihkZXNjZW5kYW50Tm9kZSwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGRlc2NlbmRhbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjZW5kYW50SW5kZXggPSBkb20uZ2V0Tm9kZUluZGV4KGRlc2NlbmRhbnROb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY2VuZGFudE9mZnNldCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRPZmZzZXQgPSBkZXNjZW5kYW50SW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXNjZW5kYW50T2Zmc2V0ID09IGRlc2NlbmRhbnROb2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kYW50T2Zmc2V0ID0gZGVzY2VuZGFudEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBtb2R1bGUuY3JlYXRlRXJyb3IoXCJzcGxpdE5vZGVBdCgpIHNob3VsZCBub3QgYmUgY2FsbGVkIHdpdGggb2Zmc2V0IGluIHRoZSBtaWRkbGUgb2YgYSBkYXRhIG5vZGUgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRPZmZzZXQgKyBcIiBpbiBcIiArIGRlc2NlbmRhbnROb2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1NwbGl0UG9pbnQoZGVzY2VuZGFudE5vZGUsIGRlc2NlbmRhbnRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzY2VuZGFudE5vZGUgaXMgbm93IGd1YXJhbnRlZWQgbm90IHRvIGJlIGEgdGV4dCBvciBvdGhlciBjaGFyYWN0ZXIgbm9kZVxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBkZXNjZW5kYW50Tm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBkZXNjZW5kYW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCwgbmV3Q2hpbGRJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIChjaGlsZCA9IGRlc2NlbmRhbnROb2RlLmNoaWxkTm9kZXNbZGVzY2VuZGFudE9mZnNldF0pICkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlUHJlc2VydmluZ1Bvc2l0aW9ucyhjaGlsZCwgbmV3Tm9kZSwgbmV3Q2hpbGRJbmRleCsrLCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW92ZVByZXNlcnZpbmdQb3NpdGlvbnMobmV3Tm9kZSwgcGFyZW50Tm9kZSwgZG9tLmdldE5vZGVJbmRleChkZXNjZW5kYW50Tm9kZSkgKyAxLCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRlc2NlbmRhbnROb2RlID09IG5vZGUpID8gbmV3Tm9kZSA6IHNwbGl0Tm9kZUF0KG5vZGUsIHBhcmVudE5vZGUsIGRvbS5nZXROb2RlSW5kZXgobmV3Tm9kZSksIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlICE9IGRlc2NlbmRhbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IGRlc2NlbmRhbnROb2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBXb3JrIG91dCBhIG5ldyBzcGxpdCBwb2ludCBpbiB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZUluZGV4ID0gZG9tLmdldE5vZGVJbmRleChkZXNjZW5kYW50Tm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0QXRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0Tm9kZUF0KG5vZGUsIG5ld05vZGUsIG5ld05vZGVJbmRleCwgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFyZUVsZW1lbnRzTWVyZ2VhYmxlKGVsMSwgZWwyKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwxLm5hbWVzcGFjZVVSSSA9PSBlbDIubmFtZXNwYWNlVVJJICYmXG4gICAgICAgICAgICAgICAgZWwxLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBlbDIudGFnTmFtZS50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgaGF2ZVNhbWVDbGFzc2VzKGVsMSwgZWwyKSAmJlxuICAgICAgICAgICAgICAgIGVsZW1lbnRzSGF2ZVNhbWVOb25DbGFzc0F0dHJpYnV0ZXMoZWwxLCBlbDIpICYmXG4gICAgICAgICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5KGVsMSwgXCJkaXNwbGF5XCIpID09IFwiaW5saW5lXCIgJiZcbiAgICAgICAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlUHJvcGVydHkoZWwyLCBcImRpc3BsYXlcIikgPT0gXCJpbmxpbmVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGVHZXR0ZXIoZm9yd2FyZCkge1xuICAgICAgICAgICAgdmFyIHNpYmxpbmdQcm9wTmFtZSA9IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dE5vZGUsIGNoZWNrUGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgdmFyIGFkamFjZW50Tm9kZSA9IHRleHROb2RlW3NpYmxpbmdQcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW4gbWVyZ2UgaWYgdGhlIG5vZGUncyBwcmV2aW91cy9uZXh0IHNpYmxpbmcgaXMgYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSAmJiBhZGphY2VudE5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkamFjZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hlY2tQYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgdGV4dCBub2RlIHBhcmVudCBlbGVtZW50IHdpdGggaXRzIHNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnROb2RlID0gZWxbc2libGluZ1Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSAmJiBhZGphY2VudE5vZGUubm9kZVR5cGUgPT0gMSAmJiBhcmVFbGVtZW50c01lcmdlYWJsZShlbCwgYWRqYWNlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkamFjZW50Tm9kZUNoaWxkID0gYWRqYWNlbnROb2RlW2ZvcndhcmQgPyBcImZpcnN0Q2hpbGRcIiA6IFwibGFzdENoaWxkXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkamFjZW50Tm9kZUNoaWxkICYmIGFkamFjZW50Tm9kZUNoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRqYWNlbnROb2RlQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldFByZXZpb3VzTWVyZ2VhYmxlVGV4dE5vZGUgPSBjcmVhdGVBZGphY2VudE1lcmdlYWJsZVRleHROb2RlR2V0dGVyKGZhbHNlKSxcbiAgICAgICAgICAgIGdldE5leHRNZXJnZWFibGVUZXh0Tm9kZSA9IGNyZWF0ZUFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGVHZXR0ZXIodHJ1ZSk7XG5cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gTWVyZ2UoZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmlzRWxlbWVudE1lcmdlID0gKGZpcnN0Tm9kZS5ub2RlVHlwZSA9PSAxKTtcbiAgICAgICAgICAgIHRoaXMudGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB2YXIgZmlyc3RUZXh0Tm9kZSA9IHRoaXMuaXNFbGVtZW50TWVyZ2UgPyBmaXJzdE5vZGUubGFzdENoaWxkIDogZmlyc3ROb2RlO1xuICAgICAgICAgICAgaWYgKGZpcnN0VGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHROb2Rlc1swXSA9IGZpcnN0VGV4dE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBNZXJnZS5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBkb01lcmdlOiBmdW5jdGlvbihwb3NpdGlvbnNUb1ByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHROb2RlcyA9IHRoaXMudGV4dE5vZGVzO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFRleHROb2RlID0gdGV4dE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RUZXh0Tm9kZUluZGV4ID0gZG9tLmdldE5vZGVJbmRleChmaXJzdFRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRQYXJ0cyA9IFtdLCBjb21iaW5lZFRleHRMZW5ndGggPSAwLCB0ZXh0Tm9kZSwgcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKHRleHROb2RlcywgZnVuY3Rpb24odGV4dE5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlTm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKHBvc2l0aW9uc1RvUHJlc2VydmUsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhlIHRleHQgbm9kZSBiZWluZyBtZXJnZWQgaW50byBhIHByZWNlZGluZyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ubm9kZSA9PSB0ZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLm5vZGUgPSBmaXJzdFRleHROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLm9mZnNldCArPSBjb21iaW5lZFRleHRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBib3RoIHRleHQgbm9kZXMgcHJlY2VkZSB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSBzYW1lIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ubm9kZSA9PSBwYXJlbnQgJiYgcG9zaXRpb24ub2Zmc2V0ID4gZmlyc3RUZXh0Tm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1wb3NpdGlvbi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uLm9mZnNldCA9PSBmaXJzdFRleHROb2RlSW5kZXggKyAxICYmIGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLm5vZGUgPSBmaXJzdFRleHROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5vZmZzZXQgPSBjb21iaW5lZFRleHRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UGFydHNbaV0gPSB0ZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZWRUZXh0TGVuZ3RoICs9IHRleHROb2RlLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RUZXh0Tm9kZS5kYXRhID0gdGV4dFBhcnRzLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFRleHROb2RlLmRhdGE7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy50ZXh0Tm9kZXMubGVuZ3RoLCBsZW4gPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHRoaXMudGV4dE5vZGVzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yRWFjaCh0aGlzLnRleHROb2RlcywgZnVuY3Rpb24odGV4dE5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBhcnRzW2ldID0gXCInXCIgKyB0ZXh0Tm9kZS5kYXRhICsgXCInXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW01lcmdlKFwiICsgdGV4dFBhcnRzLmpvaW4oXCIsXCIpICsgXCIpXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvcHRpb25Qcm9wZXJ0aWVzID0gW1wiZWxlbWVudFRhZ05hbWVcIiwgXCJpZ25vcmVXaGl0ZVNwYWNlXCIsIFwiYXBwbHlUb0VkaXRhYmxlT25seVwiLCBcInVzZUV4aXN0aW5nRWxlbWVudHNcIixcbiAgICAgICAgICAgIFwicmVtb3ZlRW1wdHlFbGVtZW50c1wiLCBcIm9uRWxlbWVudENyZWF0ZVwiXTtcblxuICAgICAgICAvLyBUT0RPOiBQb3B1bGF0ZSB0aGlzIHdpdGggZXZlcnkgYXR0cmlidXRlIG5hbWUgdGhhdCBjb3JyZXNwb25kcyB0byBhIHByb3BlcnR5IHdpdGggYSBkaWZmZXJlbnQgbmFtZS4gUmVhbGx5Pz9cbiAgICAgICAgdmFyIGF0dHJOYW1lc0ZvclByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBDbGFzc0FwcGxpZXIoY2xhc3NOYW1lLCBvcHRpb25zLCB0YWdOYW1lcykge1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZSwgaSwgbGVuLCBwcm9wTmFtZSwgYXBwbGllciA9IHRoaXM7XG4gICAgICAgICAgICBhcHBsaWVyLmNzc0NsYXNzID0gYXBwbGllci5jbGFzc05hbWUgPSBjbGFzc05hbWU7IC8vIGNzc0NsYXNzIHByb3BlcnR5IGlzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50UHJvcGVydGllc0Zyb21PcHRpb25zID0gbnVsbCwgZWxlbWVudEF0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBmcm9tIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVsZW1lbnRUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZWxlbWVudFRhZ05hbWUgPSBvcHRpb25zLmVsZW1lbnRUYWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ05hbWVzID0gb3B0aW9ucy50YWdOYW1lcztcbiAgICAgICAgICAgICAgICBlbGVtZW50UHJvcGVydGllc0Zyb21PcHRpb25zID0gb3B0aW9ucy5lbGVtZW50UHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBlbGVtZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuZWxlbWVudEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBwcm9wTmFtZSA9IG9wdGlvblByb3BlcnRpZXNbaSsrXTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllcltwcm9wTmFtZV0gPSBvcHRpb25zW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3JtYWxpemUgPSBvcHRpb25zLm5vcm1hbGl6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplID0gb3B0aW9ucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogdGhlIHNlY29uZCBwYXJhbWV0ZXIgY2FuIGFsc28gYmUgYSBCb29sZWFuIGluZGljYXRpbmcgdG8gbm9ybWFsaXplIGFmdGVyIHVuYXBwbHlpbmdcbiAgICAgICAgICAgIGFwcGxpZXIubm9ybWFsaXplID0gKHR5cGVvZiBub3JtYWxpemUgPT0gXCJ1bmRlZmluZWRcIikgPyB0cnVlIDogbm9ybWFsaXplO1xuXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGVsZW1lbnQgcHJvcGVydGllcyBhbmQgYXR0cmlidXRlIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgIGFwcGxpZXIuYXR0ckV4Y2VwdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYXBwbGllci5lbGVtZW50VGFnTmFtZSk7XG4gICAgICAgICAgICBhcHBsaWVyLmVsZW1lbnRQcm9wZXJ0aWVzID0gYXBwbGllci5jb3B5UHJvcGVydGllc1RvRWxlbWVudChlbGVtZW50UHJvcGVydGllc0Zyb21PcHRpb25zLCBlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBlYWNoKGVsZW1lbnRBdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyTmFtZSwgYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXBwbGllci5hdHRyRXhjZXB0aW9ucy5wdXNoKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgZWFjaCBhdHRyaWJ1dGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBlbGVtZW50QXR0cmlidXRlc1thdHRyTmFtZV0gPSBcIlwiICsgYXR0clZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcHBsaWVyLmVsZW1lbnRBdHRyaWJ1dGVzID0gZWxlbWVudEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIGFwcGxpZXIuZWxlbWVudFNvcnRlZENsYXNzTmFtZSA9IGFwcGxpZXIuZWxlbWVudFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXCJjbGFzc05hbWVcIikgP1xuICAgICAgICAgICAgICAgIHNvcnRDbGFzc05hbWUoYXBwbGllci5lbGVtZW50UHJvcGVydGllcy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZSkgOiBjbGFzc05hbWU7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGFnIG5hbWVzXG4gICAgICAgICAgICBhcHBsaWVyLmFwcGx5VG9BbnlUYWdOYW1lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB0YWdOYW1lcztcbiAgICAgICAgICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnTmFtZXMgPT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllci5hcHBseVRvQW55VGFnTmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllci50YWdOYW1lcyA9IHRyaW0odGFnTmFtZXMudG9Mb3dlckNhc2UoKSkuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB0YWdOYW1lcy5sZW5ndGggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGFwcGxpZXIudGFnTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0YWdOYW1lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZXNbaV0gPT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZXIuYXBwbHlUb0FueVRhZ05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllci50YWdOYW1lcy5wdXNoKHRhZ05hbWVzW2ldLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBsaWVyLnRhZ05hbWVzID0gW2FwcGxpZXIuZWxlbWVudFRhZ05hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQ2xhc3NBcHBsaWVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGVsZW1lbnRUYWdOYW1lOiBkZWZhdWx0VGFnTmFtZSxcbiAgICAgICAgICAgIGVsZW1lbnRQcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgIGVsZW1lbnRBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgIGlnbm9yZVdoaXRlU3BhY2U6IHRydWUsXG4gICAgICAgICAgICBhcHBseVRvRWRpdGFibGVPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nRWxlbWVudHM6IHRydWUsXG4gICAgICAgICAgICByZW1vdmVFbXB0eUVsZW1lbnRzOiB0cnVlLFxuICAgICAgICAgICAgb25FbGVtZW50Q3JlYXRlOiBudWxsLFxuXG4gICAgICAgICAgICBjb3B5UHJvcGVydGllc1RvRWxlbWVudDogZnVuY3Rpb24ocHJvcHMsIGVsLCBjcmVhdGVDb3B5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHMsIGVsU3R5bGUsIGVsUHJvcHMgPSB7fSwgZWxQcm9wc1N0eWxlLCBwcm9wVmFsdWUsIGVsUHJvcFZhbHVlLCBhdHRyTmFtZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBwcm9wc1twXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUHJvcFZhbHVlID0gZWxbcF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgY2xhc3MuIFRoZSBjb3BpZWQgcHJvcGVydGllcyBvYmplY3QgaGFzIHRoZSBhcHBsaWVyJ3MgY2xhc3MgYXMgd2VsbCBhcyBpdHMgb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBzaW1wbGlmeSBjaGVja3Mgd2hlbiByZW1vdmluZyBzdHlsaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA9PSBcImNsYXNzTmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWwsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWwsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFtwXSA9IHNvcnRDbGFzc05hbWUoZWxbcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGVDb3B5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUHJvcHNbcF0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwID09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsU3R5bGUgPSBlbFByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlQ29weSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFByb3BzW3BdID0gZWxQcm9wc1N0eWxlID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocyBpbiBwcm9wc1twXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHNbcF0uaGFzT3duUHJvcGVydHkocykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsU3R5bGVbc10gPSBwcm9wVmFsdWVbc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlQ29weSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUHJvcHNTdHlsZVtzXSA9IGVsU3R5bGVbc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyRXhjZXB0aW9ucy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFtwXSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBwcm9wZXJ0eSBiYWNrIGZyb20gdGhlIGR1bW15IGVsZW1lbnQgc28gdGhhdCBsYXRlciBjb21wYXJpc29ucyB0byBjaGVjayB3aGV0aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgbWF5IGJlIHJlbW92ZWQgYXJlIGNoZWNraW5nIGFnYWluc3QgdGhlIHJpZ2h0IHZhbHVlLiBGb3IgZXhhbXBsZSwgdGhlIGhyZWYgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBhbiBlbGVtZW50IHJldHVybnMgYSBmdWxseSBxdWFsaWZpZWQgVVJMIGV2ZW4gaWYgaXQgd2FzIHByZXZpb3VzbHkgYXNzaWduZWQgYSByZWxhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVSTC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlQ29weSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFByb3BzW3BdID0gZWxbcF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFsbCBwcm9wZXJ0aWVzIG1hcCB0byBpZGVudGljYWxseS1uYW1lZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWVzRm9yUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwKSA/IGF0dHJOYW1lc0ZvclByb3BlcnRpZXNbcF0gOiBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJFeGNlcHRpb25zLnB1c2goYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3B5ID8gZWxQcm9wcyA6IFwiXCI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb3B5QXR0cmlidXRlc1RvRWxlbWVudDogZnVuY3Rpb24oYXR0cnMsIGVsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHJOYW1lKSAmJiAhL15jbGFzcyg/Ok5hbWUpPyQvaS50ZXN0KGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1thdHRyTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXBwbGllc1RvRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnModGhpcy50YWdOYW1lcywgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEVtcHR5RWxlbWVudHM6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwcGxpZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZS5nZXROb2RlcyhbMV0sIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBsaWVyLmFwcGxpZXNUb0VsZW1lbnQoZWwpICYmICFlbC5oYXNDaGlsZE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuYXBwbHlUb0FueVRhZ05hbWUgfHwgdGhpcy5hcHBsaWVzVG9FbGVtZW50KG5vZGUpKSAmJlxuICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyhub2RlLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRTZWxmT3JBbmNlc3RvcldpdGhDbGFzczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0NsYXNzKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzTW9kaWZpYWJsZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5hcHBseVRvRWRpdGFibGVPbmx5IHx8IGlzRWRpdGFibGUobm9kZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBXaGl0ZSBzcGFjZSBhZGphY2VudCB0byBhbiB1bndyYXBwYWJsZSBub2RlIGNhbiBiZSBpZ25vcmVkIGZvciB3cmFwcGluZ1xuICAgICAgICAgICAgaXNJZ25vcmFibGVXaGl0ZVNwYWNlTm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlnbm9yZVdoaXRlU3BhY2UgJiYgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDMgJiYgaXNVbnJlbmRlcmVkV2hpdGVTcGFjZU5vZGUobm9kZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemVzIG5vZGVzIGFmdGVyIGFwcGx5aW5nIGEgY2xhc3MgdG8gYSBSYW5nZS5cbiAgICAgICAgICAgIHBvc3RBcHBseTogZnVuY3Rpb24odGV4dE5vZGVzLCByYW5nZSwgcG9zaXRpb25zVG9QcmVzZXJ2ZSwgaXNVbmRvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXSwgbGFzdE5vZGUgPSB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1lcmdlcyA9IFtdLCBjdXJyZW50TWVyZ2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VTdGFydE5vZGUgPSBmaXJzdE5vZGUsIHJhbmdlRW5kTm9kZSA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZVN0YXJ0T2Zmc2V0ID0gMCwgcmFuZ2VFbmRPZmZzZXQgPSBsYXN0Tm9kZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUsIHByZWNlZGluZ1RleHROb2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGV2ZXJ5IHJlcXVpcmVkIG1lcmdlIGFuZCBjcmVhdGUgYSBNZXJnZSBvYmplY3QgZm9yIGVhY2hcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHRleHROb2RlcywgZnVuY3Rpb24odGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkaW5nVGV4dE5vZGUgPSBnZXRQcmV2aW91c01lcmdlYWJsZVRleHROb2RlKHRleHROb2RlLCAhaXNVbmRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWNlZGluZ1RleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRNZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNZXJnZSA9IG5ldyBNZXJnZShwcmVjZWRpbmdUZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VzLnB1c2goY3VycmVudE1lcmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXMucHVzaCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUgPT09IGZpcnN0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlU3RhcnROb2RlID0gY3VycmVudE1lcmdlLnRleHROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVN0YXJ0T2Zmc2V0ID0gcmFuZ2VTdGFydE5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHROb2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlRW5kTm9kZSA9IGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VFbmRPZmZzZXQgPSBjdXJyZW50TWVyZ2UuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWVyZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIHJhbmdlIG5lZWRzIG1lcmdpbmdcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFRleHROb2RlID0gZ2V0TmV4dE1lcmdlYWJsZVRleHROb2RlKGxhc3ROb2RlLCAhaXNVbmRvKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0VGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TWVyZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNZXJnZSA9IG5ldyBNZXJnZShsYXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZXMucHVzaChjdXJyZW50TWVyZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXMucHVzaChuZXh0VGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBtZXJnZXNcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBtZXJnZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlc1tpXS5kb01lcmdlKHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSByYW5nZSBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QW5kRW5kKHJhbmdlU3RhcnROb2RlLCByYW5nZVN0YXJ0T2Zmc2V0LCByYW5nZUVuZE5vZGUsIHJhbmdlRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gY3JlYXRlRWxlbWVudE5TU3VwcG9ydGVkICYmICFkb20uaXNIdG1sTmFtZXNwYWNlKHBhcmVudE5vZGUpICYmIChuYW1lc3BhY2UgPSBwYXJlbnROb2RlLm5hbWVzcGFjZVVSSSkgP1xuICAgICAgICAgICAgICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKHBhcmVudE5vZGUubmFtZXNwYWNlVVJJLCB0aGlzLmVsZW1lbnRUYWdOYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KHRoaXMuZWxlbWVudFRhZ05hbWUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5UHJvcGVydGllc1RvRWxlbWVudCh0aGlzLmVsZW1lbnRQcm9wZXJ0aWVzLCBlbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29weUF0dHJpYnV0ZXNUb0VsZW1lbnQodGhpcy5lbGVtZW50QXR0cmlidXRlcywgZWwpO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25FbGVtZW50Q3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FbGVtZW50Q3JlYXRlKGVsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZWxlbWVudEhhc1Byb3BlcnRpZXM6IGZ1bmN0aW9uKGVsLCBwcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciBhcHBsaWVyID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFjaChwcm9wcywgZnVuY3Rpb24ocCwgcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09IFwiY2xhc3NOYW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBjaGVja2luZyB3aGV0aGVyIHdlIHNob3VsZCByZXVzZSBhbiBleGlzdGluZyBlbGVtZW50LCB3ZSBqdXN0IHdhbnQgdG8gY2hlY2sgdGhhdCB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGFsbCB0aGUgY2xhc3NlcyBzcGVjaWZpZWQgaW4gdGhlIGNsYXNzTmFtZSBwcm9wZXJ0eS4gV2hlbiBkZWNpZGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmFibGUgd2hlbiB1bmFwcGx5aW5nIGEgY2xhc3MsIHRoZXJlIGlzIHNlcGFyYXRlIHNwZWNpYWwgaGFuZGxpbmcgdG8gY2hlY2sgd2hldGhlciB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaGFzIGV4dHJhIGNsYXNzZXMgc28gdGhlIHNhbWUgc2ltcGxlIGNoZWNrIHdpbGwgZG8uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzQWxsQ2xhc3NlcyhlbCwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcFZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXBwbGllci5lbGVtZW50SGFzUHJvcGVydGllcyhlbFtwXSwgcHJvcFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbFtwXSAhPT0gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVsZW1lbnRIYXNBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbCwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFjaChhdHRycywgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShuYW1lKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXBwbHlUb1RleHROb2RlOiBmdW5jdGlvbih0ZXh0Tm9kZSwgcG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgdGV4dCBub2RlIGNhbiBiZSBzdHlsZWQuIFRleHQgd2l0aGluIGEgPHN0eWxlPiBvciA8c2NyaXB0PiBlbGVtZW50LCBmb3IgZXhhbXBsZSxcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IGJlIHN0eWxlZC4gU2VlIGlzc3VlIDI4My5cbiAgICAgICAgICAgICAgICBpZiAoY2FuVGV4dEJlU3R5bGVkKHRleHROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZUV4aXN0aW5nRWxlbWVudHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbGllc1RvRWxlbWVudChwYXJlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRIYXNQcm9wZXJ0aWVzKHBhcmVudCwgdGhpcy5lbGVtZW50UHJvcGVydGllcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhc0F0dHJpYnV0ZXMocGFyZW50LCB0aGlzLmVsZW1lbnRBdHRyaWJ1dGVzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhwYXJlbnQsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZVBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcih0ZXh0Tm9kZVBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZVBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNSZW1vdmFibGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSB0aGlzLmVsZW1lbnRUYWdOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIGdldFNvcnRlZENsYXNzTmFtZShlbCkgPT0gdGhpcy5lbGVtZW50U29ydGVkQ2xhc3NOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhc1Byb3BlcnRpZXMoZWwsIHRoaXMuZWxlbWVudFByb3BlcnRpZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICFlbGVtZW50SGFzTm9uQ2xhc3NBdHRyaWJ1dGVzKGVsLCB0aGlzLmF0dHJFeGNlcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRIYXNBdHRyaWJ1dGVzKGVsLCB0aGlzLmVsZW1lbnRBdHRyaWJ1dGVzKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTW9kaWZpYWJsZShlbCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0VtcHR5Q29udGFpbmVyOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVDb3VudCA9IGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNSZW1vdmFibGUoZWwpICYmXG4gICAgICAgICAgICAgICAgICAgIChjaGlsZE5vZGVDb3VudCA9PSAwIHx8IChjaGlsZE5vZGVDb3VudCA9PSAxICYmIHRoaXMuaXNFbXB0eUNvbnRhaW5lcihlbC5maXJzdENoaWxkKSkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVtb3ZlRW1wdHlDb250YWluZXJzOiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcHBsaWVyID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXNUb1JlbW92ZSA9IHJhbmdlLmdldE5vZGVzKFsxXSwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcGxpZXIuaXNFbXB0eUNvbnRhaW5lcihlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzVG9QcmVzZXJ2ZSA9IFtyYW5nZV07XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uc1RvUHJlc2VydmUgPSBnZXRSYW5nZUJvdW5kYXJpZXMocmFuZ2VzVG9QcmVzZXJ2ZSk7XG5cbiAgICAgICAgICAgICAgICBmb3JFYWNoKG5vZGVzVG9SZW1vdmUsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUHJlc2VydmluZ1Bvc2l0aW9ucyhub2RlLCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmFuZ2UgZnJvbSB0aGUgcHJlc2VydmVkIGJvdW5kYXJ5IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlc0Zyb21Cb3VuZGFyaWVzKHJhbmdlc1RvUHJlc2VydmUsIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdW5kb1RvVGV4dE5vZGU6IGZ1bmN0aW9uKHRleHROb2RlLCByYW5nZSwgYW5jZXN0b3JXaXRoQ2xhc3MsIHBvc2l0aW9uc1RvUHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmNvbnRhaW5zTm9kZShhbmNlc3RvcldpdGhDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBwb3J0aW9uIG9mIHRoZSBhbmNlc3RvciBmcm9tIHdoaWNoIHdlIGNhbiByZW1vdmUgdGhlIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIHBhcmVudCA9IGFuY2VzdG9yV2l0aENsYXNzLnBhcmVudE5vZGUsIGluZGV4ID0gZG9tLmdldE5vZGVJbmRleChhbmNlc3RvcldpdGhDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNlc3RvclJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBhbmNlc3RvclJhbmdlLnNlbGVjdE5vZGUoYW5jZXN0b3JXaXRoQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3JSYW5nZS5pc1BvaW50SW5SYW5nZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0Tm9kZUF0KGFuY2VzdG9yV2l0aENsYXNzLCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihhbmNlc3RvcldpdGhDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuY2VzdG9yUmFuZ2UuaXNQb2ludEluUmFuZ2UocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JXaXRoQ2xhc3MgPSBzcGxpdE5vZGVBdChhbmNlc3RvcldpdGhDbGFzcywgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3ZhYmxlKGFuY2VzdG9yV2l0aENsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlV2l0aE93bkNoaWxkcmVuUHJlc2VydmluZ1Bvc2l0aW9ucyhhbmNlc3RvcldpdGhDbGFzcywgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoYW5jZXN0b3JXaXRoQ2xhc3MsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzcGxpdEFuY2VzdG9yV2l0aENsYXNzOiBmdW5jdGlvbihjb250YWluZXIsIG9mZnNldCwgcG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhbmNlc3RvcldpdGhDbGFzcyA9IHRoaXMuZ2V0U2VsZk9yQW5jZXN0b3JXaXRoQ2xhc3MoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3JXaXRoQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXROb2RlQXQoYW5jZXN0b3JXaXRoQ2xhc3MsIGNvbnRhaW5lciwgb2Zmc2V0LCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bmRvVG9BbmNlc3RvcjogZnVuY3Rpb24oYW5jZXN0b3JXaXRoQ2xhc3MsIHBvc2l0aW9uc1RvUHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JlbW92YWJsZShhbmNlc3RvcldpdGhDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVdpdGhPd25DaGlsZHJlblByZXNlcnZpbmdQb3NpdGlvbnMoYW5jZXN0b3JXaXRoQ2xhc3MsIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGFuY2VzdG9yV2l0aENsYXNzLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXBwbHlUb1JhbmdlOiBmdW5jdGlvbihyYW5nZSwgcmFuZ2VzVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcHBsaWVyID0gdGhpcztcbiAgICAgICAgICAgICAgICByYW5nZXNUb1ByZXNlcnZlID0gcmFuZ2VzVG9QcmVzZXJ2ZSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiByYW5nZSBib3VuZGFyaWVzIHRvIHByZXNlcnZlXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uc1RvUHJlc2VydmUgPSBnZXRSYW5nZUJvdW5kYXJpZXMocmFuZ2VzVG9QcmVzZXJ2ZSB8fCBbXSk7XG5cbiAgICAgICAgICAgICAgICByYW5nZS5zcGxpdEJvdW5kYXJpZXNQcmVzZXJ2aW5nUG9zaXRpb25zKHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGlkeSB1cCB0aGUgRE9NIGJ5IHJlbW92aW5nIGVtcHR5IGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGllci5yZW1vdmVFbXB0eUVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZXIucmVtb3ZlRW1wdHlDb250YWluZXJzKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGVzID0gZ2V0RWZmZWN0aXZlVGV4dE5vZGVzKHJhbmdlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2godGV4dE5vZGVzLCBmdW5jdGlvbih0ZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcHBsaWVyLmlzSWdub3JhYmxlV2hpdGVTcGFjZU5vZGUodGV4dE5vZGUpICYmICFhcHBsaWVyLmdldFNlbGZPckFuY2VzdG9yV2l0aENsYXNzKHRleHROb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVyLmlzTW9kaWZpYWJsZSh0ZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVyLmFwcGx5VG9UZXh0Tm9kZSh0ZXh0Tm9kZSwgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBbmRFbmQodGV4dE5vZGVzWzBdLCAwLCBsYXN0VGV4dE5vZGUsIGxhc3RUZXh0Tm9kZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwbGllci5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZXIucG9zdEFwcGx5KHRleHROb2RlcywgcmFuZ2UsIHBvc2l0aW9uc1RvUHJlc2VydmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmFuZ2VzIGZyb20gdGhlIHByZXNlcnZlZCBib3VuZGFyeSBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VzRnJvbUJvdW5kYXJpZXMocmFuZ2VzVG9QcmVzZXJ2ZSwgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY2xhc3NlcyB0byBhbnkgYXBwcm9wcmlhdGUgZW1wdHkgZWxlbWVudHNcbiAgICAgICAgICAgICAgICB2YXIgZW1wdHlFbGVtZW50cyA9IGFwcGxpZXIuZ2V0RW1wdHlFbGVtZW50cyhyYW5nZSk7XG5cbiAgICAgICAgICAgICAgICBmb3JFYWNoKGVtcHR5RWxlbWVudHMsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsLCBhcHBsaWVyLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhcHBseVRvUmFuZ2VzOiBmdW5jdGlvbihyYW5nZXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBpID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUb1JhbmdlKHJhbmdlc1tpXSwgcmFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhcHBseVRvU2VsZWN0aW9uOiBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsID0gYXBpLmdldFNlbGVjdGlvbih3aW4pO1xuICAgICAgICAgICAgICAgIHNlbC5zZXRSYW5nZXMoIHRoaXMuYXBwbHlUb1JhbmdlcyhzZWwuZ2V0QWxsUmFuZ2VzKCkpICk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bmRvVG9SYW5nZTogZnVuY3Rpb24ocmFuZ2UsIHJhbmdlc1RvUHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwbGllciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIHJhbmdlIGJvdW5kYXJpZXMgdG8gcHJlc2VydmVcbiAgICAgICAgICAgICAgICByYW5nZXNUb1ByZXNlcnZlID0gcmFuZ2VzVG9QcmVzZXJ2ZSB8fCBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zVG9QcmVzZXJ2ZSA9IGdldFJhbmdlQm91bmRhcmllcyhyYW5nZXNUb1ByZXNlcnZlKTtcblxuXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3BsaXRCb3VuZGFyaWVzUHJlc2VydmluZ1Bvc2l0aW9ucyhwb3NpdGlvbnNUb1ByZXNlcnZlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRpZHkgdXAgdGhlIERPTSBieSByZW1vdmluZyBlbXB0eSBjb250YWluZXJzXG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpZXIucmVtb3ZlRW1wdHlFbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVyLnJlbW92ZUVtcHR5Q29udGFpbmVycyhyYW5nZSwgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRleHROb2RlcyA9IGdldEVmZmVjdGl2ZVRleHROb2RlcyhyYW5nZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHROb2RlLCBhbmNlc3RvcldpdGhDbGFzcztcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZXIuc3BsaXRBbmNlc3RvcldpdGhDbGFzcyhyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZXIuc3BsaXRBbmNlc3RvcldpdGhDbGFzcyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yV2l0aENsYXNzID0gYXBwbGllci5nZXRTZWxmT3JBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3JXaXRoQ2xhc3MgJiYgYXBwbGllci5pc01vZGlmaWFibGUodGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllci51bmRvVG9BbmNlc3RvcihhbmNlc3RvcldpdGhDbGFzcywgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSByYW5nZSBpcyBzdGlsbCB2YWxpZFxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFuZEVuZCh0ZXh0Tm9kZXNbMF0sIDAsIGxhc3RUZXh0Tm9kZSwgbGFzdFRleHROb2RlLmxlbmd0aCk7XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwbGllci5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZXIucG9zdEFwcGx5KHRleHROb2RlcywgcmFuZ2UsIHBvc2l0aW9uc1RvUHJlc2VydmUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByYW5nZXMgZnJvbSB0aGUgcHJlc2VydmVkIGJvdW5kYXJ5IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZXNGcm9tQm91bmRhcmllcyhyYW5nZXNUb1ByZXNlcnZlLCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY2xhc3MgZnJvbSBhbnkgYXBwcm9wcmlhdGUgZW1wdHkgZWxlbWVudHNcbiAgICAgICAgICAgICAgICB2YXIgZW1wdHlFbGVtZW50cyA9IGFwcGxpZXIuZ2V0RW1wdHlFbGVtZW50cyhyYW5nZSk7XG5cbiAgICAgICAgICAgICAgICBmb3JFYWNoKGVtcHR5RWxlbWVudHMsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBhcHBsaWVyLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bmRvVG9SYW5nZXM6IGZ1bmN0aW9uKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIC8vIEdldCByYW5nZXMgcmV0dXJuZWQgaW4gZG9jdW1lbnQgb3JkZXJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHJhbmdlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5kb1RvUmFuZ2UocmFuZ2VzW2ldLCByYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bmRvVG9TZWxlY3Rpb246IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWwgPSBhcGkuZ2V0U2VsZWN0aW9uKHdpbik7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlcyA9IGFwaS5nZXRTZWxlY3Rpb24od2luKS5nZXRBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZG9Ub1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgIHNlbC5zZXRSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzQXBwbGllZFRvUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCB8fCByYW5nZS50b1N0cmluZygpID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRTZWxmT3JBbmNlc3RvcldpdGhDbGFzcyhyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKCBbM10gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0ZXh0Tm9kZTsgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbaSsrXTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJZ25vcmFibGVXaGl0ZVNwYWNlTm9kZSh0ZXh0Tm9kZSkgJiYgcmFuZ2VTZWxlY3RzQW55VGV4dChyYW5nZSwgdGV4dE5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNNb2RpZmlhYmxlKHRleHROb2RlKSAmJiAhdGhpcy5nZXRTZWxmT3JBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNBcHBsaWVkVG9SYW5nZXM6IGZ1bmN0aW9uKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHZhciBpID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNBcHBsaWVkVG9SYW5nZShyYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0FwcGxpZWRUb1NlbGVjdGlvbjogZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbCA9IGFwaS5nZXRTZWxlY3Rpb24od2luKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FwcGxpZWRUb1JhbmdlcyhzZWwuZ2V0QWxsUmFuZ2VzKCkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9nZ2xlUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBcHBsaWVkVG9SYW5nZShyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmRvVG9SYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVRvUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvZ2dsZVNlbGVjdGlvbjogZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBcHBsaWVkVG9TZWxlY3Rpb24od2luKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZG9Ub1NlbGVjdGlvbih3aW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUb1NlbGVjdGlvbih3aW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEVsZW1lbnRzV2l0aENsYXNzSW50ZXJzZWN0aW5nUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGFwcGxpZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJhbmdlLmdldE5vZGVzKFszXSwgZnVuY3Rpb24odGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gYXBwbGllci5nZXRTZWxmT3JBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCAmJiAhY29udGFpbnMoZWxlbWVudHMsIGVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDbGFzc0FwcGxpZXIoY2xhc3NOYW1lLCBvcHRpb25zLCB0YWdOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzc0FwcGxpZXIoY2xhc3NOYW1lLCBvcHRpb25zLCB0YWdOYW1lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBDbGFzc0FwcGxpZXIudXRpbCA9IHtcbiAgICAgICAgICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICAgICAgICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICAgICAgICAgIGdldENsYXNzOiBnZXRDbGFzcyxcbiAgICAgICAgICAgIGhhc1NhbWVDbGFzc2VzOiBoYXZlU2FtZUNsYXNzZXMsXG4gICAgICAgICAgICBoYXNBbGxDbGFzc2VzOiBoYXNBbGxDbGFzc2VzLFxuICAgICAgICAgICAgcmVwbGFjZVdpdGhPd25DaGlsZHJlbjogcmVwbGFjZVdpdGhPd25DaGlsZHJlblByZXNlcnZpbmdQb3NpdGlvbnMsXG4gICAgICAgICAgICBlbGVtZW50c0hhdmVTYW1lTm9uQ2xhc3NBdHRyaWJ1dGVzOiBlbGVtZW50c0hhdmVTYW1lTm9uQ2xhc3NBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZWxlbWVudEhhc05vbkNsYXNzQXR0cmlidXRlczogZWxlbWVudEhhc05vbkNsYXNzQXR0cmlidXRlcyxcbiAgICAgICAgICAgIHNwbGl0Tm9kZUF0OiBzcGxpdE5vZGVBdCxcbiAgICAgICAgICAgIGlzRWRpdGFibGVFbGVtZW50OiBpc0VkaXRhYmxlRWxlbWVudCxcbiAgICAgICAgICAgIGlzRWRpdGluZ0hvc3Q6IGlzRWRpdGluZ0hvc3QsXG4gICAgICAgICAgICBpc0VkaXRhYmxlOiBpc0VkaXRhYmxlXG4gICAgICAgIH07XG5cbiAgICAgICAgYXBpLkNzc0NsYXNzQXBwbGllciA9IGFwaS5DbGFzc0FwcGxpZXIgPSBDbGFzc0FwcGxpZXI7XG4gICAgICAgIGFwaS5jcmVhdGVDbGFzc0FwcGxpZXIgPSBjcmVhdGVDbGFzc0FwcGxpZXI7XG4gICAgICAgIHV0aWwuY3JlYXRlQWxpYXNGb3JEZXByZWNhdGVkTWV0aG9kKGFwaSwgXCJjcmVhdGVDc3NDbGFzc0FwcGxpZXJcIiwgXCJjcmVhdGVDbGFzc0FwcGxpZXJcIiwgbW9kdWxlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcmFuZ3k7XG59LCB0aGlzKTtcbiIsIi8qKlxyXG4gKiBSYW5neSwgYSBjcm9zcy1icm93c2VyIEphdmFTY3JpcHQgcmFuZ2UgYW5kIHNlbGVjdGlvbiBsaWJyYXJ5XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1kb3duL3Jhbmd5XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE1LCBUaW0gRG93blxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqIFZlcnNpb246IDEuMy4wXHJcbiAqIEJ1aWxkIGRhdGU6IDEwIE1heSAyMDE1XHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKGZhY3RvcnksIHJvb3QpIHtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTIHN0eWxlXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vIEFNRCBvciBDb21tb25KUyBzdXBwb3J0IHNvIHdlIHBsYWNlIFJhbmd5IGluIChwcm9iYWJseSkgdGhlIGdsb2JhbCB2YXJpYWJsZVxyXG4gICAgICAgIHJvb3QucmFuZ3kgPSBmYWN0b3J5KCk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBPQkpFQ1QgPSBcIm9iamVjdFwiLCBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIiwgVU5ERUZJTkVEID0gXCJ1bmRlZmluZWRcIjtcclxuXHJcbiAgICAvLyBNaW5pbWFsIHNldCBvZiBwcm9wZXJ0aWVzIHJlcXVpcmVkIGZvciBET00gTGV2ZWwgMiBSYW5nZSBjb21wbGlhbmNlLiBDb21wYXJpc29uIGNvbnN0YW50cyBzdWNoIGFzIFNUQVJUX1RPX1NUQVJUXHJcbiAgICAvLyBhcmUgb21pdHRlZCBiZWNhdXNlIHJhbmdlcyBpbiBLSFRNTCBkbyBub3QgaGF2ZSB0aGVtIGJ1dCBvdGhlcndpc2Ugd29yayBwZXJmZWN0bHkgd2VsbC4gU2VlIGlzc3VlIDExMy5cclxuICAgIHZhciBkb21SYW5nZVByb3BlcnRpZXMgPSBbXCJzdGFydENvbnRhaW5lclwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwiZW5kQ29udGFpbmVyXCIsIFwiZW5kT2Zmc2V0XCIsIFwiY29sbGFwc2VkXCIsXHJcbiAgICAgICAgXCJjb21tb25BbmNlc3RvckNvbnRhaW5lclwiXTtcclxuXHJcbiAgICAvLyBNaW5pbWFsIHNldCBvZiBtZXRob2RzIHJlcXVpcmVkIGZvciBET00gTGV2ZWwgMiBSYW5nZSBjb21wbGlhbmNlXHJcbiAgICB2YXIgZG9tUmFuZ2VNZXRob2RzID0gW1wic2V0U3RhcnRcIiwgXCJzZXRTdGFydEJlZm9yZVwiLCBcInNldFN0YXJ0QWZ0ZXJcIiwgXCJzZXRFbmRcIiwgXCJzZXRFbmRCZWZvcmVcIixcclxuICAgICAgICBcInNldEVuZEFmdGVyXCIsIFwiY29sbGFwc2VcIiwgXCJzZWxlY3ROb2RlXCIsIFwic2VsZWN0Tm9kZUNvbnRlbnRzXCIsIFwiY29tcGFyZUJvdW5kYXJ5UG9pbnRzXCIsIFwiZGVsZXRlQ29udGVudHNcIixcclxuICAgICAgICBcImV4dHJhY3RDb250ZW50c1wiLCBcImNsb25lQ29udGVudHNcIiwgXCJpbnNlcnROb2RlXCIsIFwic3Vycm91bmRDb250ZW50c1wiLCBcImNsb25lUmFuZ2VcIiwgXCJ0b1N0cmluZ1wiLCBcImRldGFjaFwiXTtcclxuXHJcbiAgICB2YXIgdGV4dFJhbmdlUHJvcGVydGllcyA9IFtcImJvdW5kaW5nSGVpZ2h0XCIsIFwiYm91bmRpbmdMZWZ0XCIsIFwiYm91bmRpbmdUb3BcIiwgXCJib3VuZGluZ1dpZHRoXCIsIFwiaHRtbFRleHRcIiwgXCJ0ZXh0XCJdO1xyXG5cclxuICAgIC8vIFN1YnNldCBvZiBUZXh0UmFuZ2UncyBmdWxsIHNldCBvZiBtZXRob2RzIHRoYXQgd2UncmUgaW50ZXJlc3RlZCBpblxyXG4gICAgdmFyIHRleHRSYW5nZU1ldGhvZHMgPSBbXCJjb2xsYXBzZVwiLCBcImNvbXBhcmVFbmRQb2ludHNcIiwgXCJkdXBsaWNhdGVcIiwgXCJtb3ZlVG9FbGVtZW50VGV4dFwiLCBcInBhcmVudEVsZW1lbnRcIiwgXCJzZWxlY3RcIixcclxuICAgICAgICBcInNldEVuZFBvaW50XCIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCJdO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLy8gVHJpbyBvZiBmdW5jdGlvbnMgdGFrZW4gZnJvbSBQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZTpcclxuICAgIC8vIGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2ZlYXR1cmUtZGV0ZWN0aW9uLXN0YXRlLW9mLXRoZS1hcnQtYnJvd3Nlci1zY3JpcHRpbmdcclxuICAgIGZ1bmN0aW9uIGlzSG9zdE1ldGhvZChvLCBwKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0eXBlb2Ygb1twXTtcclxuICAgICAgICByZXR1cm4gdCA9PSBGVU5DVElPTiB8fCAoISEodCA9PSBPQkpFQ1QgJiYgb1twXSkpIHx8IHQgPT0gXCJ1bmtub3duXCI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNIb3N0T2JqZWN0KG8sIHApIHtcclxuICAgICAgICByZXR1cm4gISEodHlwZW9mIG9bcF0gPT0gT0JKRUNUICYmIG9bcF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzSG9zdFByb3BlcnR5KG8sIHApIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9bcF0gIT0gVU5ERUZJTkVEO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzYXZlIHZlcmJvc2UgcmVwZWF0ZWQgY2FsbHMgdG8gdGVzdHMgZnVuY3Rpb25zXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdCh0ZXN0RnVuYykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvLCBwcm9wcykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0RnVuYyhvLCBwcm9wc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOZXh0IHRyaW8gb2YgZnVuY3Rpb25zIGFyZSBhIGNvbnZlbmllbmNlIHRvIHNhdmUgdmVyYm9zZSByZXBlYXRlZCBjYWxscyB0byBwcmV2aW91cyB0d28gZnVuY3Rpb25zXHJcbiAgICB2YXIgYXJlSG9zdE1ldGhvZHMgPSBjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdChpc0hvc3RNZXRob2QpO1xyXG4gICAgdmFyIGFyZUhvc3RPYmplY3RzID0gY3JlYXRlTXVsdGlwbGVQcm9wZXJ0eVRlc3QoaXNIb3N0T2JqZWN0KTtcclxuICAgIHZhciBhcmVIb3N0UHJvcGVydGllcyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdFByb3BlcnR5KTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc1RleHRSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiByYW5nZSAmJiBhcmVIb3N0TWV0aG9kcyhyYW5nZSwgdGV4dFJhbmdlTWV0aG9kcykgJiYgYXJlSG9zdFByb3BlcnRpZXMocmFuZ2UsIHRleHRSYW5nZVByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEJvZHkoZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzSG9zdE9iamVjdChkb2MsIFwiYm9keVwiKSA/IGRvYy5ib2R5IDogZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZm9yRWFjaCA9IFtdLmZvckVhY2ggP1xyXG4gICAgICAgIGZ1bmN0aW9uKGFyciwgZnVuYykge1xyXG4gICAgICAgICAgICBhcnIuZm9yRWFjaChmdW5jKTtcclxuICAgICAgICB9IDpcclxuICAgICAgICBmdW5jdGlvbihhcnIsIGZ1bmMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZnVuYyhhcnJbaV0sIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB2YXIgbW9kdWxlcyA9IHt9O1xyXG5cclxuICAgIHZhciBpc0Jyb3dzZXIgPSAodHlwZW9mIHdpbmRvdyAhPSBVTkRFRklORUQgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFVOREVGSU5FRCk7XHJcblxyXG4gICAgdmFyIHV0aWwgPSB7XHJcbiAgICAgICAgaXNIb3N0TWV0aG9kOiBpc0hvc3RNZXRob2QsXHJcbiAgICAgICAgaXNIb3N0T2JqZWN0OiBpc0hvc3RPYmplY3QsXHJcbiAgICAgICAgaXNIb3N0UHJvcGVydHk6IGlzSG9zdFByb3BlcnR5LFxyXG4gICAgICAgIGFyZUhvc3RNZXRob2RzOiBhcmVIb3N0TWV0aG9kcyxcclxuICAgICAgICBhcmVIb3N0T2JqZWN0czogYXJlSG9zdE9iamVjdHMsXHJcbiAgICAgICAgYXJlSG9zdFByb3BlcnRpZXM6IGFyZUhvc3RQcm9wZXJ0aWVzLFxyXG4gICAgICAgIGlzVGV4dFJhbmdlOiBpc1RleHRSYW5nZSxcclxuICAgICAgICBnZXRCb2R5OiBnZXRCb2R5LFxyXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGFwaSA9IHtcclxuICAgICAgICB2ZXJzaW9uOiBcIjEuMy4wXCIsXHJcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzQnJvd3NlcjogaXNCcm93c2VyLFxyXG4gICAgICAgIHN1cHBvcnRlZDogdHJ1ZSxcclxuICAgICAgICB1dGlsOiB1dGlsLFxyXG4gICAgICAgIGZlYXR1cmVzOiB7fSxcclxuICAgICAgICBtb2R1bGVzOiBtb2R1bGVzLFxyXG4gICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICBhbGVydE9uRmFpbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFsZXJ0T25XYXJuOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJlZmVyVGV4dFJhbmdlOiBmYWxzZSxcclxuICAgICAgICAgICAgYXV0b0luaXRpYWxpemU6ICh0eXBlb2YgcmFuZ3lBdXRvSW5pdGlhbGl6ZSA9PSBVTkRFRklORUQpID8gdHJ1ZSA6IHJhbmd5QXV0b0luaXRpYWxpemVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnNvbGVMb2cobXNnKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9IFVOREVGSU5FRCAmJiBpc0hvc3RNZXRob2QoY29uc29sZSwgXCJsb2dcIikpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWxlcnRPckxvZyhtc2csIHNob3VsZEFsZXJ0KSB7XHJcbiAgICAgICAgaWYgKGlzQnJvd3NlciAmJiBzaG91bGRBbGVydCkge1xyXG4gICAgICAgICAgICBhbGVydChtc2cpO1xyXG4gICAgICAgIH0gZWxzZSAge1xyXG4gICAgICAgICAgICBjb25zb2xlTG9nKG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XHJcbiAgICAgICAgYXBpLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICBhcGkuc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgYWxlcnRPckxvZyhcIlJhbmd5IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4gUmVhc29uOiBcIiArIHJlYXNvbiwgYXBpLmNvbmZpZy5hbGVydE9uRmFpbCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXBpLmZhaWwgPSBmYWlsO1xyXG5cclxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XHJcbiAgICAgICAgYWxlcnRPckxvZyhcIlJhbmd5IHdhcm5pbmc6IFwiICsgbXNnLCBhcGkuY29uZmlnLmFsZXJ0T25XYXJuKTtcclxuICAgIH1cclxuXHJcbiAgICBhcGkud2FybiA9IHdhcm47XHJcblxyXG4gICAgLy8gQWRkIHV0aWxpdHkgZXh0ZW5kKCkgbWV0aG9kXHJcbiAgICB2YXIgZXh0ZW5kO1xyXG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5KSB7XHJcbiAgICAgICAgdXRpbC5leHRlbmQgPSBleHRlbmQgPSBmdW5jdGlvbihvYmosIHByb3BzLCBkZWVwKSB7XHJcbiAgICAgICAgICAgIHZhciBvLCBwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvID0gb2JqW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBvICE9PSBudWxsICYmIHR5cGVvZiBvID09IFwib2JqZWN0XCIgJiYgcCAhPT0gbnVsbCAmJiB0eXBlb2YgcCA9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZChvLCBwLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRvU3RyaW5nLCB3aGljaCBkb2VzIG5vdCBzaG93IHVwIGluIGZvci4uLmluIGxvb3BzIGluIElFIDw9IDhcclxuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikpIHtcclxuICAgICAgICAgICAgICAgIG9iai50b1N0cmluZyA9IHByb3BzLnRvU3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdXRpbC5jcmVhdGVPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9uc1BhcmFtLCBkZWZhdWx0cykge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBleHRlbmQob3B0aW9ucywgZGVmYXVsdHMpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uc1BhcmFtKSB7XHJcbiAgICAgICAgICAgICAgICBleHRlbmQob3B0aW9ucywgb3B0aW9uc1BhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmYWlsKFwiaGFzT3duUHJvcGVydHkgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IHdoZXRoZXIgd2UncmUgaW4gYSBicm93c2VyIGFuZCBiYWlsIG91dCBpZiBub3RcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgZmFpbChcIlJhbmd5IGNhbiBvbmx5IHJ1biBpbiBhIGJyb3dzZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVzdCB3aGV0aGVyIEFycmF5LnByb3RvdHlwZS5zbGljZSBjYW4gYmUgcmVsaWVkIG9uIGZvciBOb2RlTGlzdHMgYW5kIHVzZSBhbiBhbHRlcm5hdGl2ZSB0b0FycmF5KCkgaWYgbm90XHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRvQXJyYXk7XHJcblxyXG4gICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xyXG4gICAgICAgICAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChzbGljZS5jYWxsKGVsLmNoaWxkTm9kZXMsIDApWzBdLm5vZGVUeXBlID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5TGlrZSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdG9BcnJheSkge1xyXG4gICAgICAgICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXlMaWtlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHV0aWwudG9BcnJheSA9IHRvQXJyYXk7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIFZlcnkgc2ltcGxlIGV2ZW50IGhhbmRsZXIgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGRvZXNuJ3QgYXR0ZW1wdCB0byBzb2x2ZSBpc3N1ZXMgc3VjaCBhcyBcInRoaXNcIiBoYW5kbGluZyBvclxyXG4gICAgLy8gbm9ybWFsaXphdGlvbiBvZiBldmVudCBwcm9wZXJ0aWVzXHJcbiAgICB2YXIgYWRkTGlzdGVuZXI7XHJcbiAgICBpZiAoaXNCcm93c2VyKSB7XHJcbiAgICAgICAgaWYgKGlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJhZGRFdmVudExpc3RlbmVyXCIpKSB7XHJcbiAgICAgICAgICAgIGFkZExpc3RlbmVyID0gZnVuY3Rpb24ob2JqLCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2QoZG9jdW1lbnQsIFwiYXR0YWNoRXZlbnRcIikpIHtcclxuICAgICAgICAgICAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihvYmosIGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIG9iai5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudFR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmYWlsKFwiRG9jdW1lbnQgZG9lcyBub3QgaGF2ZSByZXF1aXJlZCBhZGRFdmVudExpc3RlbmVyIG9yIGF0dGFjaEV2ZW50IG1ldGhvZFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHV0aWwuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5pdExpc3RlbmVycyA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldEVycm9yRGVzYyhleCkge1xyXG4gICAgICAgIHJldHVybiBleC5tZXNzYWdlIHx8IGV4LmRlc2NyaXB0aW9uIHx8IFN0cmluZyhleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6YXRpb25cclxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgYXBpLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRlc3RSYW5nZTtcclxuICAgICAgICB2YXIgaW1wbGVtZW50c0RvbVJhbmdlID0gZmFsc2UsIGltcGxlbWVudHNUZXh0UmFuZ2UgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gRmlyc3QsIHBlcmZvcm0gYmFzaWMgZmVhdHVyZSB0ZXN0c1xyXG5cclxuICAgICAgICBpZiAoaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImNyZWF0ZVJhbmdlXCIpKSB7XHJcbiAgICAgICAgICAgIHRlc3RSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgICAgICAgIGlmIChhcmVIb3N0TWV0aG9kcyh0ZXN0UmFuZ2UsIGRvbVJhbmdlTWV0aG9kcykgJiYgYXJlSG9zdFByb3BlcnRpZXModGVzdFJhbmdlLCBkb21SYW5nZVByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRzRG9tUmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm9keSA9IGdldEJvZHkoZG9jdW1lbnQpO1xyXG4gICAgICAgIGlmICghYm9keSB8fCBib2R5Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gXCJib2R5XCIpIHtcclxuICAgICAgICAgICAgZmFpbChcIk5vIGJvZHkgZWxlbWVudCBmb3VuZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJvZHkgJiYgaXNIb3N0TWV0aG9kKGJvZHksIFwiY3JlYXRlVGV4dFJhbmdlXCIpKSB7XHJcbiAgICAgICAgICAgIHRlc3RSYW5nZSA9IGJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XHJcbiAgICAgICAgICAgIGlmIChpc1RleHRSYW5nZSh0ZXN0UmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRzVGV4dFJhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpbXBsZW1lbnRzRG9tUmFuZ2UgJiYgIWltcGxlbWVudHNUZXh0UmFuZ2UpIHtcclxuICAgICAgICAgICAgZmFpbChcIk5laXRoZXIgUmFuZ2Ugbm9yIFRleHRSYW5nZSBhcmUgYXZhaWxhYmxlXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcGkuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIGFwaS5mZWF0dXJlcyA9IHtcclxuICAgICAgICAgICAgaW1wbGVtZW50c0RvbVJhbmdlOiBpbXBsZW1lbnRzRG9tUmFuZ2UsXHJcbiAgICAgICAgICAgIGltcGxlbWVudHNUZXh0UmFuZ2U6IGltcGxlbWVudHNUZXh0UmFuZ2VcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIG1vZHVsZXNcclxuICAgICAgICB2YXIgbW9kdWxlLCBlcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgZm9yICh2YXIgbW9kdWxlTmFtZSBpbiBtb2R1bGVzKSB7XHJcbiAgICAgICAgICAgIGlmICggKG1vZHVsZSA9IG1vZHVsZXNbbW9kdWxlTmFtZV0pIGluc3RhbmNlb2YgTW9kdWxlICkge1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlLmluaXQobW9kdWxlLCBhcGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxsIGluaXQgbGlzdGVuZXJzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGluaXRMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGluaXRMaXN0ZW5lcnNbaV0oYXBpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiUmFuZ3kgaW5pdCBsaXN0ZW5lciB0aHJldyBhbiBleGNlcHRpb24uIENvbnRpbnVpbmcuIERldGFpbDogXCIgKyBnZXRFcnJvckRlc2MoZXgpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZUxvZyhlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0aW9uTm90aWNlKGRlcHJlY2F0ZWQsIHJlcGxhY2VtZW50LCBtb2R1bGUpIHtcclxuICAgICAgICBpZiAobW9kdWxlKSB7XHJcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQgKz0gXCIgaW4gbW9kdWxlIFwiICsgbW9kdWxlLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFwaS53YXJuKFwiREVQUkVDQVRFRDogXCIgKyBkZXByZWNhdGVkICsgXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIiArXHJcbiAgICAgICAgcmVwbGFjZW1lbnQgKyBcIiBpbnN0ZWFkLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBbGlhc0ZvckRlcHJlY2F0ZWRNZXRob2Qob3duZXIsIGRlcHJlY2F0ZWQsIHJlcGxhY2VtZW50LCBtb2R1bGUpIHtcclxuICAgICAgICBvd25lcltkZXByZWNhdGVkXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBkZXByZWNhdGlvbk5vdGljZShkZXByZWNhdGVkLCByZXBsYWNlbWVudCwgbW9kdWxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG93bmVyW3JlcGxhY2VtZW50XS5hcHBseShvd25lciwgdXRpbC50b0FycmF5KGFyZ3VtZW50cykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdXRpbC5kZXByZWNhdGlvbk5vdGljZSA9IGRlcHJlY2F0aW9uTm90aWNlO1xyXG4gICAgdXRpbC5jcmVhdGVBbGlhc0ZvckRlcHJlY2F0ZWRNZXRob2QgPSBjcmVhdGVBbGlhc0ZvckRlcHJlY2F0ZWRNZXRob2Q7XHJcblxyXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgc2NyaXB0cyB0byBpbml0aWFsaXplIHRoaXMgbGlicmFyeSBpbiBjYXNlIGl0J3MgbG9hZGVkIGFmdGVyIHRoZSBkb2N1bWVudCBoYXMgbG9hZGVkXHJcbiAgICBhcGkuaW5pdCA9IGluaXQ7XHJcblxyXG4gICAgLy8gRXhlY3V0ZSBsaXN0ZW5lciBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGluaXRpYWxpemVkXHJcbiAgICBhcGkuYWRkSW5pdExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAoYXBpLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKGFwaSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5pdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzaGltTGlzdGVuZXJzID0gW107XHJcblxyXG4gICAgYXBpLmFkZFNoaW1MaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgc2hpbUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gc2hpbSh3aW4pIHtcclxuICAgICAgICB3aW4gPSB3aW4gfHwgd2luZG93O1xyXG4gICAgICAgIGluaXQoKTtcclxuXHJcbiAgICAgICAgLy8gTm90aWZ5IGxpc3RlbmVyc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzaGltTGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHNoaW1MaXN0ZW5lcnNbaV0od2luKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQnJvd3Nlcikge1xyXG4gICAgICAgIGFwaS5zaGltID0gYXBpLmNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkgPSBzaGltO1xyXG4gICAgICAgIGNyZWF0ZUFsaWFzRm9yRGVwcmVjYXRlZE1ldGhvZChhcGksIFwiY3JlYXRlTWlzc2luZ05hdGl2ZUFwaVwiLCBcInNoaW1cIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTW9kdWxlKG5hbWUsIGRlcGVuZGVuY2llcywgaW5pdGlhbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcjtcclxuICAgIH1cclxuXHJcbiAgICBNb2R1bGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVxdWlyZWRNb2R1bGVOYW1lcyA9IHRoaXMuZGVwZW5kZW5jaWVzIHx8IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVxdWlyZWRNb2R1bGVOYW1lcy5sZW5ndGgsIHJlcXVpcmVkTW9kdWxlLCBtb2R1bGVOYW1lOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUgPSByZXF1aXJlZE1vZHVsZU5hbWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkTW9kdWxlID0gbW9kdWxlc1ttb2R1bGVOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVxdWlyZWRNb2R1bGUgfHwgIShyZXF1aXJlZE1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXF1aXJlZCBtb2R1bGUgJ1wiICsgbW9kdWxlTmFtZSArIFwiJyBub3QgZm91bmRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRNb2R1bGUuaW5pdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghcmVxdWlyZWRNb2R1bGUuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVxdWlyZWQgbW9kdWxlICdcIiArIG1vZHVsZU5hbWUgKyBcIicgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm93IHJ1biBpbml0aWFsaXplclxyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZhaWw6IGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zdXBwb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd2FybjogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgIGFwaS53YXJuKFwiTW9kdWxlIFwiICsgdGhpcy5uYW1lICsgXCI6IFwiICsgbXNnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZXByZWNhdGlvbk5vdGljZTogZnVuY3Rpb24oZGVwcmVjYXRlZCwgcmVwbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgYXBpLndhcm4oXCJERVBSRUNBVEVEOiBcIiArIGRlcHJlY2F0ZWQgKyBcIiBpbiBtb2R1bGUgXCIgKyB0aGlzLm5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiICtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ICsgXCIgaW5zdGVhZFwiKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjcmVhdGVFcnJvcjogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFcnJvciBpbiBSYW5neSBcIiArIHRoaXMubmFtZSArIFwiIG1vZHVsZTogXCIgKyBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTW9kdWxlKG5hbWUsIGRlcGVuZGVuY2llcywgaW5pdEZ1bmMpIHtcclxuICAgICAgICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShuYW1lLCBkZXBlbmRlbmNpZXMsIGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4gICAgICAgICAgICBpZiAoIW1vZHVsZS5pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdEZ1bmMoYXBpLCBtb2R1bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5zdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJNb2R1bGUgJ1wiICsgbmFtZSArIFwiJyBmYWlsZWQgdG8gbG9hZDogXCIgKyBnZXRFcnJvckRlc2MoZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVMb2coZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXguc3RhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZUxvZyhleC5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW9kdWxlc1tuYW1lXSA9IG5ld01vZHVsZTtcclxuICAgICAgICByZXR1cm4gbmV3TW9kdWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGFwaS5jcmVhdGVNb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgMiBvciAzIGFyZ3VtZW50cyAoc2Vjb25kIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIGFycmF5IG9mIGRlcGVuZGVuY2llcylcclxuICAgICAgICB2YXIgaW5pdEZ1bmMsIGRlcGVuZGVuY2llcztcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIGluaXRGdW5jID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBbXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbml0RnVuYyA9IGFyZ3VtZW50c1syXTtcclxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1vZHVsZSA9IGNyZWF0ZU1vZHVsZShuYW1lLCBkZXBlbmRlbmNpZXMsIGluaXRGdW5jKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGltbWVkaWF0ZWx5IGlmIHRoZSBjb3JlIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcclxuICAgICAgICBpZiAoYXBpLmluaXRpYWxpemVkICYmIGFwaS5zdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgbW9kdWxlLmluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFwaS5jcmVhdGVDb3JlTW9kdWxlID0gZnVuY3Rpb24obmFtZSwgZGVwZW5kZW5jaWVzLCBpbml0RnVuYykge1xyXG4gICAgICAgIGNyZWF0ZU1vZHVsZShuYW1lLCBkZXBlbmRlbmNpZXMsIGluaXRGdW5jKTtcclxuICAgIH07XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvLyBFbnN1cmUgcmFuZ3kucmFuZ2VQcm90b3R5cGUgYW5kIHJhbmd5LnNlbGVjdGlvblByb3RvdHlwZSBhcmUgYXZhaWxhYmxlIGltbWVkaWF0ZWx5XHJcblxyXG4gICAgZnVuY3Rpb24gUmFuZ2VQcm90b3R5cGUoKSB7fVxyXG4gICAgYXBpLlJhbmdlUHJvdG90eXBlID0gUmFuZ2VQcm90b3R5cGU7XHJcbiAgICBhcGkucmFuZ2VQcm90b3R5cGUgPSBuZXcgUmFuZ2VQcm90b3R5cGUoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25Qcm90b3R5cGUoKSB7fVxyXG4gICAgYXBpLnNlbGVjdGlvblByb3RvdHlwZSA9IG5ldyBTZWxlY3Rpb25Qcm90b3R5cGUoKTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8vIERPTSB1dGlsaXR5IG1ldGhvZHMgdXNlZCBieSBSYW5neVxuICAgIGFwaS5jcmVhdGVDb3JlTW9kdWxlKFwiRG9tVXRpbFwiLCBbXSwgZnVuY3Rpb24oYXBpLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIFVOREVGID0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgdmFyIHV0aWwgPSBhcGkudXRpbDtcbiAgICAgICAgdmFyIGdldEJvZHkgPSB1dGlsLmdldEJvZHk7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBmZWF0dXJlIHRlc3RzXG4gICAgICAgIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyhkb2N1bWVudCwgW1wiY3JlYXRlRG9jdW1lbnRGcmFnbWVudFwiLCBcImNyZWF0ZUVsZW1lbnRcIiwgXCJjcmVhdGVUZXh0Tm9kZVwiXSkpIHtcbiAgICAgICAgICAgIG1vZHVsZS5mYWlsKFwiZG9jdW1lbnQgbWlzc2luZyBhIE5vZGUgY3JlYXRpb24gbWV0aG9kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiKSkge1xuICAgICAgICAgICAgbW9kdWxlLmZhaWwoXCJkb2N1bWVudCBtaXNzaW5nIGdldEVsZW1lbnRzQnlUYWdOYW1lIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyhlbCwgW1wiaW5zZXJ0QmVmb3JlXCIsIFwiYXBwZW5kQ2hpbGRcIiwgXCJjbG9uZU5vZGVcIl0gfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5hcmVIb3N0T2JqZWN0cyhlbCwgW1wicHJldmlvdXNTaWJsaW5nXCIsIFwibmV4dFNpYmxpbmdcIiwgXCJjaGlsZE5vZGVzXCIsIFwicGFyZW50Tm9kZVwiXSkpKSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIkluY29tcGxldGUgRWxlbWVudCBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlubmVySFRNTCBpcyByZXF1aXJlZCBmb3IgUmFuZ2UncyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgbWV0aG9kXG4gICAgICAgIGlmICghdXRpbC5pc0hvc3RQcm9wZXJ0eShlbCwgXCJpbm5lckhUTUxcIikpIHtcbiAgICAgICAgICAgIG1vZHVsZS5mYWlsKFwiRWxlbWVudCBpcyBtaXNzaW5nIGlubmVySFRNTCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGVzdFwiKTtcbiAgICAgICAgaWYgKCF1dGlsLmFyZUhvc3RNZXRob2RzKHRleHROb2RlLCBbXCJzcGxpdFRleHRcIiwgXCJkZWxldGVEYXRhXCIsIFwiaW5zZXJ0RGF0YVwiLCBcImFwcGVuZERhdGFcIiwgXCJjbG9uZU5vZGVcIl0gfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5hcmVIb3N0T2JqZWN0cyhlbCwgW1wicHJldmlvdXNTaWJsaW5nXCIsIFwibmV4dFNpYmxpbmdcIiwgXCJjaGlsZE5vZGVzXCIsIFwicGFyZW50Tm9kZVwiXSkgfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5hcmVIb3N0UHJvcGVydGllcyh0ZXh0Tm9kZSwgW1wiZGF0YVwiXSkpKSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIkluY29tcGxldGUgVGV4dCBOb2RlIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBSZW1vdmVkIHVzZSBvZiBpbmRleE9mIGJlY2F1c2Ugb2YgYSBiaXphcnJlIGJ1ZyBpbiBPcGVyYSB0aGF0IGlzIHRocm93biBpbiBvbmUgb2YgdGhlIEFjaWQzIHRlc3RzLiBJIGhhdmVuJ3QgYmVlblxuICAgICAgICAvLyBhYmxlIHRvIHJlcGxpY2F0ZSBpdCBvdXRzaWRlIG9mIHRoZSB0ZXN0LiBUaGUgYnVnIGlzIHRoYXQgaW5kZXhPZiByZXR1cm5zIC0xIHdoZW4gY2FsbGVkIG9uIGFuIEFycmF5IHRoYXRcbiAgICAgICAgLy8gY29udGFpbnMganVzdCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgZWxlbWVudCBhbmQgdGhlIHZhbHVlIHNlYXJjaGVkIGZvciBpcyB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHZhciBhcnJheUNvbnRhaW5zID0gLypBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA/XG4gICAgICAgICAgICBmdW5jdGlvbihhcnIsIHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnIuaW5kZXhPZih2YWwpID4gLTE7XG4gICAgICAgICAgICB9OiovXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uKGFyciwgdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIE9wZXJhIDExIHB1dHMgSFRNTCBlbGVtZW50cyBpbiB0aGUgbnVsbCBuYW1lc3BhY2UsIGl0IHNlZW1zLCBhbmQgSUUgNyBoYXMgdW5kZWZpbmVkIG5hbWVzcGFjZVVSSVxuICAgICAgICBmdW5jdGlvbiBpc0h0bWxOYW1lc3BhY2Uobm9kZSkge1xuICAgICAgICAgICAgdmFyIG5zO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBub2RlLm5hbWVzcGFjZVVSSSA9PSBVTkRFRiB8fCAoKG5zID0gbm9kZS5uYW1lc3BhY2VVUkkpID09PSBudWxsIHx8IG5zID09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudEVsZW1lbnQobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiAocGFyZW50Lm5vZGVUeXBlID09IDEpID8gcGFyZW50IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5vZGVJbmRleChub2RlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSggKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykgKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXROb2RlTGVuZ3RoKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvcihub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvcnMgPSBbXSwgbjtcbiAgICAgICAgICAgIGZvciAobiA9IG5vZGUxOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gobik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobiA9IG5vZGUyOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5Q29udGFpbnMoYW5jZXN0b3JzLCBuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3Rvck9mKGFuY2VzdG9yLCBkZXNjZW5kYW50LCBzZWxmSXNBbmNlc3Rvcikge1xuICAgICAgICAgICAgdmFyIG4gPSBzZWxmSXNBbmNlc3RvciA/IGRlc2NlbmRhbnQgOiBkZXNjZW5kYW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzT3JJc0FuY2VzdG9yT2YoYW5jZXN0b3IsIGRlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FuY2VzdG9yT2YoYW5jZXN0b3IsIGRlc2NlbmRhbnQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZSwgYW5jZXN0b3IsIHNlbGZJc0FuY2VzdG9yKSB7XG4gICAgICAgICAgICB2YXIgcCwgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgcCA9IG4ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4gPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0ID09IDMgfHwgdCA9PSA0IHx8IHQgPT0gOCA7IC8vIFRleHQsIENEYXRhU2VjdGlvbiBvciBDb21tZW50XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1RleHRPckNvbW1lbnROb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0ID09IDMgfHwgdCA9PSA4IDsgLy8gVGV4dCBvciBDb21tZW50XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZnRlcihub2RlLCBwcmVjZWRpbmdOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBwcmVjZWRpbmdOb2RlLm5leHRTaWJsaW5nLCBwYXJlbnQgPSBwcmVjZWRpbmdOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHROb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgY2Fubm90IHVzZSBzcGxpdFRleHQoKSBiZWNhdXNlIGl0IGlzIGJ1Z3JpZGRlbiBpbiBJRSA5LlxuICAgICAgICBmdW5jdGlvbiBzcGxpdERhdGFOb2RlKG5vZGUsIGluZGV4LCBwb3NpdGlvbnNUb1ByZXNlcnZlKSB7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgIG5ld05vZGUuZGVsZXRlRGF0YSgwLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlLmRlbGV0ZURhdGEoaW5kZXgsIG5vZGUubGVuZ3RoIC0gaW5kZXgpO1xuICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIobmV3Tm9kZSwgbm9kZSk7XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHBvc2l0aW9uc1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1RvUHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcG9zaXRpb247IHBvc2l0aW9uID0gcG9zaXRpb25zVG9QcmVzZXJ2ZVtpKytdOyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcG9zaXRpb24gd2FzIGluc2lkZSB0aGUgcG9ydGlvbiBvZiBub2RlIGFmdGVyIHRoZSBzcGxpdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ubm9kZSA9PSBub2RlICYmIHBvc2l0aW9uLm9mZnNldCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5ub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLm9mZnNldCAtPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHBvc2l0aW9uIGlzIGEgbm9kZSBvZmZzZXQgd2l0aGluIG5vZGUncyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubm9kZSA9PSBub2RlLnBhcmVudE5vZGUgJiYgcG9zaXRpb24ub2Zmc2V0ID4gZ2V0Tm9kZUluZGV4KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3Bvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5vd25lckRvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuZG9jdW1lbnQgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldERvY3VtZW50KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcImdldERvY3VtZW50OiBubyBkb2N1bWVudCBmb3VuZCBmb3Igbm9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvYy5kZWZhdWx0VmlldyAhPSBVTkRFRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MucGFyZW50V2luZG93ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcIkNhbm5vdCBnZXQgYSB3aW5kb3cgb2JqZWN0IGZvciBub2RlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWZyYW1lRWwuY29udGVudERvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiZ2V0SWZyYW1lRG9jdW1lbnQ6IE5vIERvY3VtZW50IG9iamVjdCBmb3VuZCBmb3IgaWZyYW1lIGVsZW1lbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRJZnJhbWVXaW5kb3coaWZyYW1lRWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWZyYW1lRWwuY29udGVudFdpbmRvdyAhPSBVTkRFRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWZyYW1lRWwuY29udGVudERvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiZ2V0SWZyYW1lV2luZG93OiBObyBXaW5kb3cgb2JqZWN0IGZvdW5kIGZvciBpZnJhbWUgZWxlbWVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgbG9va3MgYmFkLiBJcyBpdCB3b3J0aCBpdD9cbiAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHV0aWwuaXNIb3N0TWV0aG9kKG9iaiwgXCJzZXRUaW1lb3V0XCIpICYmIHV0aWwuaXNIb3N0T2JqZWN0KG9iaiwgXCJkb2N1bWVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbnRlbnREb2N1bWVudChvYmosIG1vZHVsZSwgbWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgdmFyIGRvYztcblxuICAgICAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgICAgICBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGVzdCBpZiBhIERPTSBub2RlIGhhcyBiZWVuIHBhc3NlZCBhbmQgb2J0YWluIGEgZG9jdW1lbnQgb2JqZWN0IGZvciBpdCBpZiBzb1xuICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc0hvc3RQcm9wZXJ0eShvYmosIFwibm9kZVR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBkb2MgPSAob2JqLm5vZGVUeXBlID09IDEgJiYgb2JqLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImlmcmFtZVwiKSA/XG4gICAgICAgICAgICAgICAgICAgIGdldElmcmFtZURvY3VtZW50KG9iaikgOiBnZXREb2N1bWVudChvYmopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSBkb2MgcGFyYW1ldGVyIGFwcGVhcnMgdG8gYmUgYSBXaW5kb3cgb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmIChpc1dpbmRvdyhvYmopKSB7XG4gICAgICAgICAgICAgICAgZG9jID0gb2JqLmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihtZXRob2ROYW1lICsgXCIoKTogUGFyYW1ldGVyIG11c3QgYmUgYSBXaW5kb3cgb2JqZWN0IG9yIERPTSBub2RlXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Um9vdENvbnRhaW5lcihub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCAocGFyZW50ID0gbm9kZS5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKG5vZGVBLCBvZmZzZXRBLCBub2RlQiwgb2Zmc2V0Qikge1xuICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLVRyYXZlcnNhbC1SYW5nZS9yYW5nZXMuaHRtbCNMZXZlbC0yLVJhbmdlLUNvbXBhcmluZ1xuICAgICAgICAgICAgdmFyIG5vZGVDLCByb290LCBjaGlsZEEsIGNoaWxkQiwgbjtcbiAgICAgICAgICAgIGlmIChub2RlQSA9PSBub2RlQikge1xuICAgICAgICAgICAgICAgIC8vIENhc2UgMTogbm9kZXMgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldEEgPT09IG9mZnNldEIgPyAwIDogKG9mZnNldEEgPCBvZmZzZXRCKSA/IC0xIDogMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIChub2RlQyA9IGdldENsb3Nlc3RBbmNlc3RvckluKG5vZGVCLCBub2RlQSwgdHJ1ZSkpICkge1xuICAgICAgICAgICAgICAgIC8vIENhc2UgMjogbm9kZSBDIChjb250YWluZXIgQiBvciBhbiBhbmNlc3RvcikgaXMgYSBjaGlsZCBub2RlIG9mIEFcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0QSA8PSBnZXROb2RlSW5kZXgobm9kZUMpID8gLTEgOiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggKG5vZGVDID0gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUEsIG5vZGVCLCB0cnVlKSkgKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAzOiBub2RlIEMgKGNvbnRhaW5lciBBIG9yIGFuIGFuY2VzdG9yKSBpcyBhIGNoaWxkIG5vZGUgb2YgQlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2RlSW5kZXgobm9kZUMpIDwgb2Zmc2V0QiAgPyAtMSA6IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QgPSBnZXRDb21tb25BbmNlc3Rvcihub2RlQSwgbm9kZUIpO1xuICAgICAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wYXJlUG9pbnRzIGVycm9yOiBub2RlcyBoYXZlIG5vIGNvbW1vbiBhbmNlc3RvclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYXNlIDQ6IGNvbnRhaW5lcnMgYXJlIHNpYmxpbmdzIG9yIGRlc2NlbmRhbnRzIG9mIHNpYmxpbmdzXG4gICAgICAgICAgICAgICAgY2hpbGRBID0gKG5vZGVBID09PSByb290KSA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQSwgcm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2hpbGRCID0gKG5vZGVCID09PSByb290KSA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQiwgcm9vdCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRBID09PSBjaGlsZEIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiY29tcGFyZVBvaW50cyBnb3QgdG8gY2FzZSA0IGFuZCBjaGlsZEEgYW5kIGNoaWxkQiBhcmUgdGhlIHNhbWUhXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA9PT0gY2hpbGRBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSBjaGlsZEIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBUZXN0IGZvciBJRSdzIGNyYXNoIChJRSA2LzcpIG9yIGV4Y2VwdGlvbiAoSUUgPj0gOCkgd2hlbiBhIHJlZmVyZW5jZSB0byBnYXJiYWdlLWNvbGxlY3RlZCB0ZXh0IG5vZGUgaXMgcXVlcmllZFxuICAgICAgICB2YXIgY3Jhc2h5VGV4dE5vZGVzID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNCcm9rZW5Ob2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiXCIpO1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCIxXCI7XG4gICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8YnIgLz5cIjtcbiAgICAgICAgICAgIGNyYXNoeVRleHROb2RlcyA9IGlzQnJva2VuTm9kZSh0ZXh0Tm9kZSk7XG5cbiAgICAgICAgICAgIGFwaS5mZWF0dXJlcy5jcmFzaHlUZXh0Tm9kZXMgPSBjcmFzaHlUZXh0Tm9kZXM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICBmdW5jdGlvbiBpbnNwZWN0Tm9kZShub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbTm8gbm9kZV1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjcmFzaHlUZXh0Tm9kZXMgJiYgaXNCcm9rZW5Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW0Jyb2tlbiBub2RlXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJyArIG5vZGUuZGF0YSArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IG5vZGUuaWQgPyAnIGlkPVwiJyArIG5vZGUuaWQgKyAnXCInIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8XCIgKyBub2RlLm5vZGVOYW1lICsgaWRBdHRyICsgXCI+W2luZGV4OlwiICsgZ2V0Tm9kZUluZGV4KG5vZGUpICsgXCIsbGVuZ3RoOlwiICsgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCArIFwiXVtcIiArIChub2RlLmlubmVySFRNTCB8fCBcIltpbm5lckhUTUwgbm90IHN1cHBvcnRlZF1cIikuc2xpY2UoMCwgMjUpICsgXCJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBnZXREb2N1bWVudChub2RlKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGNoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKCAoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQpICkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnZXRDb21wdXRlZFN0eWxlUHJvcGVydHk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgIGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKGVsLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaW5kb3coZWwpLmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgIGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKGVsLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5jdXJyZW50U3R5bGUgPyBlbC5jdXJyZW50U3R5bGVbcHJvcE5hbWVdIDogXCJcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIk5vIG1lYW5zIG9mIG9idGFpbmluZyBjb21wdXRlZCBzdHlsZSBwcm9wZXJ0aWVzIGZvdW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlVGVzdEVsZW1lbnQoZG9jLCBodG1sLCBjb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gZ2V0Qm9keShkb2MpO1xuICAgICAgICAgICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBlbC5jb250ZW50RWRpdGFibGUgPSBcIlwiICsgISFjb250ZW50RWRpdGFibGU7XG4gICAgICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgdGVzdCBlbGVtZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgYm9keSB0byBwcmV2ZW50IHNjcm9sbGluZyB0byB0aGUgYm90dG9tIGluIGlPUyAoaXNzdWUgIzI5MilcbiAgICAgICAgICAgIHZhciBib2R5Rmlyc3RDaGlsZCA9IGJvZHkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChib2R5Rmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGVsLCBib2R5Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBOb2RlSXRlcmF0b3Iocm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMuX25leHQgPSByb290O1xuICAgICAgICB9XG5cbiAgICAgICAgTm9kZUl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIF9jdXJyZW50OiBudWxsLFxuXG4gICAgICAgICAgICBoYXNOZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9uZXh0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQsIG5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBuLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG4gIT09IHRoaXMucm9vdCkgJiYgIShuZXh0ID0gbi5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0ID0gdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVJdGVyYXRvcihyb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIERvbVBvc2l0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgRG9tUG9zaXRpb24ucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgZXF1YWxzOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFwb3MgJiYgdGhpcy5ub2RlID09PSBwb3Mubm9kZSAmJiB0aGlzLm9mZnNldCA9PSBwb3Mub2Zmc2V0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5zcGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW0RvbVBvc2l0aW9uKFwiICsgaW5zcGVjdE5vZGUodGhpcy5ub2RlKSArIFwiOlwiICsgdGhpcy5vZmZzZXQgKyBcIildXCI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIERPTUV4Y2VwdGlvbihjb2RlTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlID0gdGhpc1tjb2RlTmFtZV07XG4gICAgICAgICAgICB0aGlzLmNvZGVOYW1lID0gY29kZU5hbWU7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkRPTUV4Y2VwdGlvbjogXCIgKyB0aGlzLmNvZGVOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIElOREVYX1NJWkVfRVJSOiAxLFxuICAgICAgICAgICAgSElFUkFSQ0hZX1JFUVVFU1RfRVJSOiAzLFxuICAgICAgICAgICAgV1JPTkdfRE9DVU1FTlRfRVJSOiA0LFxuICAgICAgICAgICAgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiA3LFxuICAgICAgICAgICAgTk9UX0ZPVU5EX0VSUjogOCxcbiAgICAgICAgICAgIE5PVF9TVVBQT1JURURfRVJSOiA5LFxuICAgICAgICAgICAgSU5WQUxJRF9TVEFURV9FUlI6IDExLFxuICAgICAgICAgICAgSU5WQUxJRF9OT0RFX1RZUEVfRVJSOiAyNFxuICAgICAgICB9O1xuXG4gICAgICAgIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgYXBpLmRvbSA9IHtcbiAgICAgICAgICAgIGFycmF5Q29udGFpbnM6IGFycmF5Q29udGFpbnMsXG4gICAgICAgICAgICBpc0h0bWxOYW1lc3BhY2U6IGlzSHRtbE5hbWVzcGFjZSxcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICBnZXROb2RlSW5kZXg6IGdldE5vZGVJbmRleCxcbiAgICAgICAgICAgIGdldE5vZGVMZW5ndGg6IGdldE5vZGVMZW5ndGgsXG4gICAgICAgICAgICBnZXRDb21tb25BbmNlc3RvcjogZ2V0Q29tbW9uQW5jZXN0b3IsXG4gICAgICAgICAgICBpc0FuY2VzdG9yT2Y6IGlzQW5jZXN0b3JPZixcbiAgICAgICAgICAgIGlzT3JJc0FuY2VzdG9yT2Y6IGlzT3JJc0FuY2VzdG9yT2YsXG4gICAgICAgICAgICBnZXRDbG9zZXN0QW5jZXN0b3JJbjogZ2V0Q2xvc2VzdEFuY2VzdG9ySW4sXG4gICAgICAgICAgICBpc0NoYXJhY3RlckRhdGFOb2RlOiBpc0NoYXJhY3RlckRhdGFOb2RlLFxuICAgICAgICAgICAgaXNUZXh0T3JDb21tZW50Tm9kZTogaXNUZXh0T3JDb21tZW50Tm9kZSxcbiAgICAgICAgICAgIGluc2VydEFmdGVyOiBpbnNlcnRBZnRlcixcbiAgICAgICAgICAgIHNwbGl0RGF0YU5vZGU6IHNwbGl0RGF0YU5vZGUsXG4gICAgICAgICAgICBnZXREb2N1bWVudDogZ2V0RG9jdW1lbnQsXG4gICAgICAgICAgICBnZXRXaW5kb3c6IGdldFdpbmRvdyxcbiAgICAgICAgICAgIGdldElmcmFtZVdpbmRvdzogZ2V0SWZyYW1lV2luZG93LFxuICAgICAgICAgICAgZ2V0SWZyYW1lRG9jdW1lbnQ6IGdldElmcmFtZURvY3VtZW50LFxuICAgICAgICAgICAgZ2V0Qm9keTogZ2V0Qm9keSxcbiAgICAgICAgICAgIGlzV2luZG93OiBpc1dpbmRvdyxcbiAgICAgICAgICAgIGdldENvbnRlbnREb2N1bWVudDogZ2V0Q29udGVudERvY3VtZW50LFxuICAgICAgICAgICAgZ2V0Um9vdENvbnRhaW5lcjogZ2V0Um9vdENvbnRhaW5lcixcbiAgICAgICAgICAgIGNvbXBhcmVQb2ludHM6IGNvbXBhcmVQb2ludHMsXG4gICAgICAgICAgICBpc0Jyb2tlbk5vZGU6IGlzQnJva2VuTm9kZSxcbiAgICAgICAgICAgIGluc3BlY3ROb2RlOiBpbnNwZWN0Tm9kZSxcbiAgICAgICAgICAgIGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eTogZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5LFxuICAgICAgICAgICAgY3JlYXRlVGVzdEVsZW1lbnQ6IGNyZWF0ZVRlc3RFbGVtZW50LFxuICAgICAgICAgICAgcmVtb3ZlTm9kZTogcmVtb3ZlTm9kZSxcbiAgICAgICAgICAgIGZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbjogZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuLFxuICAgICAgICAgICAgY3JlYXRlSXRlcmF0b3I6IGNyZWF0ZUl0ZXJhdG9yLFxuICAgICAgICAgICAgRG9tUG9zaXRpb246IERvbVBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgYXBpLkRPTUV4Y2VwdGlvbiA9IERPTUV4Y2VwdGlvbjtcbiAgICB9KTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8vIFB1cmUgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBET00gUmFuZ2VcbiAgICBhcGkuY3JlYXRlQ29yZU1vZHVsZShcIkRvbVJhbmdlXCIsIFtcIkRvbVV0aWxcIl0sIGZ1bmN0aW9uKGFwaSwgbW9kdWxlKSB7XG4gICAgICAgIHZhciBkb20gPSBhcGkuZG9tO1xuICAgICAgICB2YXIgdXRpbCA9IGFwaS51dGlsO1xuICAgICAgICB2YXIgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb247XG4gICAgICAgIHZhciBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uO1xuXG4gICAgICAgIHZhciBpc0NoYXJhY3RlckRhdGFOb2RlID0gZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGU7XG4gICAgICAgIHZhciBnZXROb2RlSW5kZXggPSBkb20uZ2V0Tm9kZUluZGV4O1xuICAgICAgICB2YXIgaXNPcklzQW5jZXN0b3JPZiA9IGRvbS5pc09ySXNBbmNlc3Rvck9mO1xuICAgICAgICB2YXIgZ2V0RG9jdW1lbnQgPSBkb20uZ2V0RG9jdW1lbnQ7XG4gICAgICAgIHZhciBjb21wYXJlUG9pbnRzID0gZG9tLmNvbXBhcmVQb2ludHM7XG4gICAgICAgIHZhciBzcGxpdERhdGFOb2RlID0gZG9tLnNwbGl0RGF0YU5vZGU7XG4gICAgICAgIHZhciBnZXRDbG9zZXN0QW5jZXN0b3JJbiA9IGRvbS5nZXRDbG9zZXN0QW5jZXN0b3JJbjtcbiAgICAgICAgdmFyIGdldE5vZGVMZW5ndGggPSBkb20uZ2V0Tm9kZUxlbmd0aDtcbiAgICAgICAgdmFyIGFycmF5Q29udGFpbnMgPSBkb20uYXJyYXlDb250YWlucztcbiAgICAgICAgdmFyIGdldFJvb3RDb250YWluZXIgPSBkb20uZ2V0Um9vdENvbnRhaW5lcjtcbiAgICAgICAgdmFyIGNyYXNoeVRleHROb2RlcyA9IGFwaS5mZWF0dXJlcy5jcmFzaHlUZXh0Tm9kZXM7XG5cbiAgICAgICAgdmFyIHJlbW92ZU5vZGUgPSBkb20ucmVtb3ZlTm9kZTtcblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgICAgICAgZnVuY3Rpb24gaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQobm9kZSwgcmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiAobm9kZS5ub2RlVHlwZSAhPSAzKSAmJlxuICAgICAgICAgICAgICAgICAgIChpc09ySXNBbmNlc3Rvck9mKG5vZGUsIHJhbmdlLnN0YXJ0Q29udGFpbmVyKSB8fCBpc09ySXNBbmNlc3Rvck9mKG5vZGUsIHJhbmdlLmVuZENvbnRhaW5lcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmFuZ2VEb2N1bWVudChyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmRvY3VtZW50IHx8IGdldERvY3VtZW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJhbmdlUm9vdChyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFJvb3RDb250YWluZXIocmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlCZWZvcmVOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9tUG9zaXRpb24obm9kZS5wYXJlbnROb2RlLCBnZXROb2RlSW5kZXgobm9kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihub2RlLnBhcmVudE5vZGUsIGdldE5vZGVJbmRleChub2RlKSArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0Tm9kZUF0UG9zaXRpb24obm9kZSwgbiwgbykge1xuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZUluc2VydGVkID0gbm9kZS5ub2RlVHlwZSA9PSAxMSA/IG5vZGUuZmlyc3RDaGlsZCA6IG5vZGU7XG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShuKSkge1xuICAgICAgICAgICAgICAgIGlmIChvID09IG4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5pbnNlcnRBZnRlcihub2RlLCBuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG8gPT0gMCA/IG4gOiBzcGxpdERhdGFOb2RlKG4sIG8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG8gPj0gbi5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG4uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uaW5zZXJ0QmVmb3JlKG5vZGUsIG4uY2hpbGROb2Rlc1tvXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlyc3ROb2RlSW5zZXJ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5nZXNJbnRlcnNlY3QocmFuZ2VBLCByYW5nZUIsIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQocmFuZ2VBKTtcbiAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQocmFuZ2VCKTtcblxuICAgICAgICAgICAgaWYgKGdldFJhbmdlRG9jdW1lbnQocmFuZ2VCKSAhPSBnZXRSYW5nZURvY3VtZW50KHJhbmdlQSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gY29tcGFyZVBvaW50cyhyYW5nZUEuc3RhcnRDb250YWluZXIsIHJhbmdlQS5zdGFydE9mZnNldCwgcmFuZ2VCLmVuZENvbnRhaW5lciwgcmFuZ2VCLmVuZE9mZnNldCksXG4gICAgICAgICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IGNvbXBhcmVQb2ludHMocmFuZ2VBLmVuZENvbnRhaW5lciwgcmFuZ2VBLmVuZE9mZnNldCwgcmFuZ2VCLnN0YXJ0Q29udGFpbmVyLCByYW5nZUIuc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdG91Y2hpbmdJc0ludGVyc2VjdGluZyA/IHN0YXJ0Q29tcGFyaXNvbiA8PSAwICYmIGVuZENvbXBhcmlzb24gPj0gMCA6IHN0YXJ0Q29tcGFyaXNvbiA8IDAgJiYgZW5kQ29tcGFyaXNvbiA+IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbG9uZVN1YnRyZWUoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsbHlTZWxlY3RlZDtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGUsIGZyYWcgPSBnZXRSYW5nZURvY3VtZW50KGl0ZXJhdG9yLnJhbmdlKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN1Ykl0ZXJhdG9yOyBub2RlID0gaXRlcmF0b3IubmV4dCgpOyApIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsbHlTZWxlY3RlZCA9IGl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2xvbmVOb2RlKCFwYXJ0aWFsbHlTZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Ykl0ZXJhdG9yID0gaXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2xvbmVTdWJ0cmVlKHN1Ykl0ZXJhdG9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHN1Ykl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEwKSB7IC8vIERvY3VtZW50VHlwZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlU3VidHJlZShyYW5nZUl0ZXJhdG9yLCBmdW5jLCBpdGVyYXRvclN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgaXQsIG47XG4gICAgICAgICAgICBpdGVyYXRvclN0YXRlID0gaXRlcmF0b3JTdGF0ZSB8fCB7IHN0b3A6IGZhbHNlIH07XG4gICAgICAgICAgICBmb3IgKHZhciBub2RlLCBzdWJSYW5nZUl0ZXJhdG9yOyBub2RlID0gcmFuZ2VJdGVyYXRvci5uZXh0KCk7ICkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmMobm9kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvclN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vZGUgaXMgcGFydGlhbGx5IHNlbGVjdGVkIGJ5IHRoZSBSYW5nZSwgc28gd2UgY2FuIHVzZSBhIG5ldyBSYW5nZUl0ZXJhdG9yIG9uIHRoZSBwb3J0aW9uIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbm9kZSBzZWxlY3RlZCBieSB0aGUgUmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZUl0ZXJhdG9yID0gcmFuZ2VJdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVTdWJ0cmVlKHN1YlJhbmdlSXRlcmF0b3IsIGZ1bmMsIGl0ZXJhdG9yU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViUmFuZ2VJdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvclN0YXRlLnN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd2hvbGUgbm9kZSBpcyBzZWxlY3RlZCwgc28gd2UgY2FuIHVzZSBlZmZpY2llbnQgRE9NIGl0ZXJhdGlvbiB0byBpdGVyYXRlIG92ZXIgdGhlIG5vZGUgYW5kIGl0c1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXNjZW5kYW50c1xuICAgICAgICAgICAgICAgICAgICBpdCA9IGRvbS5jcmVhdGVJdGVyYXRvcihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobiA9IGl0Lm5leHQoKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVuYyhuKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvclN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVN1YnRyZWUoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzdWJJdGVyYXRvcjtcbiAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJJdGVyYXRvciA9IGl0ZXJhdG9yLmdldFN1YnRyZWVJdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVTdWJ0cmVlKHN1Ykl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViSXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdFN1YnRyZWUoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGUsIGZyYWcgPSBnZXRSYW5nZURvY3VtZW50KGl0ZXJhdG9yLnJhbmdlKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN1Ykl0ZXJhdG9yOyBub2RlID0gaXRlcmF0b3IubmV4dCgpOyApIHtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5pc1BhcnRpYWxseVNlbGVjdGVkU3VidHJlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1Ykl0ZXJhdG9yID0gaXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZXh0cmFjdFN1YnRyZWUoc3ViSXRlcmF0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViSXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEwKSB7IC8vIERvY3VtZW50VHlwZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXROb2Rlc0luUmFuZ2UocmFuZ2UsIG5vZGVUeXBlcywgZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyTm9kZVR5cGVzID0gISEobm9kZVR5cGVzICYmIG5vZGVUeXBlcy5sZW5ndGgpLCByZWdleDtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJFeGlzdHMgPSAhIWZpbHRlcjtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJOb2RlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgbm9kZVR5cGVzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgICBpdGVyYXRlU3VidHJlZShuZXcgUmFuZ2VJdGVyYXRvcihyYW5nZSwgZmFsc2UpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlck5vZGVUeXBlcyAmJiAhcmVnZXgudGVzdChub2RlLm5vZGVUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJFeGlzdHMgJiYgIWZpbHRlcihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERvbid0IGluY2x1ZGUgYSBib3VuZGFyeSBjb250YWluZXIgaWYgaXQgaXMgYSBjaGFyYWN0ZXIgZGF0YSBub2RlIGFuZCB0aGUgcmFuZ2UgZG9lcyBub3QgY29udGFpbiBhbnlcbiAgICAgICAgICAgICAgICAvLyBvZiBpdHMgY2hhcmFjdGVyIGRhdGEuIFNlZSBpc3N1ZSAxOTAuXG4gICAgICAgICAgICAgICAgdmFyIHNjID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gc2MgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShzYykgJiYgcmFuZ2Uuc3RhcnRPZmZzZXQgPT0gc2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZWMgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gZWMgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShlYykgJiYgcmFuZ2UuZW5kT2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluc3BlY3QocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gKHR5cGVvZiByYW5nZS5nZXROYW1lID09IFwidW5kZWZpbmVkXCIpID8gXCJSYW5nZVwiIDogcmFuZ2UuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgbmFtZSArIFwiKFwiICsgZG9tLmluc3BlY3ROb2RlKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSArIFwiOlwiICsgcmFuZ2Uuc3RhcnRPZmZzZXQgKyBcIiwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBkb20uaW5zcGVjdE5vZGUocmFuZ2UuZW5kQ29udGFpbmVyKSArIFwiOlwiICsgcmFuZ2UuZW5kT2Zmc2V0ICsgXCIpXVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBSYW5nZUl0ZXJhdG9yIGNvZGUgcGFydGlhbGx5IGJvcnJvd3MgZnJvbSBJRVJhbmdlIGJ5IFRpbSBSeWFuIChodHRwOi8vZ2l0aHViLmNvbS90aW1jYW1lcm9ucnlhbi9JRVJhbmdlKVxuXG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlSXRlcmF0b3IocmFuZ2UsIGNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgIHRoaXMuY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2RlcyA9IGNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXM7XG5cblxuICAgICAgICAgICAgaWYgKCFyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5zbyA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuZWMgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbyA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2MgPT09IHRoaXMuZWMgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLnNjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2xhc3QgPSB0aGlzLl9uZXh0ID0gdGhpcy5zYztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX25leHQgPSAodGhpcy5zYyA9PT0gcm9vdCAmJiAhaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLnNjKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYy5jaGlsZE5vZGVzW3RoaXMuc29dIDogZ2V0Q2xvc2VzdEFuY2VzdG9ySW4odGhpcy5zYywgcm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3QgPSAodGhpcy5lYyA9PT0gcm9vdCAmJiAhaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLmVjKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lYy5jaGlsZE5vZGVzW3RoaXMuZW8gLSAxXSA6IGdldENsb3Nlc3RBbmNlc3RvckluKHRoaXMuZWMsIHJvb3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJhbmdlSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgX2N1cnJlbnQ6IG51bGwsXG4gICAgICAgICAgICBfbmV4dDogbnVsbCxcbiAgICAgICAgICAgIF9maXJzdDogbnVsbCxcbiAgICAgICAgICAgIF9sYXN0OiBudWxsLFxuICAgICAgICAgICAgaXNTaW5nbGVDaGFyYWN0ZXJEYXRhTm9kZTogZmFsc2UsXG5cbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0ID0gdGhpcy5fZmlyc3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYXNOZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9uZXh0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byBuZXh0IG5vZGVcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHQgPSAoY3VycmVudCAhPT0gdGhpcy5fbGFzdCkgPyBjdXJyZW50Lm5leHRTaWJsaW5nIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgcGFydGlhbGx5IHNlbGVjdGVkIHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyRGF0YU5vZGUoY3VycmVudCkgJiYgdGhpcy5jbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5lYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5jbG9uZU5vZGUodHJ1ZSkpLmRlbGV0ZURhdGEodGhpcy5lbywgY3VycmVudC5sZW5ndGggLSB0aGlzLmVvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50ID09PSB0aGlzLnNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmNsb25lTm9kZSh0cnVlKSkuZGVsZXRlRGF0YSgwLCB0aGlzLnNvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQsIHN0YXJ0LCBlbmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShjdXJyZW50KSAmJiAoY3VycmVudCA9PT0gdGhpcy5zYyB8fCBjdXJyZW50ID09PSB0aGlzLmVjKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChjdXJyZW50ID09PSB0aGlzLnNjKSA/IHRoaXMuc28gOiAwO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSAoY3VycmVudCA9PT0gdGhpcy5lYykgPyB0aGlzLmVvIDogY3VycmVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGVsZXRlRGF0YShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIENoZWNrcyBpZiB0aGUgY3VycmVudCBub2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZFxuICAgICAgICAgICAgaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoY3VycmVudCwgdGhpcy5yYW5nZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRTdWJ0cmVlSXRlcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJSYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YlJhbmdlID0gdGhpcy5yYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YlJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZSA9IG5ldyBSYW5nZShnZXRSYW5nZURvY3VtZW50KHRoaXMucmFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb250YWluZXIgPSBjdXJyZW50LCBzdGFydE9mZnNldCA9IDAsIGVuZENvbnRhaW5lciA9IGN1cnJlbnQsIGVuZE9mZnNldCA9IGdldE5vZGVMZW5ndGgoY3VycmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT3JJc0FuY2VzdG9yT2YoY3VycmVudCwgdGhpcy5zYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gdGhpcy5zYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gdGhpcy5zbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPcklzQW5jZXN0b3JPZihjdXJyZW50LCB0aGlzLmVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gdGhpcy5lYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mZnNldCA9IHRoaXMuZW87XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCb3VuZGFyaWVzKHN1YlJhbmdlLCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUl0ZXJhdG9yKHN1YlJhbmdlLCB0aGlzLmNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGV0YWNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQgPSB0aGlzLl9maXJzdCA9IHRoaXMuX2xhc3QgPSB0aGlzLnNjID0gdGhpcy5zbyA9IHRoaXMuZWMgPSB0aGlzLmVvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIHZhciBiZWZvcmVBZnRlck5vZGVUeXBlcyA9IFsxLCAzLCA0LCA1LCA3LCA4LCAxMF07XG4gICAgICAgIHZhciByb290Q29udGFpbmVyTm9kZVR5cGVzID0gWzIsIDksIDExXTtcbiAgICAgICAgdmFyIHJlYWRvbmx5Tm9kZVR5cGVzID0gWzUsIDYsIDEwLCAxMl07XG4gICAgICAgIHZhciBpbnNlcnRhYmxlTm9kZVR5cGVzID0gWzEsIDMsIDQsIDUsIDcsIDgsIDEwLCAxMV07XG4gICAgICAgIHZhciBzdXJyb3VuZE5vZGVUeXBlcyA9IFsxLCAzLCA0LCA1LCA3LCA4XTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVBbmNlc3RvckZpbmRlcihub2RlVHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBzZWxmSXNBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciB0LCBuID0gc2VsZklzQW5jZXN0b3IgPyBub2RlIDogbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuLm5vZGVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlDb250YWlucyhub2RlVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0RG9jdW1lbnRPckZyYWdtZW50Q29udGFpbmVyID0gY3JlYXRlQW5jZXN0b3JGaW5kZXIoIFs5LCAxMV0gKTtcbiAgICAgICAgdmFyIGdldFJlYWRvbmx5QW5jZXN0b3IgPSBjcmVhdGVBbmNlc3RvckZpbmRlcihyZWFkb25seU5vZGVUeXBlcyk7XG4gICAgICAgIHZhciBnZXREb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKCBbNiwgMTAsIDEyXSApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgYWxsb3dTZWxmKSB7XG4gICAgICAgICAgICBpZiAoZ2V0RG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgYWxsb3dTZWxmKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX05PREVfVFlQRV9FUlJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIGludmFsaWRUeXBlcykge1xuICAgICAgICAgICAgaWYgKCFhcnJheUNvbnRhaW5zKGludmFsaWRUeXBlcywgbm9kZS5ub2RlVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSA/IG5vZGUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5ERVhfU0laRV9FUlJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KG5vZGUxLCBub2RlMikge1xuICAgICAgICAgICAgaWYgKGdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lcihub2RlMSwgdHJ1ZSkgIT09IGdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lcihub2RlMiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChnZXRSZWFkb25seUFuY2VzdG9yKG5vZGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIk5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSwgY29kZU5hbWUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oY29kZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQgPD0gKGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkgPyBub2RlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNSYW5nZVZhbGlkKHJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCEhcmFuZ2Uuc3RhcnRDb250YWluZXIgJiYgISFyYW5nZS5lbmRDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIShjcmFzaHlUZXh0Tm9kZXMgJiYgKGRvbS5pc0Jyb2tlbk5vZGUocmFuZ2Uuc3RhcnRDb250YWluZXIpIHx8IGRvbS5pc0Jyb2tlbk5vZGUocmFuZ2UuZW5kQ29udGFpbmVyKSkpICYmXG4gICAgICAgICAgICAgICAgICAgIGdldFJvb3RDb250YWluZXIocmFuZ2Uuc3RhcnRDb250YWluZXIpID09IGdldFJvb3RDb250YWluZXIocmFuZ2UuZW5kQ29udGFpbmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkT2Zmc2V0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZE9mZnNldChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0UmFuZ2VWYWxpZChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKCFpc1JhbmdlVmFsaWQocmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgZXJyb3I6IFJhbmdlIGlzIG5vdCB2YWxpZC4gVGhpcyB1c3VhbGx5IGhhcHBlbnMgYWZ0ZXIgRE9NIG11dGF0aW9uLiBSYW5nZTogKFwiICsgcmFuZ2UuaW5zcGVjdCgpICsgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBUZXN0IHRoZSBicm93c2VyJ3MgaW5uZXJIVE1MIHN1cHBvcnQgdG8gZGVjaWRlIGhvdyB0byBpbXBsZW1lbnQgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XG4gICAgICAgIHZhciBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICB2YXIgaHRtbFBhcnNpbmdDb25mb3JtcyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3R5bGVFbC5pbm5lckhUTUwgPSBcIjxiPng8L2I+XCI7XG4gICAgICAgICAgICBodG1sUGFyc2luZ0NvbmZvcm1zID0gKHN0eWxlRWwuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKTsgLy8gT3BlcmEgaW5jb3JyZWN0bHkgY3JlYXRlcyBhbiBlbGVtZW50IG5vZGVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSUUgNiBhbmQgNyB0aHJvd1xuICAgICAgICB9XG5cbiAgICAgICAgYXBpLmZlYXR1cmVzLmh0bWxQYXJzaW5nQ29uZm9ybXMgPSBodG1sUGFyc2luZ0NvbmZvcm1zO1xuXG4gICAgICAgIHZhciBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgPSBodG1sUGFyc2luZ0NvbmZvcm1zID9cblxuICAgICAgICAgICAgLy8gSW1wbGVtZW50YXRpb24gYXMgcGVyIEhUTUwgcGFyc2luZyBzcGVjLCB0cnVzdGluZyBpbiB0aGUgYnJvd3NlcidzIGltcGxlbWVudGF0aW9uIG9mIGlubmVySFRNTC4gU2VlXG4gICAgICAgICAgICAvLyBkaXNjdXNzaW9uIGFuZCBiYXNlIGNvZGUgZm9yIHRoaXMgaW1wbGVtZW50YXRpb24gYXQgaXNzdWUgNjcuXG4gICAgICAgICAgICAvLyBTcGVjOiBodHRwOi8vaHRtbDUub3JnL3NwZWNzL2RvbS1wYXJzaW5nLmh0bWwjZXh0ZW5zaW9ucy10by10aGUtcmFuZ2UtaW50ZXJmYWNlXG4gICAgICAgICAgICAvLyBUaGFua3MgdG8gQWxla3MgV2lsbGlhbXMuXG4gICAgICAgICAgICBmdW5jdGlvbihmcmFnbWVudFN0cikge1xuICAgICAgICAgICAgICAgIC8vIFwiTGV0IG5vZGUgdGhlIGNvbnRleHQgb2JqZWN0J3Mgc3RhcnQncyBub2RlLlwiXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChub2RlKTtcblxuICAgICAgICAgICAgICAgIC8vIFwiSWYgdGhlIGNvbnRleHQgb2JqZWN0J3Mgc3RhcnQncyBub2RlIGlzIG51bGwsIHJhaXNlIGFuIElOVkFMSURfU1RBVEVfRVJSXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cIlxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gXCJMZXQgZWxlbWVudCBiZSBhcyBmb2xsb3dzLCBkZXBlbmRpbmcgb24gbm9kZSdzIGludGVyZmFjZTpcIlxuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50LCBEb2N1bWVudCBGcmFnbWVudDogbnVsbFxuICAgICAgICAgICAgICAgIHZhciBlbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBcIkVsZW1lbnQ6IG5vZGVcIlxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gXCJUZXh0LCBDb21tZW50OiBub2RlJ3MgcGFyZW50RWxlbWVudFwiXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gZG9tLnBhcmVudEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gXCJJZiBlaXRoZXIgZWxlbWVudCBpcyBudWxsIG9yIGVsZW1lbnQncyBvd25lckRvY3VtZW50IGlzIGFuIEhUTUwgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBhbmQgZWxlbWVudCdzIGxvY2FsIG5hbWUgaXMgXCJodG1sXCIgYW5kIGVsZW1lbnQncyBuYW1lc3BhY2UgaXMgdGhlIEhUTUxcbiAgICAgICAgICAgICAgICAvLyBuYW1lc3BhY2VcIlxuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gbnVsbCB8fCAoXG4gICAgICAgICAgICAgICAgICAgIGVsLm5vZGVOYW1lID09IFwiSFRNTFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5pc0h0bWxOYW1lc3BhY2UoZ2V0RG9jdW1lbnQoZWwpLmRvY3VtZW50RWxlbWVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9tLmlzSHRtbE5hbWVzcGFjZShlbClcbiAgICAgICAgICAgICAgICApKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBcImxldCBlbGVtZW50IGJlIGEgbmV3IEVsZW1lbnQgd2l0aCBcImJvZHlcIiBhcyBpdHMgbG9jYWwgbmFtZSBhbmQgdGhlIEhUTUxcbiAgICAgICAgICAgICAgICAvLyBuYW1lc3BhY2UgYXMgaXRzIG5hbWVzcGFjZS5cIlwiXG4gICAgICAgICAgICAgICAgICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gZWwuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBcIklmIHRoZSBub2RlJ3MgZG9jdW1lbnQgaXMgYW4gSFRNTCBkb2N1bWVudDogSW52b2tlIHRoZSBIVE1MIGZyYWdtZW50IHBhcnNpbmcgYWxnb3JpdGhtLlwiXG4gICAgICAgICAgICAgICAgLy8gXCJJZiB0aGUgbm9kZSdzIGRvY3VtZW50IGlzIGFuIFhNTCBkb2N1bWVudDogSW52b2tlIHRoZSBYTUwgZnJhZ21lbnQgcGFyc2luZyBhbGdvcml0aG0uXCJcbiAgICAgICAgICAgICAgICAvLyBcIkluIGVpdGhlciBjYXNlLCB0aGUgYWxnb3JpdGhtIG11c3QgYmUgaW52b2tlZCB3aXRoIGZyYWdtZW50IGFzIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgIC8vIGFuZCBlbGVtZW50IGFzIHRoZSBjb250ZXh0IGVsZW1lbnQuXCJcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBmcmFnbWVudFN0cjtcblxuICAgICAgICAgICAgICAgIC8vIFwiSWYgdGhpcyByYWlzZXMgYW4gZXhjZXB0aW9uLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLiBPdGhlcndpc2UsIGxldCBuZXdcbiAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiBiZSB0aGUgbm9kZXMgcmV0dXJuZWQuXCJcblxuICAgICAgICAgICAgICAgIC8vIFwiTGV0IGZyYWdtZW50IGJlIGEgbmV3IERvY3VtZW50RnJhZ21lbnQuXCJcbiAgICAgICAgICAgICAgICAvLyBcIkFwcGVuZCBhbGwgbmV3IGNoaWxkcmVuIHRvIGZyYWdtZW50LlwiXG4gICAgICAgICAgICAgICAgLy8gXCJSZXR1cm4gZnJhZ21lbnQuXCJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbihlbCk7XG4gICAgICAgICAgICB9IDpcblxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpbm5lckhUTUwgY2Fubm90IGJlIHRydXN0ZWQsIHNvIGZhbGwgYmFjayB0byBhIHNpbXBsZXIsIG5vbi1jb25mb3JtYW50IGltcGxlbWVudGF0aW9uIHRoYXRcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHZlcnNpb25zIG9mIFJhbmd5IHVzZWQgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB1c2luZyBhIGJvZHkgZWxlbWVudCByYXRoZXIgdGhhbiBhIGRpdilcbiAgICAgICAgICAgIGZ1bmN0aW9uKGZyYWdtZW50U3RyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGdldFJhbmdlRG9jdW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGZyYWdtZW50U3RyO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbS5mcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4oZWwpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzcGxpdFJhbmdlQm91bmRhcmllcyhyYW5nZSwgcG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZChyYW5nZSk7XG5cbiAgICAgICAgICAgIHZhciBzYyA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBzbyA9IHJhbmdlLnN0YXJ0T2Zmc2V0LCBlYyA9IHJhbmdlLmVuZENvbnRhaW5lciwgZW8gPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbmRTYW1lID0gKHNjID09PSBlYyk7XG5cbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKGVjKSAmJiBlbyA+IDAgJiYgZW8gPCBlYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGxpdERhdGFOb2RlKGVjLCBlbywgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKHNjKSAmJiBzbyA+IDAgJiYgc28gPCBzYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzYyA9IHNwbGl0RGF0YU5vZGUoc2MsIHNvLCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRFbmRTYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGVvIC09IHNvO1xuICAgICAgICAgICAgICAgICAgICBlYyA9IHNjO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWMgPT0gc2MucGFyZW50Tm9kZSAmJiBlbyA+PSBnZXROb2RlSW5kZXgoc2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVvKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QW5kRW5kKHNjLCBzbywgZWMsIGVvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmdlVG9IdG1sKHJhbmdlKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHJhbmdlKTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5wYXJlbnROb2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoIHJhbmdlLmNsb25lQ29udGVudHMoKSApO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgIH1cblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIHZhciByYW5nZVByb3BlcnRpZXMgPSBbXCJzdGFydENvbnRhaW5lclwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwiZW5kQ29udGFpbmVyXCIsIFwiZW5kT2Zmc2V0XCIsIFwiY29sbGFwc2VkXCIsXG4gICAgICAgICAgICBcImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyXCJdO1xuXG4gICAgICAgIHZhciBzMnMgPSAwLCBzMmUgPSAxLCBlMmUgPSAyLCBlMnMgPSAzO1xuICAgICAgICB2YXIgbl9iID0gMCwgbl9hID0gMSwgbl9iX2EgPSAyLCBuX2kgPSAzO1xuXG4gICAgICAgIHV0aWwuZXh0ZW5kKGFwaS5yYW5nZVByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29tcGFyZUJvdW5kYXJ5UG9pbnRzOiBmdW5jdGlvbihob3csIHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KHRoaXMuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgIHZhciBub2RlQSwgb2Zmc2V0QSwgbm9kZUIsIG9mZnNldEI7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeEEgPSAoaG93ID09IGUycyB8fCBob3cgPT0gczJzKSA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeEIgPSAoaG93ID09IHMyZSB8fCBob3cgPT0gczJzKSA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgbm9kZUEgPSB0aGlzW3ByZWZpeEEgKyBcIkNvbnRhaW5lclwiXTtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gdGhpc1twcmVmaXhBICsgXCJPZmZzZXRcIl07XG4gICAgICAgICAgICAgICAgbm9kZUIgPSByYW5nZVtwcmVmaXhCICsgXCJDb250YWluZXJcIl07XG4gICAgICAgICAgICAgICAgb2Zmc2V0QiA9IHJhbmdlW3ByZWZpeEIgKyBcIk9mZnNldFwiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhub2RlQSwgb2Zmc2V0QSwgbm9kZUIsIG9mZnNldEIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBpbnNlcnRhYmxlTm9kZVR5cGVzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnROb2RlTm90UmVhZE9ubHkodGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPcklzQW5jZXN0b3JPZihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE5vIGNoZWNrIGZvciB3aGV0aGVyIHRoZSBjb250YWluZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSBSYW5nZSBpcyBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhbGxvd1xuICAgICAgICAgICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSB0eXBlIG9mIG5vZGU6IHRoZSBicm93c2VyJ3MgRE9NIGltcGxlbWVudGF0aW9uIHNob3VsZCBkbyB0aGlzIGZvciB1cyB3aGVuIHdlIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAvLyB0byBhZGQgdGhlIG5vZGVcblxuICAgICAgICAgICAgICAgIHZhciBmaXJzdE5vZGVJbnNlcnRlZCA9IGluc2VydE5vZGVBdFBvc2l0aW9uKG5vZGUsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnRCZWZvcmUoZmlyc3ROb2RlSW5zZXJ0ZWQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xvbmVDb250ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBjbG9uZSwgZnJhZztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhbmdlRG9jdW1lbnQodGhpcykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVuZENvbnRhaW5lciAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHRoaXMuc3RhcnRDb250YWluZXIuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuZGF0YSA9IGNsb25lLmRhdGEuc2xpY2UodGhpcy5zdGFydE9mZnNldCwgdGhpcy5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGdldFJhbmdlRG9jdW1lbnQodGhpcykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBjbG9uZVN1YnRyZWUoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhblN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLmVuZENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudHMgY2FuIGJlIHN1cnJvdW5kZWQuIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB3aGV0aGVyIHRoZSByYW5nZSBwYXJ0aWFsbHkgc2VsZWN0c1xuICAgICAgICAgICAgICAgIC8vIG5vIG5vbi10ZXh0IG5vZGVzLlxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyaWVzSW52YWxpZCA9IChpdGVyYXRvci5fZmlyc3QgJiYgKGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpKSk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFib3VuZGFyaWVzSW52YWxpZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIHN1cnJvdW5kTm9kZVR5cGVzKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYW5TdXJyb3VuZENvbnRlbnRzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmV4dHJhY3RDb250ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNoaWxkcmVuIG9mIHRoZSBub2RlXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBub2RlIGFuZCBhZGQgdGhlIGV4dHJhY3RlZCBjb250ZW50c1xuICAgICAgICAgICAgICAgIGluc2VydE5vZGVBdFBvc2l0aW9uKG5vZGUsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbG9uZVJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShnZXRSYW5nZURvY3VtZW50KHRoaXMpKTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsIHByb3A7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wID0gcmFuZ2VQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByYW5nZVtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgaWYgKHNjID09PSB0aGlzLmVuZENvbnRhaW5lciAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKHNjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNjLm5vZGVUeXBlID09IDMgfHwgc2Mubm9kZVR5cGUgPT0gNCkgPyBzYy5kYXRhLnNsaWNlKHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuZW5kT2Zmc2V0KSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRQYXJ0cyA9IFtdLCBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU3VidHJlZShpdGVyYXRvciwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXB0IG9ubHkgdGV4dCBvciBDREFUQSBub2Rlcywgbm90IGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzIHx8IG5vZGUubm9kZVR5cGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQYXJ0cy5wdXNoKG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRQYXJ0cy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRoZSBtZXRob2RzIGJlbG93IGFyZSBhbGwgbm9uLXN0YW5kYXJkLiBUaGUgZm9sbG93aW5nIGJhdGNoIHdlcmUgaW50cm9kdWNlZCBieSBNb3ppbGxhIGJ1dCBoYXZlIHNpbmNlXG4gICAgICAgICAgICAvLyBiZWVuIHJlbW92ZWQgZnJvbSBNb3ppbGxhLlxuXG4gICAgICAgICAgICBjb21wYXJlTm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBnZXROb2RlSW5kZXgobm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiTk9UX0ZPVU5EX0VSUlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gdGhpcy5jb21wYXJlUG9pbnQocGFyZW50LCBub2RlSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb21wYXJpc29uID0gdGhpcy5jb21wYXJlUG9pbnQocGFyZW50LCBub2RlSW5kZXggKyAxKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGFydENvbXBhcmlzb24gPCAwKSB7IC8vIE5vZGUgc3RhcnRzIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVuZENvbXBhcmlzb24gPiAwKSA/IG5fYl9hIDogbl9iO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZW5kQ29tcGFyaXNvbiA+IDApID8gbl9hIDogbl9pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbXBhcmVQb2ludDogZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnROb2RlKG5vZGUsIFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50OiBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQsXG5cbiAgICAgICAgICAgIHRvSHRtbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9IdG1sKHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gdG91Y2hpbmdJc0ludGVyc2VjdGluZyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBtZXRob2QgY29uc2lkZXJzIGEgbm9kZSB0aGF0IGJvcmRlcnMgYSByYW5nZSBpbnRlcnNlY3RzXG4gICAgICAgICAgICAvLyB3aXRoIGl0IChhcyBpbiBXZWJLaXQpIG9yIG5vdCAoYXMgaW4gR2Vja28gcHJlLTEuOSwgYW5kIHRoZSBkZWZhdWx0KVxuICAgICAgICAgICAgaW50ZXJzZWN0c05vZGU6IGZ1bmN0aW9uKG5vZGUsIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRSb290Q29udGFpbmVyKG5vZGUpICE9IGdldFJhbmdlUm9vdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSwgb2Zmc2V0ID0gZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSBjb21wYXJlUG9pbnRzKHBhcmVudCwgb2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb21wYXJpc29uID0gY29tcGFyZVBvaW50cyhwYXJlbnQsIG9mZnNldCArIDEsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcgPyBzdGFydENvbXBhcmlzb24gPD0gMCAmJiBlbmRDb21wYXJpc29uID49IDAgOiBzdGFydENvbXBhcmlzb24gPCAwICYmIGVuZENvbXBhcmlzb24gPiAwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNQb2ludEluUmFuZ2U6IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KG5vZGUsIHRoaXMuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCkgPj0gMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpIDw9IDApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gVGhlIG1ldGhvZHMgYmVsb3cgYXJlIG5vbi1zdGFuZGFyZCBhbmQgaW52ZW50ZWQgYnkgbWUuXG5cbiAgICAgICAgICAgIC8vIFNoYXJpbmcgYSBib3VuZGFyeSBzdGFydC10by1lbmQgb3IgZW5kLXRvLXN0YXJ0IGRvZXMgbm90IGNvdW50IGFzIGludGVyc2VjdGlvbi5cbiAgICAgICAgICAgIGludGVyc2VjdHNSYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzSW50ZXJzZWN0KHRoaXMsIHJhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBTaGFyaW5nIGEgYm91bmRhcnkgc3RhcnQtdG8tZW5kIG9yIGVuZC10by1zdGFydCBkb2VzIGNvdW50IGFzIGludGVyc2VjdGlvbi5cbiAgICAgICAgICAgIGludGVyc2VjdHNPclRvdWNoZXNSYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzSW50ZXJzZWN0KHRoaXMsIHJhbmdlLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RzUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSBjb21wYXJlUG9pbnRzKHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDb21wYXJpc29uID0gY29tcGFyZVBvaW50cyh0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQsIHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29tcGFyaXNvbiA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kQ29tcGFyaXNvbiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25SYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bmlvbjogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RzT3JUb3VjaGVzUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmlvblJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlUG9pbnRzKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaW9uUmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlvblJhbmdlLnNldEVuZChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuaW9uUmFuZ2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIlJhbmdlcyBkbyBub3QgaW50ZXJzZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbnRhaW5zTm9kZTogZnVuY3Rpb24obm9kZSwgYWxsb3dQYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93UGFydGlhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzTm9kZShub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZU5vZGUobm9kZSkgPT0gbl9pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbnRhaW5zTm9kZUNvbnRlbnRzOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVBvaW50KG5vZGUsIDApID49IDAgJiYgdGhpcy5jb21wYXJlUG9pbnQobm9kZSwgZ2V0Tm9kZUxlbmd0aChub2RlKSkgPD0gMDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbnRhaW5zUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMuaW50ZXJzZWN0aW9uKHJhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uICE9PSBudWxsICYmIHJhbmdlLmVxdWFscyhpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29udGFpbnNOb2RlVGV4dDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBub2RlUmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGVzID0gbm9kZVJhbmdlLmdldE5vZGVzKFszXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVSYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZXNbMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFRleHROb2RlID0gdGV4dE5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlUmFuZ2Uuc2V0RW5kKGxhc3RUZXh0Tm9kZSwgbGFzdFRleHROb2RlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zUmFuZ2Uobm9kZVJhbmdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc05vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXROb2RlczogZnVuY3Rpb24obm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2Rlc0luUmFuZ2UodGhpcywgbm9kZVR5cGVzLCBmaWx0ZXIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYW5nZURvY3VtZW50KHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29sbGFwc2VCZWZvcmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbGxhcHNlQWZ0ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEJvb2ttYXJrOiBmdW5jdGlvbihjb250YWluZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGdldFJhbmdlRG9jdW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIHByZVNlbGVjdGlvblJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyTm9kZSA9IGNvbnRhaW5lck5vZGUgfHwgZG9tLmdldEJvZHkoZG9jKTtcbiAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb25SYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoY29udGFpbmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5pbnRlcnNlY3Rpb24ocHJlU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDAsIGVuZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVNlbGVjdGlvblJhbmdlLnNldEVuZChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHByZVNlbGVjdGlvblJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIHJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck5vZGU6IGNvbnRhaW5lck5vZGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbW92ZVRvQm9va21hcms6IGZ1bmN0aW9uKGJvb2ttYXJrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lck5vZGUgPSBib29rbWFyay5jb250YWluZXJOb2RlO1xuICAgICAgICAgICAgICAgIHZhciBjaGFySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnQoY29udGFpbmVyTm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVN0YWNrID0gW2NvbnRhaW5lck5vZGVdLCBub2RlLCBmb3VuZFN0YXJ0ID0gZmFsc2UsIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXJJbmRleCwgaSwgY2hpbGROb2RlcztcblxuICAgICAgICAgICAgICAgIHdoaWxlICghc3RvcCAmJiAobm9kZSA9IG5vZGVTdGFjay5wb3AoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENoYXJJbmRleCA9IGNoYXJJbmRleCArIG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJ0ICYmIGJvb2ttYXJrLnN0YXJ0ID49IGNoYXJJbmRleCAmJiBib29rbWFyay5zdGFydCA8PSBuZXh0Q2hhckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGFydChub2RlLCBib29rbWFyay5zdGFydCAtIGNoYXJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGFydCAmJiBib29rbWFyay5lbmQgPj0gY2hhckluZGV4ICYmIGJvb2ttYXJrLmVuZCA8PSBuZXh0Q2hhckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbmQobm9kZSwgYm9va21hcmsuZW5kIC0gY2hhckluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJJbmRleCA9IG5leHRDaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVTdGFjay5wdXNoKGNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiRG9tUmFuZ2VcIjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmFuZ2UucmFuZ2VzRXF1YWwodGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluc3BlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGV0YWNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBET000LCBkZXRhY2goKSBpcyBub3cgYSBuby1vcC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChvYmopIHtcbiAgICAgICAgICAgIG9iai5TVEFSVF9UT19TVEFSVCA9IHMycztcbiAgICAgICAgICAgIG9iai5TVEFSVF9UT19FTkQgPSBzMmU7XG4gICAgICAgICAgICBvYmouRU5EX1RPX0VORCA9IGUyZTtcbiAgICAgICAgICAgIG9iai5FTkRfVE9fU1RBUlQgPSBlMnM7XG5cbiAgICAgICAgICAgIG9iai5OT0RFX0JFRk9SRSA9IG5fYjtcbiAgICAgICAgICAgIG9iai5OT0RFX0FGVEVSID0gbl9hO1xuICAgICAgICAgICAgb2JqLk5PREVfQkVGT1JFX0FORF9BRlRFUiA9IG5fYl9hO1xuICAgICAgICAgICAgb2JqLk5PREVfSU5TSURFID0gbl9pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29weUNvbXBhcmlzb25Db25zdGFudHMoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzVG9PYmplY3QoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2VDb250ZW50UmVtb3ZlcihyZW1vdmVyLCBib3VuZGFyeVVwZGF0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjID0gdGhpcy5zdGFydENvbnRhaW5lciwgc28gPSB0aGlzLnN0YXJ0T2Zmc2V0LCByb290ID0gdGhpcy5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gV29yayBvdXQgd2hlcmUgdG8gcG9zaXRpb24gdGhlIHJhbmdlIGFmdGVyIGNvbnRlbnQgcmVtb3ZhbFxuICAgICAgICAgICAgICAgIHZhciBub2RlLCBib3VuZGFyeTtcbiAgICAgICAgICAgICAgICBpZiAoc2MgIT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGdldENsb3Nlc3RBbmNlc3RvckluKHNjLCByb290LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkgPSBnZXRCb3VuZGFyeUFmdGVyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBib3VuZGFyeS5ub2RlO1xuICAgICAgICAgICAgICAgICAgICBzbyA9IGJvdW5kYXJ5Lm9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBub25lIG9mIHRoZSByYW5nZSBpcyByZWFkLW9ubHlcbiAgICAgICAgICAgICAgICBpdGVyYXRlU3VidHJlZShpdGVyYXRvciwgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KTtcblxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZW1vdmVyKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5kZXRhY2goKTtcblxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzYywgc28sIHNjLCBzbyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvdG90eXBlUmFuZ2UoY29uc3RydWN0b3IsIGJvdW5kYXJ5VXBkYXRlcikge1xuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGlzQmVmb3JlLCBpc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBiZWZvcmVBZnRlck5vZGVUeXBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUoZ2V0Um9vdENvbnRhaW5lcihub2RlKSwgcm9vdENvbnRhaW5lck5vZGVUeXBlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gKGlzQmVmb3JlID8gZ2V0Qm91bmRhcnlCZWZvcmVOb2RlIDogZ2V0Qm91bmRhcnlBZnRlck5vZGUpKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAoaXNTdGFydCA/IHNldFJhbmdlU3RhcnQgOiBzZXRSYW5nZUVuZCkodGhpcywgYm91bmRhcnkubm9kZSwgYm91bmRhcnkub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRSYW5nZVN0YXJ0KHJhbmdlLCBub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWMgPSByYW5nZS5lbmRDb250YWluZXIsIGVvID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSByYW5nZS5zdGFydENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLnN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByb290IGNvbnRhaW5lcnMgb2YgdGhlIHJhbmdlIGFuZCB0aGUgbmV3IGJvdW5kYXJ5LCBhbmQgYWxzbyBjaGVjayB3aGV0aGVyIHRoZSBuZXcgYm91bmRhcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYWZ0ZXIgdGhlIGN1cnJlbnQgZW5kLiBJbiBlaXRoZXIgY2FzZSwgY29sbGFwc2UgdGhlIHJhbmdlIHRvIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldFJvb3RDb250YWluZXIobm9kZSkgIT0gZ2V0Um9vdENvbnRhaW5lcihlYykgfHwgY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIGVjLCBlbykgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWMgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW8gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHJhbmdlLCBub2RlLCBvZmZzZXQsIGVjLCBlbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRSYW5nZUVuZChyYW5nZSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIHNvID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHJhbmdlLmVuZENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLmVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcm9vdCBjb250YWluZXJzIG9mIHRoZSByYW5nZSBhbmQgdGhlIG5ldyBib3VuZGFyeSwgYW5kIGFsc28gY2hlY2sgd2hldGhlciB0aGUgbmV3IGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFmdGVyIHRoZSBjdXJyZW50IGVuZC4gSW4gZWl0aGVyIGNhc2UsIGNvbGxhcHNlIHRoZSByYW5nZSB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRSb290Q29udGFpbmVyKG5vZGUpICE9IGdldFJvb3RDb250YWluZXIoc2MpIHx8IGNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCBzYywgc28pID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbyA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIHNjLCBzbywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB1cCBpbmhlcml0YW5jZVxuICAgICAgICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBhcGkucmFuZ2VQcm90b3R5cGU7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgICAgICAgICB1dGlsLmV4dGVuZChjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBzZXRTdGFydDogZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0UmFuZ2VTdGFydCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXRFbmQ6IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFJhbmdlRW5kKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBzZXQgYSByYW5nZSdzIHN0YXJ0IGFuZCBlbmQgYm91bmRhcmllcy4gT3ZlcmxvYWRlZCBhcyBmb2xsb3dzOlxuICAgICAgICAgICAgICAgICAqIC0gVHdvIHBhcmFtZXRlcnMgKG5vZGUsIG9mZnNldCkgY3JlYXRlcyBhIGNvbGxhcHNlZCByYW5nZSBhdCB0aGF0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICogLSBUaHJlZSBwYXJhbWV0ZXJzIChub2RlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSBjcmVhdGVzIGEgcmFuZ2UgY29udGFpbmVkIHdpdGggbm9kZSBzdGFydGluZyBhdFxuICAgICAgICAgICAgICAgICAqICAgc3RhcnRPZmZzZXQgYW5kIGVuZGluZyBhdCBlbmRPZmZzZXRcbiAgICAgICAgICAgICAgICAgKiAtIEZvdXIgcGFyYW1ldGVycyAoc3RhcnROb2RlLCBzdGFydE9mZnNldCwgZW5kTm9kZSwgZW5kT2Zmc2V0KSBjcmVhdGVzIGEgcmFuZ2Ugc3RhcnRpbmcgYXQgc3RhcnRPZmZzZXQgaW5cbiAgICAgICAgICAgICAgICAgKiAgIHN0YXJ0Tm9kZSBhbmQgZW5kaW5nIGF0IGVuZE9mZnNldCBpbiBlbmROb2RlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2V0U3RhcnRBbmRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjID0gYXJnc1swXSwgc28gPSBhcmdzWzFdLCBlYyA9IHNjLCBlbyA9IHNvO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbyA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWMgPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVvID0gYXJnc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzYywgc28sIGVjLCBlbyk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldEJvdW5kYXJ5OiBmdW5jdGlvbihub2RlLCBvZmZzZXQsIGlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcInNldFwiICsgKGlzU3RhcnQgPyBcIlN0YXJ0XCIgOiBcIkVuZFwiKV0obm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0U3RhcnRCZWZvcmU6IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcih0cnVlLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBzZXRTdGFydEFmdGVyOiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoZmFsc2UsIHRydWUpLFxuICAgICAgICAgICAgICAgIHNldEVuZEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICBzZXRFbmRBZnRlcjogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGZhbHNlLCBmYWxzZSksXG5cbiAgICAgICAgICAgICAgICBjb2xsYXBzZTogZnVuY3Rpb24oaXNTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZWxlY3ROb2RlQ29udGVudHM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgbm9kZSwgMCwgbm9kZSwgZ2V0Tm9kZUxlbmd0aChub2RlKSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNlbGVjdE5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdldEJvdW5kYXJ5QmVmb3JlTm9kZShub2RlKSwgZW5kID0gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZXh0cmFjdENvbnRlbnRzOiBjcmVhdGVSYW5nZUNvbnRlbnRSZW1vdmVyKGV4dHJhY3RTdWJ0cmVlLCBib3VuZGFyeVVwZGF0ZXIpLFxuXG4gICAgICAgICAgICAgICAgZGVsZXRlQ29udGVudHM6IGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIoZGVsZXRlU3VidHJlZSwgYm91bmRhcnlVcGRhdGVyKSxcblxuICAgICAgICAgICAgICAgIGNhblN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnROb2RlTm90UmVhZE9ubHkodGhpcy5zdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLmVuZENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnRzIGNhbiBiZSBzdXJyb3VuZGVkLiBTcGVjaWZpY2FsbHksIHRoaXMgbWVhbnMgd2hldGhlciB0aGUgcmFuZ2UgcGFydGlhbGx5IHNlbGVjdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbm9uLXRleHQgbm9kZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRhcmllc0ludmFsaWQgPSAoaXRlcmF0b3IuX2ZpcnN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpKSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWJvdW5kYXJpZXNJbnZhbGlkO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzcGxpdEJvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFJhbmdlQm91bmRhcmllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc3BsaXRCb3VuZGFyaWVzUHJlc2VydmluZ1Bvc2l0aW9uczogZnVuY3Rpb24ocG9zaXRpb25zVG9QcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFJhbmdlQm91bmRhcmllcyh0aGlzLCBwb3NpdGlvbnNUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjID0gdGhpcy5zdGFydENvbnRhaW5lciwgc28gPSB0aGlzLnN0YXJ0T2Zmc2V0LCBlYyA9IHRoaXMuZW5kQ29udGFpbmVyLCBlbyA9IHRoaXMuZW5kT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZUZvcndhcmQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLm5vZGVUeXBlID09IG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW8gPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZERhdGEoc2libGluZy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZUJhY2t3YXJkID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgPT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUxlbmd0aCA9IG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvID0gc2libGluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnNlcnREYXRhKDAsIHNpYmxpbmcuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MgPT0gZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW8gKz0gc287XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjID0gc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlYyA9PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGdldE5vZGVJbmRleChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVvID09IG5vZGVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWMgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW8gPSBub2RlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVvID4gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlby0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVTdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVvID09IGVjLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlRm9yd2FyZChlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVvID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gZWMucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgPT0gZWMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW8gPSBzaWJsaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjID09IGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYXBwZW5kRGF0YShlYy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjID0gc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW8gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSBlYy5jaGlsZE5vZGVzW2VvIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZE5vZGUgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShlbmROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUZvcndhcmQoZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplU3RhcnQgPSAhdGhpcy5jb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKHNjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQmFja3dhcmQoc2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc28gPT0gc2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBzYy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy5ub2RlVHlwZSA9PSBzYy5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVjID09IHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYyA9IHNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVvICs9IHNjLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmFwcGVuZERhdGEoc2libGluZy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbyA8IHNjLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBzYy5jaGlsZE5vZGVzW3NvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Tm9kZSAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQmFja3dhcmQoc3RhcnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbyA9IGVvO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHNjLCBzbywgZWMsIGVvKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgY29sbGFwc2VUb1BvaW50OiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGFydEFuZEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyhjb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIC8vIFVwZGF0ZXMgY29tbW9uQW5jZXN0b3JDb250YWluZXIgYW5kIGNvbGxhcHNlZCBhZnRlciBib3VuZGFyeSBjaGFuZ2VcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IocmFuZ2UpIHtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlZCA9IChyYW5nZS5zdGFydENvbnRhaW5lciA9PT0gcmFuZ2UuZW5kQ29udGFpbmVyICYmIHJhbmdlLnN0YXJ0T2Zmc2V0ID09PSByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb2xsYXBzZWQgP1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyIDogZG9tLmdldENvbW1vbkFuY2VzdG9yKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQm91bmRhcmllcyhyYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCkge1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0T2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICByYW5nZS5lbmRDb250YWluZXIgPSBlbmRDb250YWluZXI7XG4gICAgICAgICAgICByYW5nZS5lbmRPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICByYW5nZS5kb2N1bWVudCA9IGRvbS5nZXREb2N1bWVudChzdGFydENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yKHJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlKGRvYykge1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRhaW5lciA9IGRvYztcbiAgICAgICAgICAgIHRoaXMuc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5lbmRDb250YWluZXIgPSBkb2M7XG4gICAgICAgICAgICB0aGlzLmVuZE9mZnNldCA9IDA7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jO1xuICAgICAgICAgICAgdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjcmVhdGVQcm90b3R5cGVSYW5nZShSYW5nZSwgdXBkYXRlQm91bmRhcmllcyk7XG5cbiAgICAgICAgdXRpbC5leHRlbmQoUmFuZ2UsIHtcbiAgICAgICAgICAgIHJhbmdlUHJvcGVydGllczogcmFuZ2VQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgUmFuZ2VJdGVyYXRvcjogUmFuZ2VJdGVyYXRvcixcbiAgICAgICAgICAgIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzOiBjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyxcbiAgICAgICAgICAgIGNyZWF0ZVByb3RvdHlwZVJhbmdlOiBjcmVhdGVQcm90b3R5cGVSYW5nZSxcbiAgICAgICAgICAgIGluc3BlY3Q6IGluc3BlY3QsXG4gICAgICAgICAgICB0b0h0bWw6IHJhbmdlVG9IdG1sLFxuICAgICAgICAgICAgZ2V0UmFuZ2VEb2N1bWVudDogZ2V0UmFuZ2VEb2N1bWVudCxcbiAgICAgICAgICAgIHJhbmdlc0VxdWFsOiBmdW5jdGlvbihyMSwgcjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjEuc3RhcnRDb250YWluZXIgPT09IHIyLnN0YXJ0Q29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgIHIxLnN0YXJ0T2Zmc2V0ID09PSByMi5zdGFydE9mZnNldCAmJlxuICAgICAgICAgICAgICAgICAgICByMS5lbmRDb250YWluZXIgPT09IHIyLmVuZENvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgICAgICByMS5lbmRPZmZzZXQgPT09IHIyLmVuZE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXBpLkRvbVJhbmdlID0gUmFuZ2U7XG4gICAgfSk7XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvLyBXcmFwcGVycyBmb3IgdGhlIGJyb3dzZXIncyBuYXRpdmUgRE9NIFJhbmdlIGFuZC9vciBUZXh0UmFuZ2UgaW1wbGVtZW50YXRpb25cbiAgICBhcGkuY3JlYXRlQ29yZU1vZHVsZShcIldyYXBwZWRSYW5nZVwiLCBbXCJEb21SYW5nZVwiXSwgZnVuY3Rpb24oYXBpLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIFdyYXBwZWRSYW5nZSwgV3JhcHBlZFRleHRSYW5nZTtcbiAgICAgICAgdmFyIGRvbSA9IGFwaS5kb207XG4gICAgICAgIHZhciB1dGlsID0gYXBpLnV0aWw7XG4gICAgICAgIHZhciBEb21Qb3NpdGlvbiA9IGRvbS5Eb21Qb3NpdGlvbjtcbiAgICAgICAgdmFyIERvbVJhbmdlID0gYXBpLkRvbVJhbmdlO1xuICAgICAgICB2YXIgZ2V0Qm9keSA9IGRvbS5nZXRCb2R5O1xuICAgICAgICB2YXIgZ2V0Q29udGVudERvY3VtZW50ID0gZG9tLmdldENvbnRlbnREb2N1bWVudDtcbiAgICAgICAgdmFyIGlzQ2hhcmFjdGVyRGF0YU5vZGUgPSBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZTtcblxuXG4gICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgaWYgKGFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgYnJvd3NlcidzIG5hdGl2ZSBET00gUmFuZ2UuIEl0IGhhcyB0d28gYWltczpcbiAgICAgICAgICAgIC8vIC0gUHJvdmlkZSB3b3JrYXJvdW5kcyBmb3Igc3BlY2lmaWMgYnJvd3NlciBidWdzXG4gICAgICAgICAgICAvLyAtIHByb3ZpZGUgY29udmVuaWVudCBleHRlbnNpb25zLCB3aGljaCBhcmUgaW5oZXJpdGVkIGZyb20gUmFuZ3kncyBEb21SYW5nZVxuXG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlUHJvdG87XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlUHJvcGVydGllcyA9IERvbVJhbmdlLnJhbmdlUHJvcGVydGllcztcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlUHJvcGVydGllcyhyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsIHByb3A7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSByYW5nZVByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVtwcm9wXSA9IHJhbmdlLm5hdGl2ZVJhbmdlW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBmb3IgYnJva2VuIGNvbGxhcHNlZCBwcm9wZXJ0eSBpbiBJRSA5LlxuICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZWQgPSAocmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IHJhbmdlLmVuZENvbnRhaW5lciAmJiByYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVOYXRpdmVSYW5nZShyYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNb3ZlZCA9IChyYW5nZS5zdGFydENvbnRhaW5lciAhPT0gc3RhcnRDb250YWluZXIgfHwgcmFuZ2Uuc3RhcnRPZmZzZXQgIT0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTW92ZWQgPSAocmFuZ2UuZW5kQ29udGFpbmVyICE9PSBlbmRDb250YWluZXIgfHwgcmFuZ2UuZW5kT2Zmc2V0ICE9IGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVSYW5nZURpZmZlcmVudCA9ICFyYW5nZS5lcXVhbHMocmFuZ2UubmF0aXZlUmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgYm90aCBib3VuZGFyaWVzIGZvciB0aGUgYmVuZWZpdCBvZiBJRTkgKHNlZSBpc3N1ZSAzNSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0TW92ZWQgfHwgZW5kTW92ZWQgfHwgbmF0aXZlUmFuZ2VEaWZmZXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChlbmRDb250YWluZXIsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcjtcblxuICAgICAgICAgICAgICAgIFdyYXBwZWRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcIldyYXBwZWRSYW5nZTogUmFuZ2UgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIERvbVJhbmdlLmNyZWF0ZVByb3RvdHlwZVJhbmdlKFdyYXBwZWRSYW5nZSwgdXBkYXRlTmF0aXZlUmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90byA9IFdyYXBwZWRSYW5nZS5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNlbGVjdE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLmNsb25lQ29udGVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYSBsb25nLXN0YW5kaW5nIEZpcmVmb3ggYnVnIHRoYXQgSSBoYXZlIG5vdCBiZWVuIGFibGUgdG8gZmluZCBhIHJlbGlhYmxlIHdheSB0byBkZXRlY3QsXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0Tm9kZSgpIGlzIG5ldmVyIGRlbGVnYXRlZCB0byB0aGUgbmF0aXZlIHJhbmdlLlxuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zdXJyb3VuZENvbnRlbnRzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnN1cnJvdW5kQ29udGVudHMobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5jb2xsYXBzZSA9IGZ1bmN0aW9uKGlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5jb2xsYXBzZShpc1N0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLmNsb25lUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkUmFuZ2UodGhpcy5uYXRpdmVSYW5nZS5jbG9uZVJhbmdlKCkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0ZXN0IHJhbmdlIGFuZCBub2RlIGZvciBmZWF0dXJlIGRldGVjdGlvblxuXG4gICAgICAgICAgICAgICAgdmFyIHRlc3RUZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGVzdFwiKTtcbiAgICAgICAgICAgICAgICBnZXRCb2R5KGRvY3VtZW50KS5hcHBlbmRDaGlsZCh0ZXN0VGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIEZpcmVmb3ggMiBidWcgdGhhdCBwcmV2ZW50cyBtb3ZpbmcgdGhlIHN0YXJ0IG9mIGEgUmFuZ2UgdG8gYSBwb2ludCBhZnRlciBpdHMgY3VycmVudCBlbmQgYW5kXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBmb3IgaXRcblxuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRlc3RUZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRlc3RUZXh0Tm9kZSwgMCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnQgPSBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldEVuZCA9IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0ID0gZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZXRFbmQgPSBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyID0gZnVuY3Rpb24obmFtZSwgb3Bwb3NpdGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZVtvcHBvc2l0ZU5hbWVdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW25hbWVdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRTdGFydEJlZm9yZVwiLCBcInNldEVuZEJlZm9yZVwiKTtcbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0QWZ0ZXIgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRTdGFydEFmdGVyXCIsIFwic2V0RW5kQWZ0ZXJcIik7XG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZXRFbmRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRFbmRCZWZvcmVcIiwgXCJzZXRTdGFydEJlZm9yZVwiKTtcbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldEVuZEFmdGVyID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0RW5kQWZ0ZXJcIiwgXCJzZXRTdGFydEFmdGVyXCIpO1xuXG4gICAgICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNlIERPTTQtY29tcGxpYW50IHNlbGVjdE5vZGVDb250ZW50cyBpbXBsZW1lbnRhdGlvbjogaXQncyBzaW1wbGVyIGFuZCBsZXNzIGNvZGUgdGhhbiB0ZXN0aW5nXG4gICAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGNhbiBiZSB0cnVzdGVkXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZWxlY3ROb2RlQ29udGVudHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnRBbmRFbmQobm9kZSwgMCwgZG9tLmdldE5vZGVMZW5ndGgobm9kZSkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIGFuZCBjb3JyZWN0IFdlYktpdCBidWcgdGhhdCBoYXMgdGhlIGJlaGF2aW91ciBvZiBjb21wYXJlQm91bmRhcnlQb2ludHMgcm91bmQgdGhlIHdyb25nIHdheSBmb3JcbiAgICAgICAgICAgICAgICAvLyBjb25zdGFudHMgU1RBUlRfVE9fRU5EIGFuZCBFTkRfVE9fU1RBUlQ6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDczOFxuXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRlc3RUZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRlc3RUZXh0Tm9kZSwgMyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UyID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZTIuc2VsZWN0Tm9kZUNvbnRlbnRzKHRlc3RUZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2UyLnNldEVuZCh0ZXN0VGV4dE5vZGUsIDQpO1xuICAgICAgICAgICAgICAgIHJhbmdlMi5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyYW5nZS5TVEFSVF9UT19FTkQsIHJhbmdlMikgPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyYW5nZS5FTkRfVE9fU1RBUlQsIHJhbmdlMikgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSB3cm9uZyB3YXkgcm91bmQsIHNvIGNvcnJlY3QgZm9yIGl0XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5jb21wYXJlQm91bmRhcnlQb2ludHMgPSBmdW5jdGlvbih0eXBlLCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZS5uYXRpdmVSYW5nZSB8fCByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IHJhbmdlLlNUQVJUX1RPX0VORCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSByYW5nZS5FTkRfVE9fU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gcmFuZ2UuRU5EX1RPX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJhbmdlLlNUQVJUX1RPX0VORDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyh0eXBlLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5jb21wYXJlQm91bmRhcnlQb2ludHMgPSBmdW5jdGlvbih0eXBlLCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKHR5cGUsIHJhbmdlLm5hdGl2ZVJhbmdlIHx8IHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIGRlbGV0ZUNvbnRlbnRzKCkgYW5kIGV4dHJhY3RDb250ZW50cygpIGJ1ZyBhbmQgY29ycmVjdCBpdC4gU2VlIGlzc3VlIDEwNy5cblxuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCIxMjNcIjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gZ2V0Qm9keShkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCAyKTtcbiAgICAgICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRleHROb2RlLmRhdGEgPT0gXCIxM1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJlaGF2aW91ciBpcyBjb3JyZWN0IHBlciBET000IFJhbmdlIHNvIHdyYXAgdGhlIGJyb3dzZXIncyBpbXBsZW1lbnRhdGlvbiBvZiBkZWxldGVDb250ZW50cygpIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBleHRyYWN0Q29udGVudHMoKVxuICAgICAgICAgICAgICAgICAgICByYW5nZVByb3RvLmRlbGV0ZUNvbnRlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5leHRyYWN0Q29udGVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFnID0gdGhpcy5uYXRpdmVSYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgYm9keSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIGV4aXN0ZW5jZSBvZiBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgYW5kIGRlbGVnYXRlIHRvIGl0IGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSG9zdE1ldGhvZChyYW5nZSwgXCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgPSBmdW5jdGlvbihmcmFnbWVudFN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGZyYWdtZW50U3RyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgICAgICAgICAgZ2V0Qm9keShkb2N1bWVudCkucmVtb3ZlQ2hpbGQodGVzdFRleHROb2RlKTtcblxuICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJXcmFwcGVkUmFuZ2VcIjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgYXBpLldyYXBwZWRSYW5nZSA9IFdyYXBwZWRSYW5nZTtcblxuICAgICAgICAgICAgICAgIGFwaS5jcmVhdGVOYXRpdmVSYW5nZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBnZXRDb250ZW50RG9jdW1lbnQoZG9jLCBtb2R1bGUsIFwiY3JlYXRlTmF0aXZlUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyB3aGVyZSBJRSByZXR1cm5zIHRoZSB3cm9uZyBjb250YWluZXIgZWxlbWVudCBmcm9tIHRoZSBUZXh0UmFuZ2UncyBwYXJlbnRFbGVtZW50KClcbiAgICAgICAgICAgIG1ldGhvZC4gRm9yIGV4YW1wbGUsIGluIHRoZSBmb2xsb3dpbmcgKHdoZXJlIHBpcGVzIGRlbm90ZSB0aGUgc2VsZWN0aW9uIGJvdW5kYXJpZXMpOlxuXG4gICAgICAgICAgICA8dWwgaWQ9XCJ1bFwiPjxsaSBpZD1cImFcIj58IGEgPC9saT48bGkgaWQ9XCJiXCI+IGIgfDwvbGk+PC91bD5cblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBhbGVydChyYW5nZS5wYXJlbnRFbGVtZW50KCkuaWQpOyAvLyBTaG91bGQgYWxlcnQgXCJ1bFwiIGJ1dCBhbGVydHMgXCJiXCJcblxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY29tbW9uIGFuY2VzdG9yIG5vZGUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAgIC0gdGhlIHBhcmVudEVsZW1lbnQoKSBvZiB0aGUgdGV4dFJhbmdlXG4gICAgICAgICAgICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZSBhZnRlciBjYWxsaW5nIGNvbGxhcHNlKHRydWUpXG4gICAgICAgICAgICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZSBhZnRlciBjYWxsaW5nIGNvbGxhcHNlKGZhbHNlKVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBnZXRUZXh0UmFuZ2VDb250YWluZXJFbGVtZW50ID0gZnVuY3Rpb24odGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gdGV4dFJhbmdlLnBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RWwgPSByYW5nZS5wYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRFbCA9IHJhbmdlLnBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRFbmRDb250YWluZXIgPSAoc3RhcnRFbCA9PSBlbmRFbCkgPyBzdGFydEVsIDogZG9tLmdldENvbW1vbkFuY2VzdG9yKHN0YXJ0RWwsIGVuZEVsKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEVuZENvbnRhaW5lciA9PSBwYXJlbnRFbCA/IHN0YXJ0RW5kQ29udGFpbmVyIDogZG9tLmdldENvbW1vbkFuY2VzdG9yKHBhcmVudEVsLCBzdGFydEVuZENvbnRhaW5lcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdGV4dFJhbmdlSXNDb2xsYXBzZWQgPSBmdW5jdGlvbih0ZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFJhbmdlLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHRleHRSYW5nZSkgPT0gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEdldHMgdGhlIGJvdW5kYXJ5IG9mIGEgVGV4dFJhbmdlIGV4cHJlc3NlZCBhcyBhIG5vZGUgYW5kIGFuIG9mZnNldCB3aXRoaW4gdGhhdCBub2RlLiBUaGlzIGZ1bmN0aW9uIHN0YXJ0ZWRcbiAgICAgICAgICAgIC8vIG91dCBhcyBhbiBpbXByb3ZlZCB2ZXJzaW9uIG9mIGNvZGUgZm91bmQgaW4gVGltIENhbWVyb24gUnlhbidzIElFUmFuZ2UgKGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9pZXJhbmdlLylcbiAgICAgICAgICAgIC8vIGJ1dCBoYXMgZ3Jvd24sIGZpeGluZyBwcm9ibGVtcyB3aXRoIGxpbmUgYnJlYWtzIGluIHByZWZvcm1hdHRlZCB0ZXh0LCBhZGRpbmcgd29ya2Fyb3VuZCBmb3IgSUUgVGV4dFJhbmdlXG4gICAgICAgICAgICAvLyBidWdzLCBoYW5kbGluZyBmb3IgaW5wdXRzIGFuZCBpbWFnZXMsIHBsdXMgb3B0aW1pemF0aW9ucy5cbiAgICAgICAgICAgIHZhciBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uID0gZnVuY3Rpb24odGV4dFJhbmdlLCB3aG9sZVJhbmdlQ29udGFpbmVyRWxlbWVudCwgaXNTdGFydCwgaXNDb2xsYXBzZWQsIHN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHZhciB3b3JraW5nUmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgICAgICAgICAgd29ya2luZ1JhbmdlLmNvbGxhcHNlKGlzU3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJFbGVtZW50ID0gd29ya2luZ1JhbmdlLnBhcmVudEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBjb2xsYXBzaW5nIGEgVGV4dFJhbmdlIHRoYXQncyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUgY2FuIG1vdmUgaXQgaW50byB0aGUgcHJldmlvdXMgbm9kZSwgc29cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdGhhdFxuICAgICAgICAgICAgICAgIGlmICghZG9tLmlzT3JJc0FuY2VzdG9yT2Yod2hvbGVSYW5nZUNvbnRhaW5lckVsZW1lbnQsIGNvbnRhaW5lckVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSB3aG9sZVJhbmdlQ29udGFpbmVyRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBub2RlcyB0aGF0IGNhbm5vdCBcImNvbnRhaW4gcmljaCBIVE1MIG1hcmt1cFwiLiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyBmb3JtIGlucHV0cywgaW1hZ2VzIGFuZFxuICAgICAgICAgICAgICAgIC8vIHNpbWlsYXIuIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWE3MDM5NTAlMjhWUy44NSUyOS5hc3B4XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJFbGVtZW50LmNhbkhhdmVIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBuZXcgRG9tUG9zaXRpb24oY29udGFpbmVyRWxlbWVudC5wYXJlbnROb2RlLCBkb20uZ2V0Tm9kZUluZGV4KGNvbnRhaW5lckVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4OiBwb3Mub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQ6IHBvcy5ub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHdvcmtpbmdOb2RlID0gZG9tLmdldERvY3VtZW50KGNvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgSFRNTDUgU2hpdidzIGluc2FuZSB2aW9sYXRpb24gb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgpLiBTZWUgUmFuZ3kgaXNzdWUgMTA0IGFuZCBIVE1MNVxuICAgICAgICAgICAgICAgIC8vIFNoaXYgaXNzdWUgNjQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hRmFya2FzL2h0bWw1c2hpdi9pc3N1ZXMvNjRcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZ05vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlTm9kZSh3b3JraW5nTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhcmlzb24sIHdvcmtpbmdDb21wYXJpc29uVHlwZSA9IGlzU3RhcnQgPyBcIlN0YXJ0VG9TdGFydFwiIDogXCJTdGFydFRvRW5kXCI7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzTm9kZSwgbmV4dE5vZGUsIGJvdW5kYXJ5UG9zaXRpb24sIGJvdW5kYXJ5Tm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAoc3RhcnRJbmZvICYmIHN0YXJ0SW5mby5jb250YWluZXJFbGVtZW50ID09IGNvbnRhaW5lckVsZW1lbnQpID8gc3RhcnRJbmZvLm5vZGVJbmRleCA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUNvdW50ID0gY29udGFpbmVyRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gY2hpbGROb2RlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlbmQgZmlyc3QuIENvZGUgd2l0aGluIHRoZSBsb29wIGFzc3VtZXMgdGhhdCB0aGUgZW5kdGggY2hpbGQgbm9kZSBvZiB0aGUgY29udGFpbmVyIGlzIGRlZmluaXRlbHlcbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgcmFuZ2UgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGVuZDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlSW5kZXggPT0gY2hpbGROb2RlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQod29ya2luZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5pbnNlcnRCZWZvcmUod29ya2luZ05vZGUsIGNvbnRhaW5lckVsZW1lbnQuY2hpbGROb2Rlc1tub2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JraW5nUmFuZ2UubW92ZVRvRWxlbWVudFRleHQod29ya2luZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uID0gd29ya2luZ1JhbmdlLmNvbXBhcmVFbmRQb2ludHMod29ya2luZ0NvbXBhcmlzb25UeXBlLCB0ZXh0UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvbiA9PSAwIHx8IHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvbiA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA9PSBzdGFydCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBlbmR0aCBjaGlsZCBub2RlIGlzIGFmdGVyIHRoZSByYW5nZSBib3VuZGFyeSwgc28gd2UgbXVzdCBiZSBkb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChlbmQgPT0gc3RhcnQgKyAxKSA/IHN0YXJ0IDogbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJFbGVtZW50LnJlbW92ZUNoaWxkKHdvcmtpbmdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIG5vdyByZWFjaGVkIG9yIGdvbmUgcGFzdCB0aGUgYm91bmRhcnkgb2YgdGhlIHRleHQgcmFuZ2Ugd2UncmUgaW50ZXJlc3RlZCBpblxuICAgICAgICAgICAgICAgIC8vIHNvIGhhdmUgaWRlbnRpZmllZCB0aGUgbm9kZSB3ZSB3YW50XG4gICAgICAgICAgICAgICAgYm91bmRhcnlOb2RlID0gd29ya2luZ05vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvbiA9PSAtMSAmJiBib3VuZGFyeU5vZGUgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShib3VuZGFyeU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjaGFyYWN0ZXIgZGF0YSBub2RlICh0ZXh0LCBjb21tZW50LCBjZGF0YSkuIFRoZSB3b3JraW5nIHJhbmdlIGlzIGNvbGxhcHNlZCBhdCB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgdGV4dCByYW5nZSdzIGJvdW5kYXJ5LCBzbyB3ZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHdvcmtpbmcgcmFuZ2UgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdW5kYXJ5IHBvaW50IGFuZCBtZWFzdXJlIHRoZSBsZW5ndGggb2YgaXRzIHRleHQgdG8gZ2V0IHRoZSBib3VuZGFyeSdzIG9mZnNldCB3aXRoaW4gdGhlIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmdSYW5nZS5zZXRFbmRQb2ludChpc1N0YXJ0ID8gXCJFbmRUb1N0YXJ0XCIgOiBcIkVuZFRvRW5kXCIsIHRleHRSYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoL1tcXHJcXG5dLy50ZXN0KGJvdW5kYXJ5Tm9kZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvciB0aGUgcGFydGljdWxhciBjYXNlIG9mIGEgYm91bmRhcnkgd2l0aGluIGEgdGV4dCBub2RlIGNvbnRhaW5pbmcgcmVuZGVyZWQgbGluZSBicmVha3MgKHdpdGhpbiBhXG4gICAgICAgICAgICAgICAgICAgICAgICA8cHJlPiBlbGVtZW50LCBmb3IgZXhhbXBsZSksIHdlIG5lZWQgYSBzbGlnaHRseSBjb21wbGljYXRlZCBhcHByb2FjaCB0byBnZXQgdGhlIGJvdW5kYXJ5J3Mgb2Zmc2V0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBJRS4gVGhlIGZhY3RzOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAtIEVhY2ggbGluZSBicmVhayBpcyByZXByZXNlbnRlZCBhcyBcXHIgaW4gdGhlIHRleHQgbm9kZSdzIGRhdGEvbm9kZVZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gRWFjaCBsaW5lIGJyZWFrIGlzIHJlcHJlc2VudGVkIGFzIFxcclxcbiBpbiB0aGUgVGV4dFJhbmdlJ3MgJ3RleHQnIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSAndGV4dCcgcHJvcGVydHkgb2YgdGhlIFRleHRSYW5nZSBkb2VzIG5vdCBjb250YWluIHRyYWlsaW5nIGxpbmUgYnJlYWtzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRvIGdldCByb3VuZCB0aGUgcHJvYmxlbSBwcmVzZW50ZWQgYnkgdGhlIGZpbmFsIGZhY3QgYWJvdmUsIHdlIGNhbiB1c2UgdGhlIGZhY3QgdGhhdCBUZXh0UmFuZ2Unc1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVN0YXJ0KCkgYW5kIG1vdmVFbmQoKSBtZXRob2RzIHJldHVybiB0aGUgYWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1vdmVkLCB3aGljaCBpcyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lY2Vzc2FyaWx5IHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpdCB3YXMgaW5zdHJ1Y3RlZCB0byBtb3ZlLiBUaGUgc2ltcGxlc3QgYXBwcm9hY2ggaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvIHVzZSB0aGlzIHRvIHN0b3JlIHRoZSBjaGFyYWN0ZXJzIG1vdmVkIHdoZW4gbW92aW5nIGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgb2YgdGhlIGRvY3VtZW50IGJvZHkgYW5kIHN1YnRyYWN0aW5nIHRoZSBzdGFydCBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mZnNldCAodGhlXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1vdmUtbmVnYXRpdmUtZ2F6aWxsaW9uXCIgbWV0aG9kKS4gSG93ZXZlciwgdGhpcyBpcyBleHRyZW1lbHkgc2xvdyB3aGVuIHRoZSBkb2N1bWVudCBpcyBsYXJnZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByYW5nZSBpcyBuZWFyIHRoZSBlbmQgb2YgaXQuIENsZWFybHkgZG9pbmcgdGhlIG1pcnJvciBpbWFnZSAoaS5lLiBtb3ZpbmcgdGhlIHJhbmdlIGJvdW5kYXJpZXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50KSBoYXMgdGhlIHNhbWUgcHJvYmxlbS5cblxuICAgICAgICAgICAgICAgICAgICAgICAgQW5vdGhlciBhcHByb2FjaCB0aGF0IHdvcmtzIGlzIHRvIHVzZSBtb3ZlU3RhcnQoKSB0byBtb3ZlIHRoZSBzdGFydCBib3VuZGFyeSBvZiB0aGUgcmFuZ2UgdXAgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgYm91bmRhcnkgb25lIGNoYXJhY3RlciBhdCBhIHRpbWUgYW5kIGluY3JlbWVudGluZyBhIGNvdW50ZXIgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlU3RhcnQoKSBjYWxsLiBIb3dldmVyLCB0aGUgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHN0YXJ0IGJvdW5kYXJ5IGhhcyByZWFjaGVkIHRoZSBlbmQgYm91bmRhcnkgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVuc2l2ZSwgc28gdGhpcyBtZXRob2QgaXMgc2xvdyAoYWx0aG91Z2ggdW5saWtlIFwibW92ZS1uZWdhdGl2ZS1nYXppbGxpb25cIiBpcyBsYXJnZWx5IHVuYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgcmFuZ2Ugd2l0aGluIHRoZSBkb2N1bWVudCkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBhcHByb2FjaCB1c2VkIGJlbG93IGlzIGEgaHlicmlkIG9mIHRoZSB0d28gbWV0aG9kcyBhYm92ZS4gSXQgdXNlcyB0aGUgZmFjdCB0aGF0IGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nIHRoZSBUZXh0UmFuZ2UncyAndGV4dCcgcHJvcGVydHkgd2l0aCBlYWNoIFxcclxcbiBjb252ZXJ0ZWQgdG8gYSBzaW5nbGUgXFxyIGNoYXJhY3RlciBjYW5ub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlIGxvbmdlciB0aGFuIHRoZSB0ZXh0IG9mIHRoZSBUZXh0UmFuZ2UsIHNvIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgaXMgbW92ZWQgdGhhdCBsZW5ndGggaW5pdGlhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlbiBhIGNoYXJhY3RlciBhdCBhIHRpbWUgdG8gbWFrZSB1cCBmb3IgYW55IHRyYWlsaW5nIGxpbmUgYnJlYWtzIG5vdCBjb250YWluZWQgaW4gdGhlICd0ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuIFRoaXMgaGFzIGdvb2QgcGVyZm9ybWFuY2UgaW4gbW9zdCBzaXR1YXRpb25zIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyB0d28gbWV0aG9kcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcFJhbmdlID0gd29ya2luZ1JhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlTGVuZ3RoID0gdGVtcFJhbmdlLnRleHQucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxyXCIpLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGVtcFJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCByYW5nZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChjb21wYXJpc29uID0gdGVtcFJhbmdlLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHRlbXBSYW5nZSkpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHdvcmtpbmdSYW5nZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKGJvdW5kYXJ5Tm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBib3VuZGFyeSBpbW1lZGlhdGVseSBmb2xsb3dzIGEgY2hhcmFjdGVyIGRhdGEgbm9kZSBhbmQgdGhpcyBpcyB0aGUgZW5kIGJvdW5kYXJ5LCB3ZSBzaG91bGQgZmF2b3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcG9zaXRpb24gd2l0aGluIHRoYXQsIGFuZCBsaWtld2lzZSBmb3IgYSBzdGFydCBib3VuZGFyeSBwcmVjZWRpbmcgYSBjaGFyYWN0ZXIgZGF0YSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IChpc0NvbGxhcHNlZCB8fCAhaXNTdGFydCkgJiYgd29ya2luZ05vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IChpc0NvbGxhcHNlZCB8fCBpc1N0YXJ0KSAmJiB3b3JraW5nTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROb2RlICYmIGlzQ2hhcmFjdGVyRGF0YU5vZGUobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKG5leHROb2RlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c05vZGUgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKHByZXZpb3VzTm9kZSwgcHJldmlvdXNOb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UG9zaXRpb24gPSBuZXcgRG9tUG9zaXRpb24oY29udGFpbmVyRWxlbWVudCwgZG9tLmdldE5vZGVJbmRleCh3b3JraW5nTm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlTm9kZSh3b3JraW5nTm9kZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uOiBib3VuZGFyeVBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBub2RlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4OiBub2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJFbGVtZW50OiBjb250YWluZXJFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUmV0dXJucyBhIFRleHRSYW5nZSByZXByZXNlbnRpbmcgdGhlIGJvdW5kYXJ5IG9mIGEgVGV4dFJhbmdlIGV4cHJlc3NlZCBhcyBhIG5vZGUgYW5kIGFuIG9mZnNldCB3aXRoaW4gdGhhdFxuICAgICAgICAgICAgLy8gbm9kZS4gVGhpcyBmdW5jdGlvbiBzdGFydGVkIG91dCBhcyBhbiBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBjb2RlIGZvdW5kIGluIFRpbSBDYW1lcm9uIFJ5YW4ncyBJRVJhbmdlXG4gICAgICAgICAgICAvLyAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2llcmFuZ2UvKVxuICAgICAgICAgICAgdmFyIGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlID0gZnVuY3Rpb24oYm91bmRhcnlQb3NpdGlvbiwgaXNTdGFydCkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeU5vZGUsIGJvdW5kYXJ5UGFyZW50LCBib3VuZGFyeU9mZnNldCA9IGJvdW5kYXJ5UG9zaXRpb24ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQoYm91bmRhcnlQb3NpdGlvbi5ub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgd29ya2luZ05vZGUsIGNoaWxkTm9kZXMsIHdvcmtpbmdSYW5nZSA9IGdldEJvZHkoZG9jKS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUlzRGF0YU5vZGUgPSBpc0NoYXJhY3RlckRhdGFOb2RlKGJvdW5kYXJ5UG9zaXRpb24ubm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZUlzRGF0YU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlOb2RlID0gYm91bmRhcnlQb3NpdGlvbi5ub2RlO1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBhcmVudCA9IGJvdW5kYXJ5Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBib3VuZGFyeVBvc2l0aW9uLm5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlOb2RlID0gKGJvdW5kYXJ5T2Zmc2V0IDwgY2hpbGROb2Rlcy5sZW5ndGgpID8gY2hpbGROb2Rlc1tib3VuZGFyeU9mZnNldF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBhcmVudCA9IGJvdW5kYXJ5UG9zaXRpb24ubm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgcmFuZ2UgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgd29ya2luZ05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtpbmcgdGhlIHdvcmtpbmcgZWxlbWVudCBub24tZW1wdHkgZWxlbWVudCBwZXJzdWFkZXMgSUUgdG8gY29uc2lkZXIgdGhlIFRleHRSYW5nZSBib3VuZGFyeSB0byBiZSB3aXRoaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCByYXRoZXIgdGhhbiBpbW1lZGlhdGVseSBiZWZvcmUgb3IgYWZ0ZXIgaXRcbiAgICAgICAgICAgICAgICB3b3JraW5nTm9kZS5pbm5lckhUTUwgPSBcIiYjZmVmZjtcIjtcblxuICAgICAgICAgICAgICAgIC8vIGluc2VydEJlZm9yZSBpcyBzdXBwb3NlZCB0byB3b3JrIGxpa2UgYXBwZW5kQ2hpbGQgaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgbnVsbC4gSG93ZXZlciwgYSBidWcgcmVwb3J0XG4gICAgICAgICAgICAgICAgLy8gZm9yIElFUmFuZ2Ugc3VnZ2VzdHMgdGhhdCBpdCBjYW4gY3Jhc2ggdGhlIGJyb3dzZXI6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9pZXJhbmdlL2lzc3Vlcy9kZXRhaWw/aWQ9MTJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRhcnlOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50Lmluc2VydEJlZm9yZSh3b3JraW5nTm9kZSwgYm91bmRhcnlOb2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBhcmVudC5hcHBlbmRDaGlsZCh3b3JraW5nTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd29ya2luZ1JhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KHdvcmtpbmdOb2RlKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nUmFuZ2UuY29sbGFwc2UoIWlzU3RhcnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgICAgICBib3VuZGFyeVBhcmVudC5yZW1vdmVDaGlsZCh3b3JraW5nTm9kZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSB3b3JraW5nIHJhbmdlIHRvIHRoZSB0ZXh0IG9mZnNldCwgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICBpZiAobm9kZUlzRGF0YU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZ1JhbmdlW2lzU3RhcnQgPyBcIm1vdmVTdGFydFwiIDogXCJtb3ZlRW5kXCJdKFwiY2hhcmFjdGVyXCIsIGJvdW5kYXJ5T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2luZ1JhbmdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgd3JhcHBlciBhcm91bmQgYSBUZXh0UmFuZ2UsIHByb3ZpZGluZyBmdWxsIERPTSBSYW5nZSBmdW5jdGlvbmFsaXR5IHVzaW5nIHJhbmd5J3MgRG9tUmFuZ2UgYXMgYVxuICAgICAgICAgICAgLy8gcHJvdG90eXBlXG5cbiAgICAgICAgICAgIFdyYXBwZWRUZXh0UmFuZ2UgPSBmdW5jdGlvbih0ZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRSYW5nZSA9IHRleHRSYW5nZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFdyYXBwZWRUZXh0UmFuZ2UucHJvdG90eXBlID0gbmV3IERvbVJhbmdlKGRvY3VtZW50KTtcblxuICAgICAgICAgICAgV3JhcHBlZFRleHRSYW5nZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCwgZW5kLCBzdGFydEJvdW5kYXJ5O1xuXG4gICAgICAgICAgICAgICAgLy8gVGV4dFJhbmdlJ3MgcGFyZW50RWxlbWVudCgpIG1ldGhvZCBjYW5ub3QgYmUgdHJ1c3RlZC4gZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCgpIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgICAgIHZhciByYW5nZUNvbnRhaW5lckVsZW1lbnQgPSBnZXRUZXh0UmFuZ2VDb250YWluZXJFbGVtZW50KHRoaXMudGV4dFJhbmdlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0UmFuZ2VJc0NvbGxhcHNlZCh0aGlzLnRleHRSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlKS5ib3VuZGFyeVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Qm91bmRhcnkgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydEJvdW5kYXJ5LmJvdW5kYXJ5UG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gb3B0aW1pemF0aW9uIHVzZWQgaGVyZSBpcyB0aGF0IGlmIHRoZSBzdGFydCBhbmQgZW5kIGJvdW5kYXJpZXMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQgZWxlbWVudCwgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBzY29wZSBmb3IgdGhlIGVuZCBib3VuZGFyeSBjYW4gYmUgbGltaXRlZCB0byBleGNsdWRlIHRoZSBwb3J0aW9uIG9mIHRoZSBlbGVtZW50IHRoYXQgcHJlY2VkZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGdldFRleHRSYW5nZUJvdW5kYXJ5UG9zaXRpb24odGhpcy50ZXh0UmFuZ2UsIHJhbmdlQ29udGFpbmVyRWxlbWVudCwgZmFsc2UsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRCb3VuZGFyeS5ub2RlSW5mbykuYm91bmRhcnlQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXJ0KHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbmQoZW5kLm5vZGUsIGVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgV3JhcHBlZFRleHRSYW5nZS5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIldyYXBwZWRUZXh0UmFuZ2VcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIERvbVJhbmdlLmNvcHlDb21wYXJpc29uQ29uc3RhbnRzKFdyYXBwZWRUZXh0UmFuZ2UpO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2VUb1RleHRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm91bmRhcnlUZXh0UmFuZ2UobmV3IERvbVBvc2l0aW9uKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFJhbmdlID0gY3JlYXRlQm91bmRhcnlUZXh0UmFuZ2UobmV3IERvbVBvc2l0aW9uKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUmFuZ2UgPSBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UmFuZ2UgPSBnZXRCb2R5KCBEb21SYW5nZS5nZXRSYW5nZURvY3VtZW50KHJhbmdlKSApLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0UmFuZ2Uuc2V0RW5kUG9pbnQoXCJTdGFydFRvU3RhcnRcIiwgc3RhcnRSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRSYW5nZS5zZXRFbmRQb2ludChcIkVuZFRvRW5kXCIsIGVuZFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBXcmFwcGVkVGV4dFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UgPSByYW5nZVRvVGV4dFJhbmdlO1xuXG4gICAgICAgICAgICBXcmFwcGVkVGV4dFJhbmdlLnByb3RvdHlwZS50b1RleHRSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVRvVGV4dFJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYXBpLldyYXBwZWRUZXh0UmFuZ2UgPSBXcmFwcGVkVGV4dFJhbmdlO1xuXG4gICAgICAgICAgICAvLyBJRSA5IGFuZCBhYm92ZSBoYXZlIGJvdGggaW1wbGVtZW50YXRpb25zIGFuZCBSYW5neSBtYWtlcyBib3RoIGF2YWlsYWJsZS4gVGhlIG5leHQgZmV3IGxpbmVzIHNldHMgd2hpY2hcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uIHRvIHVzZSBieSBkZWZhdWx0LlxuICAgICAgICAgICAgaWYgKCFhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlIHx8IGFwaS5jb25maWcucHJlZmVyVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIFdyYXBwZWRUZXh0UmFuZ2UgYXMgdGhlIFJhbmdlIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGFsbG93IGV4cHJlc3Npb24gbGlrZSBSYW5nZS5FTkRfVE9fRU5EIHRvIHdvcmtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsT2JqID0gKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGYoXCJyZXR1cm4gdGhpcztcIikoKTsgfSkoRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsT2JqLlJhbmdlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsT2JqLlJhbmdlID0gV3JhcHBlZFRleHRSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gZ2V0Q29udGVudERvY3VtZW50KGRvYywgbW9kdWxlLCBcImNyZWF0ZU5hdGl2ZVJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qm9keShkb2MpLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBhcGkuV3JhcHBlZFJhbmdlID0gV3JhcHBlZFRleHRSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFwaS5jcmVhdGVSYW5nZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgZG9jID0gZ2V0Q29udGVudERvY3VtZW50KGRvYywgbW9kdWxlLCBcImNyZWF0ZVJhbmdlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhcGkuV3JhcHBlZFJhbmdlKGFwaS5jcmVhdGVOYXRpdmVSYW5nZShkb2MpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBhcGkuY3JlYXRlUmFuZ3lSYW5nZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgZG9jID0gZ2V0Q29udGVudERvY3VtZW50KGRvYywgbW9kdWxlLCBcImNyZWF0ZVJhbmd5UmFuZ2VcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbVJhbmdlKGRvYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdXRpbC5jcmVhdGVBbGlhc0ZvckRlcHJlY2F0ZWRNZXRob2QoYXBpLCBcImNyZWF0ZUlmcmFtZVJhbmdlXCIsIFwiY3JlYXRlUmFuZ2VcIik7XG4gICAgICAgIHV0aWwuY3JlYXRlQWxpYXNGb3JEZXByZWNhdGVkTWV0aG9kKGFwaSwgXCJjcmVhdGVJZnJhbWVSYW5neVJhbmdlXCIsIFwiY3JlYXRlUmFuZ3lSYW5nZVwiKTtcblxuICAgICAgICBhcGkuYWRkU2hpbUxpc3RlbmVyKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jLmNyZWF0ZVJhbmdlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBkb2MuY3JlYXRlUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2MgPSB3aW4gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9KTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8vIFRoaXMgbW9kdWxlIGNyZWF0ZXMgYSBzZWxlY3Rpb24gb2JqZWN0IHdyYXBwZXIgdGhhdCBjb25mb3JtcyBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHRvIHRoZSBTZWxlY3Rpb24gc3BlY2lmaWNhdGlvblxuICAgIC8vIGluIHRoZSBIVE1MIEVkaXRpbmcgc3BlYyAoaHR0cDovL2R2Y3MudzMub3JnL2hnL2VkaXRpbmcvcmF3LWZpbGUvdGlwL2VkaXRpbmcuaHRtbCNzZWxlY3Rpb25zKVxuICAgIGFwaS5jcmVhdGVDb3JlTW9kdWxlKFwiV3JhcHBlZFNlbGVjdGlvblwiLCBbXCJEb21SYW5nZVwiLCBcIldyYXBwZWRSYW5nZVwiXSwgZnVuY3Rpb24oYXBpLCBtb2R1bGUpIHtcbiAgICAgICAgYXBpLmNvbmZpZy5jaGVja1NlbGVjdGlvblJhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgdmFyIEJPT0xFQU4gPSBcImJvb2xlYW5cIjtcbiAgICAgICAgdmFyIE5VTUJFUiA9IFwibnVtYmVyXCI7XG4gICAgICAgIHZhciBkb20gPSBhcGkuZG9tO1xuICAgICAgICB2YXIgdXRpbCA9IGFwaS51dGlsO1xuICAgICAgICB2YXIgaXNIb3N0TWV0aG9kID0gdXRpbC5pc0hvc3RNZXRob2Q7XG4gICAgICAgIHZhciBEb21SYW5nZSA9IGFwaS5Eb21SYW5nZTtcbiAgICAgICAgdmFyIFdyYXBwZWRSYW5nZSA9IGFwaS5XcmFwcGVkUmFuZ2U7XG4gICAgICAgIHZhciBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uO1xuICAgICAgICB2YXIgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb247XG4gICAgICAgIHZhciBnZXROYXRpdmVTZWxlY3Rpb247XG4gICAgICAgIHZhciBzZWxlY3Rpb25Jc0NvbGxhcHNlZDtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gYXBpLmZlYXR1cmVzO1xuICAgICAgICB2YXIgQ09OVFJPTCA9IFwiQ29udHJvbFwiO1xuICAgICAgICB2YXIgZ2V0RG9jdW1lbnQgPSBkb20uZ2V0RG9jdW1lbnQ7XG4gICAgICAgIHZhciBnZXRCb2R5ID0gZG9tLmdldEJvZHk7XG4gICAgICAgIHZhciByYW5nZXNFcXVhbCA9IERvbVJhbmdlLnJhbmdlc0VxdWFsO1xuXG5cbiAgICAgICAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBzdXBwb3J0IGRpcmVjdGlvbiBwYXJhbWV0ZXJzIGluIHRoZSBBUEkgdGhhdCBtYXkgYmUgYSBzdHJpbmcgKFwiYmFja3dhcmRcIiwgXCJiYWNrd2FyZHNcIixcbiAgICAgICAgLy8gXCJmb3J3YXJkXCIgb3IgXCJmb3J3YXJkc1wiKSBvciBhIEJvb2xlYW4gKHRydWUgZm9yIGJhY2t3YXJkcykuXG4gICAgICAgIGZ1bmN0aW9uIGlzRGlyZWN0aW9uQmFja3dhcmQoZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBkaXIgPT0gXCJzdHJpbmdcIikgPyAvXmJhY2t3YXJkKHMpPyQvaS50ZXN0KGRpcikgOiAhIWRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvdyh3aW4sIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICghd2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLmlzV2luZG93KHdpbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW4gaW5zdGFuY2VvZiBXcmFwcGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbi53aW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBkb20uZ2V0Q29udGVudERvY3VtZW50KHdpbiwgbW9kdWxlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmdldFdpbmRvdyhkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0V2luU2VsZWN0aW9uKHdpblBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93KHdpblBhcmFtLCBcImdldFdpblNlbGVjdGlvblwiKS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERvY1NlbGVjdGlvbih3aW5QYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvdyh3aW5QYXJhbSwgXCJnZXREb2NTZWxlY3Rpb25cIikuZG9jdW1lbnQuc2VsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd2luU2VsZWN0aW9uSXNCYWNrd2FyZChzZWwpIHtcbiAgICAgICAgICAgIHZhciBiYWNrd2FyZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbC5hbmNob3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgYmFja3dhcmQgPSAoZG9tLmNvbXBhcmVQb2ludHMoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQsIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCkgPT0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFja3dhcmQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IGZvciB0aGUgUmFuZ2UvVGV4dFJhbmdlIGFuZCBTZWxlY3Rpb24gZmVhdHVyZXMgcmVxdWlyZWRcbiAgICAgICAgLy8gVGVzdCBmb3IgYWJpbGl0eSB0byByZXRyaWV2ZSBzZWxlY3Rpb25cbiAgICAgICAgdmFyIGltcGxlbWVudHNXaW5HZXRTZWxlY3Rpb24gPSBpc0hvc3RNZXRob2Qod2luZG93LCBcImdldFNlbGVjdGlvblwiKSxcbiAgICAgICAgICAgIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gPSB1dGlsLmlzSG9zdE9iamVjdChkb2N1bWVudCwgXCJzZWxlY3Rpb25cIik7XG5cbiAgICAgICAgZmVhdHVyZXMuaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbiA9IGltcGxlbWVudHNXaW5HZXRTZWxlY3Rpb247XG4gICAgICAgIGZlYXR1cmVzLmltcGxlbWVudHNEb2NTZWxlY3Rpb24gPSBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uO1xuXG4gICAgICAgIHZhciB1c2VEb2N1bWVudFNlbGVjdGlvbiA9IGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgKCFpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uIHx8IGFwaS5jb25maWcucHJlZmVyVGV4dFJhbmdlKTtcblxuICAgICAgICBpZiAodXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGdldE5hdGl2ZVNlbGVjdGlvbiA9IGdldERvY1NlbGVjdGlvbjtcbiAgICAgICAgICAgIGFwaS5pc1NlbGVjdGlvblZhbGlkID0gZnVuY3Rpb24od2luUGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZ2V0V2luZG93KHdpblBhcmFtLCBcImlzU2VsZWN0aW9uVmFsaWRcIikuZG9jdW1lbnQsIG5hdGl2ZVNlbCA9IGRvYy5zZWxlY3Rpb247XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gVGV4dFJhbmdlIGlzIGFjdHVhbGx5IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGNvcnJlY3QgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hdGl2ZVNlbC50eXBlICE9IFwiTm9uZVwiIHx8IGdldERvY3VtZW50KG5hdGl2ZVNlbC5jcmVhdGVSYW5nZSgpLnBhcmVudEVsZW1lbnQoKSkgPT0gZG9jKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgZ2V0TmF0aXZlU2VsZWN0aW9uID0gZ2V0V2luU2VsZWN0aW9uO1xuICAgICAgICAgICAgYXBpLmlzU2VsZWN0aW9uVmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIk5laXRoZXIgZG9jdW1lbnQuc2VsZWN0aW9uIG9yIHdpbmRvdy5nZXRTZWxlY3Rpb24oKSBkZXRlY3RlZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhcGkuZ2V0TmF0aXZlU2VsZWN0aW9uID0gZ2V0TmF0aXZlU2VsZWN0aW9uO1xuXG4gICAgICAgIHZhciB0ZXN0U2VsZWN0aW9uID0gZ2V0TmF0aXZlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgLy8gSW4gRmlyZWZveCwgdGhlIHNlbGVjdGlvbiBpcyBudWxsIGluIGFuIGlmcmFtZSB3aXRoIGRpc3BsYXk6IG5vbmUuIFNlZSBpc3N1ZSAjMTM4LlxuICAgICAgICBpZiAoIXRlc3RTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIG1vZHVsZS5mYWlsKFwiTmF0aXZlIHNlbGVjdGlvbiB3YXMgbnVsbCAocG9zc2libHkgaXNzdWUgMTM4PylcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGVzdFJhbmdlID0gYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlKGRvY3VtZW50KTtcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KGRvY3VtZW50KTtcblxuICAgICAgICAvLyBPYnRhaW5pbmcgYSByYW5nZSBmcm9tIGEgc2VsZWN0aW9uXG4gICAgICAgIHZhciBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyA9IHV0aWwuYXJlSG9zdFByb3BlcnRpZXModGVzdFNlbGVjdGlvbixcbiAgICAgICAgICAgIFtcImFuY2hvck5vZGVcIiwgXCJmb2N1c05vZGVcIiwgXCJhbmNob3JPZmZzZXRcIiwgXCJmb2N1c09mZnNldFwiXSk7XG5cbiAgICAgICAgZmVhdHVyZXMuc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cztcblxuICAgICAgICAvLyBUZXN0IGZvciBleGlzdGVuY2Ugb2YgbmF0aXZlIHNlbGVjdGlvbiBleHRlbmQoKSBtZXRob2RcbiAgICAgICAgdmFyIHNlbGVjdGlvbkhhc0V4dGVuZCA9IGlzSG9zdE1ldGhvZCh0ZXN0U2VsZWN0aW9uLCBcImV4dGVuZFwiKTtcbiAgICAgICAgZmVhdHVyZXMuc2VsZWN0aW9uSGFzRXh0ZW5kID0gc2VsZWN0aW9uSGFzRXh0ZW5kO1xuXG4gICAgICAgIC8vIFRlc3QgaWYgcmFuZ2VDb3VudCBleGlzdHNcbiAgICAgICAgdmFyIHNlbGVjdGlvbkhhc1JhbmdlQ291bnQgPSAodHlwZW9mIHRlc3RTZWxlY3Rpb24ucmFuZ2VDb3VudCA9PSBOVU1CRVIpO1xuICAgICAgICBmZWF0dXJlcy5zZWxlY3Rpb25IYXNSYW5nZUNvdW50ID0gc2VsZWN0aW9uSGFzUmFuZ2VDb3VudDtcblxuICAgICAgICB2YXIgc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkUmFuZ2VCYWNrd2FyZFRvTmF0aXZlID0gc2VsZWN0aW9uSGFzRXh0ZW5kID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKG5hdGl2ZVNlbGVjdGlvbiwgcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gRG9tUmFuZ2UuZ2V0UmFuZ2VEb2N1bWVudChyYW5nZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgICAgICAgZW5kUmFuZ2UuY29sbGFwc2VUb1BvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBuYXRpdmVTZWxlY3Rpb24uYWRkUmFuZ2UoZ2V0TmF0aXZlUmFuZ2UoZW5kUmFuZ2UpKTtcbiAgICAgICAgICAgICAgICBuYXRpdmVTZWxlY3Rpb24uZXh0ZW5kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICB9IDogbnVsbDtcblxuICAgICAgICBpZiAodXRpbC5hcmVIb3N0TWV0aG9kcyh0ZXN0U2VsZWN0aW9uLCBbXCJhZGRSYW5nZVwiLCBcImdldFJhbmdlQXRcIiwgXCJyZW1vdmVBbGxSYW5nZXNcIl0pICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRlc3RTZWxlY3Rpb24ucmFuZ2VDb3VudCA9PSBOVU1CRVIgJiYgZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2aW91c2x5IGFuIGlmcmFtZSB3YXMgdXNlZCBidXQgdGhpcyBjYXVzZWQgcHJvYmxlbXMgaW4gc29tZSBjaXJjdW1zdGFuY2VzIGluIElFLCBzbyB0ZXN0cyBhcmVcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnQncyBzZWxlY3Rpb24uIFNlZSBpc3N1ZSAxMDkuXG5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIGFsc28gdGhhdCBpZiBhIHNlbGVjdGlvbiBwcmV2aW91c2x5IGV4aXN0ZWQsIGl0IGlzIHdpcGVkIGFuZCBsYXRlciByZXN0b3JlZCBieSB0aGVzZSB0ZXN0cy4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIHRoZSBzZWxlY3Rpb24gZGlyZWN0aW9uIGJlZ2luIHJldmVyc2VkIGlmIHRoZSBvcmlnaW5hbCBzZWxlY3Rpb24gd2FzIGJhY2t3YXJkcyBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgYmFja3dhcmRzIHNlbGVjdGlvbnMgKEludGVybmV0IEV4cGxvcmVyLCBJJ20gbG9va2luZyBhdCB5b3UpLlxuICAgICAgICAgICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2VsZWN0aW9uUmFuZ2VDb3VudCA9IHNlbC5yYW5nZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSGFzTXVsdGlwbGVSYW5nZXMgPSAob3JpZ2luYWxTZWxlY3Rpb25SYW5nZUNvdW50ID4gMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbFNlbGVjdGlvblJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxTZWxlY3Rpb25CYWNrd2FyZCA9IHdpblNlbGVjdGlvbklzQmFja3dhcmQoc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbFNlbGVjdGlvblJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTZWxlY3Rpb25SYW5nZXNbaV0gPSBzZWwuZ2V0UmFuZ2VBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBzb21lIHRlc3QgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RFbCA9IGRvbS5jcmVhdGVUZXN0RWxlbWVudChkb2N1bWVudCwgXCJcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSB0ZXN0RWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFx1MDBhMFxcdTAwYTBcXHUwMGEwXCIpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCB3aGV0aGVyIHRoZSBuYXRpdmUgc2VsZWN0aW9uIHdpbGwgYWxsb3cgYSBjb2xsYXBzZWQgc2VsZWN0aW9uIHdpdGhpbiBhIG5vbi1lZGl0YWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciByMSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcjEuc2V0U3RhcnQodGV4dE5vZGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICByMS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocjEpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQgPSAoc2VsLnJhbmdlQ291bnQgPT0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIG5hdGl2ZSBzZWxlY3Rpb24gaXMgY2FwYWJsZSBvZiBzdXBwb3J0aW5nIG11bHRpcGxlIHJhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25IYXNNdWx0aXBsZVJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9pbmcgdGhlIG9yaWdpbmFsIGZlYXR1cmUgdGVzdCBoZXJlIGluIENocm9tZSAzNiAoYW5kIHByZXN1bWFibHkgbGF0ZXIgdmVyc2lvbnMpIHByaW50cyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlIGVycm9yIG9mIFwiRGlzY29udGlndW91cyBzZWxlY3Rpb24gaXMgbm90IHN1cHBvcnRlZC5cIiB0aGF0IGNhbm5vdCBiZSBzdXBwcmVzc2VkLiBUaGVyZSdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHdlIGNhbiBkbyBhYm91dCB0aGlzIHdoaWxlIHJldGFpbmluZyB0aGUgZmVhdHVyZSB0ZXN0IHNvIHdlIGhhdmUgdG8gcmVzb3J0IHRvIGEgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc25pZmYuIEknbSBub3QgaGFwcHkgYWJvdXQgaXQuIFNlZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM5OTc5MVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNocm9tZU1hdGNoID0gd2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9DaHJvbWVcXC8oLio/KSAvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHJvbWVNYXRjaCAmJiBwYXJzZUludChjaHJvbWVNYXRjaFsxXSkgPj0gMzYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByMiA9IHIxLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByMS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjIuc2V0RW5kKHRleHROb2RlLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByMi5zZXRTdGFydCh0ZXh0Tm9kZSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHIxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMgPSAoc2VsLnJhbmdlQ291bnQgPT0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlTm9kZSh0ZXN0RWwpO1xuICAgICAgICAgICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsU2VsZWN0aW9uUmFuZ2VDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwICYmIG9yaWdpbmFsU2VsZWN0aW9uQmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkUmFuZ2VCYWNrd2FyZFRvTmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlQmFja3dhcmRUb05hdGl2ZShzZWwsIG9yaWdpbmFsU2VsZWN0aW9uUmFuZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkud2FybihcIlJhbmd5IGluaXRpYWxpemF0aW9uOiBvcmlnaW5hbCBzZWxlY3Rpb24gd2FzIGJhY2t3YXJkcyBidXQgc2VsZWN0aW9uIGhhcyBiZWVuIHJlc3RvcmVkIGZvcndhcmRzIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBTZWxlY3Rpb24uZXh0ZW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2Uob3JpZ2luYWxTZWxlY3Rpb25SYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmFkZFJhbmdlKG9yaWdpbmFsU2VsZWN0aW9uUmFuZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmZWF0dXJlcy5zZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzID0gc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcztcbiAgICAgICAgZmVhdHVyZXMuY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkID0gY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkO1xuXG4gICAgICAgIC8vIENvbnRyb2xSYW5nZXNcbiAgICAgICAgdmFyIGltcGxlbWVudHNDb250cm9sUmFuZ2UgPSBmYWxzZSwgdGVzdENvbnRyb2xSYW5nZTtcblxuICAgICAgICBpZiAoYm9keSAmJiBpc0hvc3RNZXRob2QoYm9keSwgXCJjcmVhdGVDb250cm9sUmFuZ2VcIikpIHtcbiAgICAgICAgICAgIHRlc3RDb250cm9sUmFuZ2UgPSBib2R5LmNyZWF0ZUNvbnRyb2xSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKHV0aWwuYXJlSG9zdFByb3BlcnRpZXModGVzdENvbnRyb2xSYW5nZSwgW1wiaXRlbVwiLCBcImFkZFwiXSkpIHtcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRzQ29udHJvbFJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5pbXBsZW1lbnRzQ29udHJvbFJhbmdlID0gaW1wbGVtZW50c0NvbnRyb2xSYW5nZTtcblxuICAgICAgICAvLyBTZWxlY3Rpb24gY29sbGFwc2VkbmVzc1xuICAgICAgICBpZiAoc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklzQ29sbGFwc2VkID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09PSBzZWwuZm9jdXNOb2RlICYmIHNlbC5hbmNob3JPZmZzZXQgPT09IHNlbC5mb2N1c09mZnNldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IGZ1bmN0aW9uKHNlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWwucmFuZ2VDb3VudCA/IHNlbC5nZXRSYW5nZUF0KHNlbC5yYW5nZUNvdW50IC0gMSkuY29sbGFwc2VkIDogZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tUmFuZ2Uoc2VsLCByYW5nZSwgYmFja3dhcmQpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3JQcmVmaXggPSBiYWNrd2FyZCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIsIGZvY3VzUHJlZml4ID0gYmFja3dhcmQgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUgPSByYW5nZVthbmNob3JQcmVmaXggKyBcIkNvbnRhaW5lclwiXTtcbiAgICAgICAgICAgIHNlbC5hbmNob3JPZmZzZXQgPSByYW5nZVthbmNob3JQcmVmaXggKyBcIk9mZnNldFwiXTtcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgPSByYW5nZVtmb2N1c1ByZWZpeCArIFwiQ29udGFpbmVyXCJdO1xuICAgICAgICAgICAgc2VsLmZvY3VzT2Zmc2V0ID0gcmFuZ2VbZm9jdXNQcmVmaXggKyBcIk9mZnNldFwiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbU5hdGl2ZVNlbGVjdGlvbihzZWwpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVTZWwgPSBzZWwubmF0aXZlU2VsZWN0aW9uO1xuICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUgPSBuYXRpdmVTZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgICAgIHNlbC5hbmNob3JPZmZzZXQgPSBuYXRpdmVTZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSA9IG5hdGl2ZVNlbC5mb2N1c05vZGU7XG4gICAgICAgICAgICBzZWwuZm9jdXNPZmZzZXQgPSBuYXRpdmVTZWwuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVFbXB0eVNlbGVjdGlvbihzZWwpIHtcbiAgICAgICAgICAgIHNlbC5hbmNob3JOb2RlID0gc2VsLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBzZWwuYW5jaG9yT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHNlbC5yYW5nZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgICAgICBzZWwuX3Jhbmdlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVSYW5nZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIERvbVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlUmFuZ2UgPSBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UocmFuZ2UuZ2V0RG9jdW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgbmF0aXZlUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBuYXRpdmVSYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZSBpbnN0YW5jZW9mIFdyYXBwZWRSYW5nZSkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZVJhbmdlID0gcmFuZ2UubmF0aXZlUmFuZ2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSAmJiAocmFuZ2UgaW5zdGFuY2VvZiBkb20uZ2V0V2luZG93KHJhbmdlLnN0YXJ0Q29udGFpbmVyKS5SYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmFuZ2VDb250YWluc1NpbmdsZUVsZW1lbnQocmFuZ2VOb2Rlcykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZU5vZGVzLmxlbmd0aCB8fCByYW5nZU5vZGVzWzBdLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gcmFuZ2VOb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghZG9tLmlzQW5jZXN0b3JPZihyYW5nZU5vZGVzWzBdLCByYW5nZU5vZGVzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSByYW5nZS5nZXROb2RlcygpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zU2luZ2xlRWxlbWVudChub2RlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtb2R1bGUuY3JlYXRlRXJyb3IoXCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlOiByYW5nZSBcIiArIHJhbmdlLmluc3BlY3QoKSArIFwiIGRpZCBub3QgY29uc2lzdCBvZiBhIHNpbmdsZSBlbGVtZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2ltcGxlLCBxdWljayB0ZXN0IHdoaWNoIG9ubHkgbmVlZHMgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhIFRleHRSYW5nZSBhbmQgYSBDb250cm9sUmFuZ2VcbiAgICAgICAgZnVuY3Rpb24gaXNUZXh0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXJhbmdlICYmIHR5cGVvZiByYW5nZS50ZXh0ICE9IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIFJhbmdlIGZyb20gdGhlIHNlbGVjdGVkIFRleHRSYW5nZVxuICAgICAgICAgICAgdmFyIHdyYXBwZWRSYW5nZSA9IG5ldyBXcmFwcGVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgc2VsLl9yYW5nZXMgPSBbd3JhcHBlZFJhbmdlXTtcblxuICAgICAgICAgICAgdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tUmFuZ2Uoc2VsLCB3cmFwcGVkUmFuZ2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbC5yYW5nZUNvdW50ID0gMTtcbiAgICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHdyYXBwZWRSYW5nZS5jb2xsYXBzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgICAgICBzZWwuX3Jhbmdlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBcIk5vbmVcIikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSBzZWwuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dFJhbmdlKGNvbnRyb2xSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYXNlICh3aGVyZSB0aGUgc2VsZWN0aW9uIHR5cGUgaXMgXCJDb250cm9sXCIgYW5kIGNhbGxpbmcgY3JlYXRlUmFuZ2UoKSBvbiB0aGUgc2VsZWN0aW9uIHJldHVybnNcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBUZXh0UmFuZ2UpIGNhbiBoYXBwZW4gaW4gSUUgOS4gSXQgaGFwcGVucywgZm9yIGV4YW1wbGUsIHdoZW4gYWxsIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBDb250cm9sUmFuZ2UgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgQ29udHJvbFJhbmdlIGFuZCByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgY29udHJvbFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWwucmFuZ2VDb3VudCA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSwgZG9jID0gZ2V0RG9jdW1lbnQoY29udHJvbFJhbmdlLml0ZW0oMCkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5fcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHNlbC5yYW5nZUNvdW50ID09IDEgJiYgc2VsLl9yYW5nZXNbMF0uY29sbGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHNlbC5fcmFuZ2VzW3NlbC5yYW5nZUNvdW50IC0gMV0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRSYW5nZVRvQ29udHJvbFNlbGVjdGlvbihzZWwsIHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbFJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlRWxlbWVudCA9IGdldFNpbmdsZUVsZW1lbnRGcm9tUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgQ29udHJvbFJhbmdlIGNvbnRhaW5pbmcgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2VsZWN0ZWQgQ29udHJvbFJhbmdlIHBsdXMgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGNvbnRhaW5lZCBieSB0aGUgc3VwcGxpZWQgcmFuZ2VcbiAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgICAgICB2YXIgbmV3Q29udHJvbFJhbmdlID0gZ2V0Qm9keShkb2MpLmNyZWF0ZUNvbnRyb2xSYW5nZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xSYW5nZS5hZGQoY29udHJvbFJhbmdlLml0ZW0oaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKHJhbmdlRWxlbWVudCk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcImFkZFJhbmdlKCk6IEVsZW1lbnQgd2l0aGluIHRoZSBzcGVjaWZpZWQgUmFuZ2UgY291bGQgbm90IGJlIGFkZGVkIHRvIGNvbnRyb2wgc2VsZWN0aW9uIChkb2VzIGl0IGhhdmUgbGF5b3V0PylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdDb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCdzIG5vdyBpbiB0aGUgbmF0aXZlIHNlbGVjdGlvblxuICAgICAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldFNlbGVjdGlvblJhbmdlQXQ7XG5cbiAgICAgICAgaWYgKGlzSG9zdE1ldGhvZCh0ZXN0U2VsZWN0aW9uLCBcImdldFJhbmdlQXRcIikpIHtcbiAgICAgICAgICAgIC8vIHRyeS9jYXRjaCBpcyBwcmVzZW50IGJlY2F1c2UgZ2V0UmFuZ2VBdCgpIG11c3QgaGF2ZSB0aHJvd24gYW4gZXJyb3IgaW4gc29tZSBicm93c2VyIGFuZCBzb21lIHNpdHVhdGlvbi5cbiAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEkgZGlkbid0IHdyaXRlIGEgY29tbWVudCBhYm91dCB0aGUgc3BlY2lmaWNzIGFuZCBhbSBub3cgc2NhcmVkIHRvIHRha2UgaXQgb3V0LiBMZXQgdGhhdCBiZSBhXG4gICAgICAgICAgICAvLyBsZXNzb24gdG8gdXMgYWxsLCBlc3BlY2lhbGx5IG1lLlxuICAgICAgICAgICAgZ2V0U2VsZWN0aW9uUmFuZ2VBdCA9IGZ1bmN0aW9uKHNlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsLmdldFJhbmdlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMpIHtcbiAgICAgICAgICAgIGdldFNlbGVjdGlvblJhbmdlQXQgPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QW5kRW5kKHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0LCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gdGhlIHNlbGVjdGlvbiB3YXMgc2VsZWN0ZWQgYmFja3dhcmRzIChmcm9tIHRoZSBlbmQgdG8gdGhlIHN0YXJ0IGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQgIT09IHRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBbmRFbmQoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIFdyYXBwZWRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2NTZWxlY3Rpb24sIHdpbikge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICB0aGlzLmRvY1NlbGVjdGlvbiA9IGRvY1NlbGVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy53aW4gPSB3aW47XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFdyYXBwZWRTZWxlY3Rpb24ucHJvdG90eXBlID0gYXBpLnNlbGVjdGlvblByb3RvdHlwZTtcblxuICAgICAgICBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0aWVzKHNlbCkge1xuICAgICAgICAgICAgc2VsLndpbiA9IHNlbC5hbmNob3JOb2RlID0gc2VsLmZvY3VzTm9kZSA9IHNlbC5fcmFuZ2VzID0gbnVsbDtcbiAgICAgICAgICAgIHNlbC5yYW5nZUNvdW50ID0gc2VsLmFuY2hvck9mZnNldCA9IHNlbC5mb2N1c09mZnNldCA9IDA7XG4gICAgICAgICAgICBzZWwuZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhY2hlZFJhbmd5U2VsZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFjdE9uQ2FjaGVkU2VsZWN0aW9uKHdpbiwgYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGNhY2hlZFJhbmd5U2VsZWN0aW9ucy5sZW5ndGgsIGNhY2hlZCwgc2VsO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZCA9IGNhY2hlZFJhbmd5U2VsZWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBzZWwgPSBjYWNoZWQuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXCJkZWxldGVBbGxcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0aWVzKHNlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYWNoZWQud2luID09IHdpbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFJhbmd5U2VsZWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IFwiZGVsZXRlQWxsXCIpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRSYW5neVNlbGVjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBhcmFtZXRlciBpcyBhIFJhbmd5IFNlbGVjdGlvbiBvYmplY3RcbiAgICAgICAgICAgIGlmICh3aW4gJiYgd2luIGluc3RhbmNlb2YgV3JhcHBlZFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHdpbi5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2luID0gZ2V0V2luZG93KHdpbiwgXCJnZXROYXRpdmVTZWxlY3Rpb25cIik7XG5cbiAgICAgICAgICAgIHZhciBzZWwgPSBhY3RPbkNhY2hlZFNlbGVjdGlvbih3aW4pO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVNlbCA9IGdldE5hdGl2ZVNlbGVjdGlvbih3aW4pLCBkb2NTZWwgPSBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uID8gZ2V0RG9jU2VsZWN0aW9uKHdpbikgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHNlbCkge1xuICAgICAgICAgICAgICAgIHNlbC5uYXRpdmVTZWxlY3Rpb24gPSBuYXRpdmVTZWw7XG4gICAgICAgICAgICAgICAgc2VsLmRvY1NlbGVjdGlvbiA9IGRvY1NlbDtcbiAgICAgICAgICAgICAgICBzZWwucmVmcmVzaCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWwgPSBuZXcgV3JhcHBlZFNlbGVjdGlvbihuYXRpdmVTZWwsIGRvY1NlbCwgd2luKTtcbiAgICAgICAgICAgICAgICBjYWNoZWRSYW5neVNlbGVjdGlvbnMucHVzaCggeyB3aW46IHdpbiwgc2VsZWN0aW9uOiBzZWwgfSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbDtcbiAgICAgICAgfTtcblxuICAgICAgICBhcGkuZ2V0U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uO1xuXG4gICAgICAgIHV0aWwuY3JlYXRlQWxpYXNGb3JEZXByZWNhdGVkTWV0aG9kKGFwaSwgXCJnZXRJZnJhbWVTZWxlY3Rpb25cIiwgXCJnZXRTZWxlY3Rpb25cIik7XG5cbiAgICAgICAgdmFyIHNlbFByb3RvID0gV3JhcHBlZFNlbGVjdGlvbi5wcm90b3R5cGU7XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ29udHJvbFNlbGVjdGlvbihzZWwsIHJhbmdlcykge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbGVjdGlvbiBiZWNvbWVzIG9mIHR5cGUgXCJDb250cm9sXCJcbiAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChyYW5nZXNbMF0uc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IGdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbCwgbGVuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbFJhbmdlLmFkZChlbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwic2V0UmFuZ2VzKCk6IEVsZW1lbnQgd2l0aGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIFJhbmdlcyBjb3VsZCBub3QgYmUgYWRkZWQgdG8gY29udHJvbCBzZWxlY3Rpb24gKGRvZXMgaXQgaGF2ZSBsYXlvdXQ/KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCdzIG5vdyBpbiB0aGUgbmF0aXZlIHNlbGVjdGlvblxuICAgICAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0aW5nIGEgcmFuZ2VcbiAgICAgICAgaWYgKCF1c2VEb2N1bWVudFNlbGVjdGlvbiAmJiBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyAmJiB1dGlsLmFyZUhvc3RNZXRob2RzKHRlc3RTZWxlY3Rpb24sIFtcInJlbW92ZUFsbFJhbmdlc1wiLCBcImFkZFJhbmdlXCJdKSkge1xuICAgICAgICAgICAgc2VsUHJvdG8ucmVtb3ZlQWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYWRkUmFuZ2VCYWNrd2FyZCA9IGZ1bmN0aW9uKHNlbCwgcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBhZGRSYW5nZUJhY2t3YXJkVG9OYXRpdmUoc2VsLm5hdGl2ZVNlbGVjdGlvbiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIHNlbC5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uSGFzUmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHNlbFByb3RvLmFkZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmIHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlyZWN0aW9uQmFja3dhcmQoZGlyZWN0aW9uKSAmJiBzZWxlY3Rpb25IYXNFeHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZUJhY2t3YXJkKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUmFuZ2VDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1JhbmdlQ291bnQgPSB0aGlzLnJhbmdlQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSYW5nZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIG5hdGl2ZSByYW5nZSBzbyB0aGF0IGNoYW5naW5nIHRoZSBzZWxlY3RlZCByYW5nZSBkb2VzIG5vdCBhZmZlY3QgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGNvbnRyYXJ5IHRvIHRoZSBzcGVjIGJ1dCBpcyB0aGUgb25seSB3YXkgdG8gYWNoaWV2ZSBjb25zaXN0ZW5jeSBiZXR3ZWVuIGJyb3dzZXJzLiBTZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpc3N1ZSA4MC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmVkTmF0aXZlUmFuZ2UgPSBnZXROYXRpdmVSYW5nZShyYW5nZSkuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uLmFkZFJhbmdlKGNsb25lZE5hdGl2ZVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYWRkaW5nIHRoZSByYW5nZSB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMubmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09IHByZXZpb3VzUmFuZ2VDb3VudCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHdhcyBhZGRlZCBzdWNjZXNzZnVsbHlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByYW5nZSB0aGF0IHdlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gaXMgcmVmbGVjdGVkIGluIHRoZSBsYXN0IHJhbmdlIGV4dHJhY3RlZCBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwaS5jb25maWcuY2hlY2tTZWxlY3Rpb25SYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVSYW5nZSA9IGdldFNlbGVjdGlvblJhbmdlQXQodGhpcy5uYXRpdmVTZWxlY3Rpb24sIHRoaXMucmFuZ2VDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVJhbmdlICYmICFyYW5nZXNFcXVhbChuYXRpdmVSYW5nZSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFwcGVucyBpbiBXZWJLaXQgd2l0aCwgZm9yIGV4YW1wbGUsIGEgc2VsZWN0aW9uIHBsYWNlZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBXcmFwcGVkUmFuZ2UobmF0aXZlUmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jhbmdlc1t0aGlzLnJhbmdlQ291bnQgLSAxXSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZSh0aGlzLCByYW5nZSwgc2VsZWN0aW9uSXNCYWNrd2FyZCh0aGlzLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHdhcyBub3QgYWRkZWQgc3VjY2Vzc2Z1bGx5LiBUaGUgc2ltcGxlc3QgdGhpbmcgaXMgdG8gcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxQcm90by5hZGRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlyZWN0aW9uQmFja3dhcmQoZGlyZWN0aW9uKSAmJiBzZWxlY3Rpb25IYXNFeHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlQmFja3dhcmQodGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24uYWRkUmFuZ2UoZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgaW1wbGVtZW50c0RvY1NlbGVjdGlvbiAmJiByYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDb250cm9sU2VsZWN0aW9uKHRoaXMsIHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJlbXB0eVwiKSAmJiBpc0hvc3RNZXRob2QodGVzdFJhbmdlLCBcInNlbGVjdFwiKSAmJlxuICAgICAgICAgICAgICAgICAgIGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgdXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcblxuICAgICAgICAgICAgc2VsUHJvdG8ucmVtb3ZlQWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkZWQgdHJ5L2NhdGNoIGFzIGZpeCBmb3IgaXNzdWUgIzIxXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NTZWxlY3Rpb24uZW1wdHkoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZW1wdHkoKSBub3Qgd29ya2luZyAoaXNzdWUgIzI0KVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSAhPSBcIk5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZmFpbHVyZSB0byBlbXB0eSBhIGNvbnRyb2wgc2VsZWN0aW9uIGJ5IGluc3RlYWQgc2VsZWN0aW5nIGEgVGV4dFJhbmdlIGFuZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIGVtcHR5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmNob3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZ2V0RG9jdW1lbnQodGhpcy5hbmNob3JOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHRoaXMuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZ2V0RG9jdW1lbnQoIGNvbnRyb2xSYW5nZS5pdGVtKDApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UmFuZ2UgPSBnZXRCb2R5KGRvYykuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jU2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7fVxuICAgICAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2VsUHJvdG8uYWRkUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5XcmFwcGVkVGV4dFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UocmFuZ2UpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZXNbMF0gPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IHRoaXMuX3Jhbmdlc1swXS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHRoaXMsIHJhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VDb3VudCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIk5vIG1lYW5zIG9mIHNlbGVjdGluZyBhIFJhbmdlIG9yIFRleHRSYW5nZSB3YXMgZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxQcm90by5nZXRSYW5nZUF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOREVYX1NJWkVfRVJSXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgcmFuZ2UgdG8gcHJlc2VydmUgc2VsZWN0aW9uLXJhbmdlIGluZGVwZW5kZW5jZS4gU2VlIGlzc3VlIDgwLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5nZXNbaW5kZXhdLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVmcmVzaFNlbGVjdGlvbjtcblxuICAgICAgICBpZiAodXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKGFwaS5pc1NlbGVjdGlvblZhbGlkKHNlbC53aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZ2V0Qm9keShzZWwud2luLmRvY3VtZW50KS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dFJhbmdlKHJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJnZXRSYW5nZUF0XCIpICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLnJhbmdlQ291bnQgPT0gTlVNQkVSKSB7XG4gICAgICAgICAgICByZWZyZXNoU2VsZWN0aW9uID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgaW1wbGVtZW50c0RvY1NlbGVjdGlvbiAmJiBzZWwuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsLl9yYW5nZXMubGVuZ3RoID0gc2VsLnJhbmdlQ291bnQgPSBzZWwubmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbC5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuX3Jhbmdlc1tpXSA9IG5ldyBhcGkuV3JhcHBlZFJhbmdlKHNlbC5uYXRpdmVTZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHNlbC5fcmFuZ2VzW3NlbC5yYW5nZUNvdW50IC0gMV0sIHNlbGVjdGlvbklzQmFja3dhcmQoc2VsLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLmlzQ29sbGFwc2VkID09IEJPT0xFQU4gJiYgdHlwZW9mIHRlc3RSYW5nZS5jb2xsYXBzZWQgPT0gQk9PTEVBTiAmJiBmZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UpIHtcbiAgICAgICAgICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UsIG5hdGl2ZVNlbCA9IHNlbC5uYXRpdmVTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVNlbC5hbmNob3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZ2V0U2VsZWN0aW9uUmFuZ2VBdChuYXRpdmVTZWwsIDApO1xuICAgICAgICAgICAgICAgICAgICBzZWwuX3JhbmdlcyA9IFtyYW5nZV07XG4gICAgICAgICAgICAgICAgICAgIHNlbC5yYW5nZUNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKHNlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmZhaWwoXCJObyBtZWFucyBvZiBvYnRhaW5pbmcgYSBSYW5nZSBvciBUZXh0UmFuZ2UgZnJvbSB0aGUgdXNlcidzIHNlbGVjdGlvbiB3YXMgZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxQcm90by5yZWZyZXNoID0gZnVuY3Rpb24oY2hlY2tGb3JDaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgb2xkUmFuZ2VzID0gY2hlY2tGb3JDaGFuZ2VzID8gdGhpcy5fcmFuZ2VzLnNsaWNlKDApIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBvbGRBbmNob3JOb2RlID0gdGhpcy5hbmNob3JOb2RlLCBvbGRBbmNob3JPZmZzZXQgPSB0aGlzLmFuY2hvck9mZnNldDtcblxuICAgICAgICAgICAgcmVmcmVzaFNlbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIGlmIChjaGVja0ZvckNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgY291bnQgZmlyc3RcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG9sZFJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gdGhpcy5fcmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgdGhlIGRpcmVjdGlvbi4gQ2hlY2tpbmcgdGhlIGFuY2hvciBwb3NpdGlvbiBpcyB0aGUgc2FtZSBpcyBlbm91Z2ggc2luY2Ugd2UncmUgY2hlY2tpbmcgYWxsIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJhbmdlcyBhZnRlciB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5jaG9yTm9kZSAhPSBvbGRBbmNob3JOb2RlIHx8IHRoaXMuYW5jaG9yT2Zmc2V0ICE9IG9sZEFuY2hvck9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBjb21wYXJlIGVhY2ggcmFuZ2UgaW4gdHVyblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYW5nZXNFcXVhbChvbGRSYW5nZXNbaV0sIHRoaXMuX3Jhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZW1vdmFsIG9mIGEgc2luZ2xlIHJhbmdlXG4gICAgICAgIHZhciByZW1vdmVSYW5nZU1hbnVhbGx5ID0gZnVuY3Rpb24oc2VsLCByYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHNlbC5nZXRBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlc0VxdWFsKHJhbmdlLCByYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2VFbGVtZW50ID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IENvbnRyb2xSYW5nZSBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBtaW51cyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBjb250YWluZWQgYnkgdGhlIHN1cHBsaWVkIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb250cm9sUmFuZ2UgPSBnZXRCb2R5KGRvYykuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCwgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGNvbnRyb2xSYW5nZS5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsICE9PSByYW5nZUVsZW1lbnQgfHwgcmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xSYW5nZS5hZGQoY29udHJvbFJhbmdlLml0ZW0oaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmFuZ2VNYW51YWxseSh0aGlzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVSYW5nZU1hbnVhbGx5KHRoaXMsIHJhbmdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3RpbmcgaWYgYSBzZWxlY3Rpb24gaXMgYmFja3dhcmRcbiAgICAgICAgdmFyIHNlbGVjdGlvbklzQmFja3dhcmQ7XG4gICAgICAgIGlmICghdXNlRG9jdW1lbnRTZWxlY3Rpb24gJiYgc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgJiYgZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Jc0JhY2t3YXJkID0gd2luU2VsZWN0aW9uSXNCYWNrd2FyZDtcblxuICAgICAgICAgICAgc2VsUHJvdG8uaXNCYWNrd2FyZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Jc0JhY2t3YXJkKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklzQmFja3dhcmQgPSBzZWxQcm90by5pc0JhY2t3YXJkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEZyb20gMS4zLCBldmVyeXRoaW5nIGlzIFwiYmFja3dhcmRcIiByYXRoZXIgdGhhbiBcImJhY2t3YXJkc1wiXG4gICAgICAgIHNlbFByb3RvLmlzQmFja3dhcmRzID0gc2VsUHJvdG8uaXNCYWNrd2FyZDtcblxuICAgICAgICAvLyBTZWxlY3Rpb24gc3RyaW5naWZpZXJcbiAgICAgICAgLy8gVGhpcyBpcyBjb25mb3JtYW50IHRvIHRoZSBvbGQgSFRNTDUgc2VsZWN0aW9ucyBkcmFmdCBzcGVjIGJ1dCBkaWZmZXJzIGZyb20gV2ViS2l0IGFuZCBNb3ppbGxhJ3MgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHNwZWMgZG9lcyBub3QgeWV0IGRlZmluZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgc2VsUHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVRleHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICByYW5nZVRleHRzW2ldID0gXCJcIiArIHRoaXMuX3Jhbmdlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZVRleHRzLmpvaW4oXCJcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50KHNlbCwgbm9kZSkge1xuICAgICAgICAgICAgaWYgKHNlbC53aW4uZG9jdW1lbnQgIT0gZ2V0RG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gY3VycmVudCBicm93c2VyIGNvbmZvcm1zIGZ1bGx5IHRvIHRoZSBzcGVjIGZvciB0aGlzIG1ldGhvZCwgc28gUmFuZ3kncyBvd24gbWV0aG9kIGlzIGFsd2F5cyB1c2VkXG4gICAgICAgIHNlbFByb3RvLmNvbGxhcHNlID0gZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBhc3NlcnROb2RlSW5TYW1lRG9jdW1lbnQodGhpcywgbm9kZSk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2Uobm9kZSk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZVRvUG9pbnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2luZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uY29sbGFwc2VUb1N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLmNvbGxhcHNlVG9FbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZXNbdGhpcy5yYW5nZUNvdW50IC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGUgc3BlYyBpcyB2ZXJ5IHNwZWNpZmljIG9uIGhvdyBzZWxlY3RBbGxDaGlsZHJlbiBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYW5kIG5vdCBhbGwgYnJvd3NlcnMgaW1wbGVtZW50IGl0IGFzXG4gICAgICAgIC8vIHNwZWNpZmllZCBzbyB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIG5ldmVyIHVzZWQgYnkgUmFuZ3kuXG4gICAgICAgIHNlbFByb3RvLnNlbGVjdEFsbENoaWxkcmVuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50KHRoaXMsIG5vZGUpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKG5vZGUpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZXRTaW5nbGVSYW5nZShyYW5nZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uZGVsZXRlRnJvbURvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTZXBjaWFsIGJlaGF2aW91ciByZXF1aXJlZCBmb3IgSUUncyBjb250cm9sIHNlbGVjdGlvbnNcbiAgICAgICAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgdGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHRoaXMuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGNvbnRyb2xSYW5nZS5pdGVtKDApO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sUmFuZ2UucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLmdldEFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlc1tpXS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzcGVjIHNheXMgbm90aGluZyBhYm91dCB3aGF0IHRoZSBzZWxlY3Rpb24gc2hvdWxkIGNvbnRhaW4gYWZ0ZXIgY2FsbGluZyBkZWxldGVDb250ZW50cyBvbiBlYWNoXG4gICAgICAgICAgICAgICAgICAgIC8vIHJhbmdlLiBGaXJlZm94IG1vdmVzIHRoZSBzZWxlY3Rpb24gdG8gd2hlcmUgdGhlIGZpbmFsIHNlbGVjdGVkIHJhbmdlIHdhcywgc28gd2UgZW11bGF0ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2VzW2xlbiAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgbm9uLXN0YW5kYXJkIGV4dGVuc2lvbnNcbiAgICAgICAgc2VsUHJvdG8uZWFjaFJhbmdlID0gZnVuY3Rpb24oZnVuYywgcmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIGZ1bmMoIHRoaXMuZ2V0UmFuZ2VBdChpKSApICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLmdldEFsbFJhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5lYWNoUmFuZ2UoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uc2V0U2luZ2xlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5jYWxsTWV0aG9kT25FYWNoUmFuZ2UgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICB0aGlzLmVhY2hSYW5nZSggZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIHJhbmdlW21ldGhvZE5hbWVdLmFwcGx5KHJhbmdlLCBwYXJhbXMgfHwgW10pICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTdGFydE9yRW5kU2V0dGVyKGlzU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbXCJzZXRcIiArIChpc1N0YXJ0ID8gXCJTdGFydFwiIDogXCJFbmRcIildKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UodGhpcy53aW4uZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFuZEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFNpbmdsZVJhbmdlKHJhbmdlLCB0aGlzLmlzQmFja3dhcmQoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsUHJvdG8uc2V0U3RhcnQgPSBjcmVhdGVTdGFydE9yRW5kU2V0dGVyKHRydWUpO1xuICAgICAgICBzZWxQcm90by5zZXRFbmQgPSBjcmVhdGVTdGFydE9yRW5kU2V0dGVyKGZhbHNlKTtcblxuICAgICAgICAvLyBBZGQgc2VsZWN0KCkgbWV0aG9kIHRvIFJhbmdlIHByb3RvdHlwZS4gQW55IGV4aXN0aW5nIHNlbGVjdGlvbiB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgIGFwaS5yYW5nZVByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGdldFNlbGVjdGlvbiggdGhpcy5nZXREb2N1bWVudCgpICkuc2V0U2luZ2xlUmFuZ2UodGhpcywgZGlyZWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5jaGFuZ2VFYWNoUmFuZ2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICAgICAgICB2YXIgYmFja3dhcmQgPSB0aGlzLmlzQmFja3dhcmQoKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoUmFuZ2UoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmdW5jKHJhbmdlKTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIGlmIChiYWNrd2FyZCAmJiByYW5nZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJhbmdlKHJhbmdlc1swXSwgXCJiYWNrd2FyZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5jb250YWluc05vZGUgPSBmdW5jdGlvbihub2RlLCBhbGxvd1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2hSYW5nZSggZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UuY29udGFpbnNOb2RlKG5vZGUsIGFsbG93UGFydGlhbCk7XG4gICAgICAgICAgICB9LCB0cnVlICkgfHwgZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uZ2V0Qm9va21hcmsgPSBmdW5jdGlvbihjb250YWluZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJhY2t3YXJkOiB0aGlzLmlzQmFja3dhcmQoKSxcbiAgICAgICAgICAgICAgICByYW5nZUJvb2ttYXJrczogdGhpcy5jYWxsTWV0aG9kT25FYWNoUmFuZ2UoXCJnZXRCb29rbWFya1wiLCBbY29udGFpbmVyTm9kZV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLm1vdmVUb0Jvb2ttYXJrID0gZnVuY3Rpb24oYm9va21hcmspIHtcbiAgICAgICAgICAgIHZhciBzZWxSYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByYW5nZUJvb2ttYXJrLCByYW5nZTsgcmFuZ2VCb29rbWFyayA9IGJvb2ttYXJrLnJhbmdlQm9va21hcmtzW2krK107ICkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKHRoaXMud2luKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlVG9Cb29rbWFyayhyYW5nZUJvb2ttYXJrKTtcbiAgICAgICAgICAgICAgICBzZWxSYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm9va21hcmsuYmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNpbmdsZVJhbmdlKHNlbFJhbmdlc1swXSwgXCJiYWNrd2FyZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZXMoc2VsUmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5zYXZlUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJhY2t3YXJkOiB0aGlzLmlzQmFja3dhcmQoKSxcbiAgICAgICAgICAgICAgICByYW5nZXM6IHRoaXMuY2FsbE1ldGhvZE9uRWFjaFJhbmdlKFwiY2xvbmVSYW5nZVwiKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5yZXN0b3JlUmFuZ2VzID0gZnVuY3Rpb24oc2VsUmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHJhbmdlOyByYW5nZSA9IHNlbFJhbmdlcy5yYW5nZXNbaV07ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2UsIChzZWxSYW5nZXMuYmFja3dhcmQgJiYgaSA9PSAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8udG9IdG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VIdG1scyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5lYWNoUmFuZ2UoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZUh0bWxzLnB1c2goIERvbVJhbmdlLnRvSHRtbChyYW5nZSkgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlSHRtbHMuam9pbihcIlwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgICAgICAgICAgc2VsUHJvdG8uZ2V0TmF0aXZlVGV4dFJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbCwgdGV4dFJhbmdlO1xuICAgICAgICAgICAgICAgIGlmICggKHNlbCA9IHRoaXMuZG9jU2VsZWN0aW9uKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RleHRSYW5nZShyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcImdldE5hdGl2ZVRleHRSYW5nZTogc2VsZWN0aW9uIGlzIGEgY29udHJvbCBzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5XcmFwcGVkVGV4dFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UoIHRoaXMuZ2V0UmFuZ2VBdCgwKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcImdldE5hdGl2ZVRleHRSYW5nZTogc2VsZWN0aW9uIGNvbnRhaW5zIG5vIHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNwZWN0KHNlbCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlSW5zcGVjdHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBuZXcgRG9tUG9zaXRpb24oc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gbmV3IERvbVBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICh0eXBlb2Ygc2VsLmdldE5hbWUgPT0gXCJmdW5jdGlvblwiKSA/IHNlbC5nZXROYW1lKCkgOiBcIlNlbGVjdGlvblwiO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbC5yYW5nZUNvdW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsLnJhbmdlQ291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZUluc3BlY3RzW2ldID0gRG9tUmFuZ2UuaW5zcGVjdChzZWwuZ2V0UmFuZ2VBdChpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgbmFtZSArIFwiKFJhbmdlczogXCIgKyByYW5nZUluc3BlY3RzLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiKShhbmNob3I6IFwiICsgYW5jaG9yLmluc3BlY3QoKSArIFwiLCBmb2N1czogXCIgKyBmb2N1cy5pbnNwZWN0KCkgKyBcIl1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBcIldyYXBwZWRTZWxlY3Rpb25cIjtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdCh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFjdE9uQ2FjaGVkU2VsZWN0aW9uKHRoaXMud2luLCBcImRlbGV0ZVwiKTtcbiAgICAgICAgICAgIGRlbGV0ZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgV3JhcHBlZFNlbGVjdGlvbi5kZXRhY2hBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFjdE9uQ2FjaGVkU2VsZWN0aW9uKG51bGwsIFwiZGVsZXRlQWxsXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFdyYXBwZWRTZWxlY3Rpb24uaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgICAgIFdyYXBwZWRTZWxlY3Rpb24uaXNEaXJlY3Rpb25CYWNrd2FyZCA9IGlzRGlyZWN0aW9uQmFja3dhcmQ7XG5cbiAgICAgICAgYXBpLlNlbGVjdGlvbiA9IFdyYXBwZWRTZWxlY3Rpb247XG5cbiAgICAgICAgYXBpLnNlbGVjdGlvblByb3RvdHlwZSA9IHNlbFByb3RvO1xuXG4gICAgICAgIGFwaS5hZGRTaGltTGlzdGVuZXIoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbi5nZXRTZWxlY3Rpb24gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHdpbi5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFNlbGVjdGlvbih3aW4pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW4gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGxvYWQgYmVmb3JlIGluaXRpYWxpemluZ1xyXG4gICAgdmFyIGRvY1JlYWR5ID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmICghZG9jUmVhZHkpIHtcclxuICAgICAgICAgICAgZG9jUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIWFwaS5pbml0aWFsaXplZCAmJiBhcGkuY29uZmlnLmF1dG9Jbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0Jyb3dzZXIpIHtcclxuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIGRvY3VtZW50IGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIGFuZCBpbml0aWFsaXplIGltbWVkaWF0ZWx5IGlmIHNvXHJcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gXCJjb21wbGV0ZVwiKSB7XHJcbiAgICAgICAgICAgIGxvYWRIYW5kbGVyKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJhZGRFdmVudExpc3RlbmVyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBsb2FkSGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgYSBmYWxsYmFjayBpbiBjYXNlIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50IGlzbid0IHN1cHBvcnRlZFxyXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcih3aW5kb3csIFwibG9hZFwiLCBsb2FkSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbn0sIHRoaXMpOyJdfQ==
